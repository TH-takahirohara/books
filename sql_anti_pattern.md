SQLアンチパターン

# 2章 ナイーブツリー（素朴な木）
## 目的
- 階層構造を格納し、クエリを発行する

## アンチパターン
- 隣接リスト　parent_idを持たせて親子関係を表す方法
  - DBで本来シンプルかつ効率的に行えるべきことでも、多くのコードが必要になってしまう。

## 解決策
- 隣接リストモデルの代替となるものには、経路列挙モデル、入子集合モデル、閉包テーブルモデルなどがある。

# 3章 IDリクワイアド（とりあえずID）
## 目的：主キーの規約を確立する
- 意味を持たない人工的な値を主キーにする場合（例：id列）、このタイプの主キー列を疑似キーや代理キーと呼ぶ場合がある。

## アンチパターン：すべてのテーブルに「id」列を用いる

## アンチパターンを用いても良い場合
- 「設定より規約」を原則としたORMフレームワークを使い、その規約で列名id・データ型整数の疑似キーを採用している場合

## 解決策：状況に応じて適切に調整する
- わかりやすい列名にしよう
  - メタデータの命名規則について、Joe Celko 「SQL Programming Style」でSQLに焦点を当てた解説が読める。
- 規約に縛られない
- 自然キー（自然に主キーに使えそうな列）と復号キーの活用

# 4章 キーレスエントリ（外部キー嫌い）
## 目的：データベースのアーキテクチャを単純化する
- 参照整合性は極めて重要。
- 外部キー制約

## アンチパターン：外部キー制約を使用しない
- 外部キー制約が邪魔になると考える開発者もいるが、外部キーを用いてシンプルかつ効率的に複数テーブルの更新と削除を行う方法はある。（後述）

## 解決策：外部キー制約を宣言する
- DBへの登録時点でデータ不整合のミスを防止できる。
- 外部キーには、カスケード更新という機能がある
  - これを使うと、親の行の更新や削除が可能になり、さらにその行を参照しているあらゆる子の行もDBが適切に処理してくれる。

SQLアンチパターン

# 2章 ナイーブツリー（素朴な木）
## 目的
- 階層構造を格納し、クエリを発行する

## アンチパターン
- 隣接リスト　parent_idを持たせて親子関係を表す方法
  - DBで本来シンプルかつ効率的に行えるべきことでも、多くのコードが必要になってしまう。

## 解決策
- 隣接リストモデルの代替となるものには、経路列挙モデル、入子集合モデル、閉包テーブルモデルなどがある。

# 3章 IDリクワイアド（とりあえずID）
## 目的：主キーの規約を確立する
- 意味を持たない人工的な値を主キーにする場合（例：id列）、このタイプの主キー列を疑似キーや代理キーと呼ぶ場合がある。

## アンチパターン：すべてのテーブルに「id」列を用いる

## アンチパターンを用いても良い場合
- 「設定より規約」を原則としたORMフレームワークを使い、その規約で列名id・データ型整数の疑似キーを採用している場合

## 解決策：状況に応じて適切に調整する
- わかりやすい列名にしよう
  - メタデータの命名規則について、Joe Celko 「SQL Programming Style」でSQLに焦点を当てた解説が読める。
- 規約に縛られない
- 自然キー（自然に主キーに使えそうな列）と復号キーの活用

# 4章 キーレスエントリ（外部キー嫌い）
## 目的：データベースのアーキテクチャを単純化する
- 参照整合性は極めて重要。
- 外部キー制約

## アンチパターン：外部キー制約を使用しない
- 外部キー制約が邪魔になると考える開発者もいるが、外部キーを用いてシンプルかつ効率的に複数テーブルの更新と削除を行う方法はある。（後述）

## 解決策：外部キー制約を宣言する
- DBへの登録時点でデータ不整合のミスを防止できる。
- 外部キーには、カスケード更新という機能がある
  - これを使うと、親の行の更新や削除が可能になり、さらにその行を参照しているあらゆる子の行もDBが適切に処理してくれる。

# 5章 EAV(エンティティ・アトリビュート・バリュー)
## 目的：可変属性をサポートする

## アンチパターン：汎用的な属性テーブルを使用する
- EAVは、属性をattr_name, attr_valueのような形式で行ごとに格納する方法
- この方法はメリットが期待されるように見えるが、従来型のDB設計で得られるいくつもの利点を失ってしまう。

## 解決策：サブタイプのモデリングを行う
- 解決策がうまく機能するのは、サブタイプの数が限られ、開発者が各サブタイプの属性をよく知っているとき

### シングルテーブル継承
- 関連するすべてのサブタイプを1つのテーブルに格納
- この採用が適切なのは、サブタイプの数とサブタイプ固有の属性の数が少なく、アクティブレコードのような単一のテーブルに対するデータベースアクセスパターンを使う必要がある場合

### 具象テーブル継承
- サブタイプごとにテーブルを作成
- すべてのサブタイプをまたいだ検索を実行する頻度が低い場合に適切

### クラステーブル継承
- テーブルをオブジェクト指向のクラスであるかのようにみなして、継承を模倣するという方法
- すべてのサブタイプに共通する列を参照するクエリが頻繁に実行されるときに適している

### 半構造化データ
- LOB（Large Object）列にJSONなどの形式で属性名と値をともに格納する
- この設計の長所は、拡張性が極めて高いこと。短所は、SQLが特定の属性にアクセスする手段をほとんど持たないこと。
- サブタイプの数を制限できない場合や、新しい属性を随時定義するための高い柔軟性が必要な場合に適している。

# 6章 ポリモーフィック関連
## 目的：複数の親テーブルを参照する

## アンチパターン：二重目的の外部キーを使用する
- ポリモーフィック関連
- 外部キー制約を使えないので、参照整合性が保証されない
- 色々と注意点が出てくる

## アンチパターンを用いても良い場合
- 成熟した実績あるフレームワークを選べば、ポリモーフィック関連がきちんと実装されていることが期待できる場合もある。

## 解決策：関連（リレーションシップ）を単純化する
- ポリモーフィック関連では、「本来あるべき関連が、逆さまになっている」
- 交差テーブルを作成する方法
- 共通の親テーブルを作成する方法

# 7章 マルチカラムアトリビュート（複数列属性）
## 目的：複数の値を持つ属性を格納する

## アンチパターン：複数の列を定義する

## アンチパターンを用いてもよい場合
- 属性値の選択肢の順番が重大な意味を持つ場合

## 解決策：従属テーブルを作成する
- 最善の解決策は、属性を格納する列を1つ持つ従属テーブルを作壊死し、属性を格納すること。属性値を複数の列ではなく、複数の行に格納する。

# 8章 メタデータトリブル（メタデータ大増殖）
## 目的：スケーラビリティを高める
- この章の目的は、クエリの実行速度を劣化させずに、データが増加し続けるテーブルに対応できるよう、データベースの構造を設計すること。

## アンチパターン：テーブルや列をコピーする
- 「すべてのテーブルの行は少ない方がいい」という誤った考えのもと、以下のアンチパターンに陥る。
  - 行数の多いテーブルを、複数のテーブルに分割する
  - 列を複数列に分割する

## 解決策：パーティショニングと正規化を行う
- テーブルサイズが巨大化した場合に、パフォーマンスを改善するよい方法は下記
  - 水平パーティショニング、垂直パーティショニング、従属テーブルの導入
- 水平パーティショニング（シャーディング）の使用：　テーブルを行で分割
- 垂直パーティショニングの使用：　テーブルを列で分割する。列の一部のサイズが大きい場合や、めったに使用されない場合にメリットがある。

# II部 データベース物理設計のアンチパターン

# 9章 ラウンディングエラー（丸め誤差)
## 目的：整数の代わりに小数値を使用する

## アンチパターン：FLOATデータ型を使用する
- 丸めが避けられない。10進数で有限精度で表せる値でも、2進数形式では無限精度が必要になり、丸められることがある。
- 実質上、FLOAT、REAL、DOUBLE PRECISIONなどのデータ型を用いると、完全に正確な値は期待できないと考えるべき。

## 解決策：NUMERICデータ型を使用する
- NUMERICまたはDECIMALを用いて、固定精度の小数点数を表すようにする。
- 精度（使用可能な10進数の桁数の総数）、スケール（小数点以下に格納できる桁数）を指定する。
- NUMERICおよびDECIMAL型の長所は、有理数を丸めることなく格納できる点

# 10章 サーティワンのフレーバー（３１のフレーバー）
## 目的：列を特定の値に限定する

## アンチパターン：限定する値を（テーブルの）列定義で指定する
- 許可されている列挙値を取得するのが厄介
- 列を再定義する場合も厄介な作業となる

## アンチパターンを用いてもよい場合
- 有効値の変更が不要だと断言できる場合（例：相互排他的な2つの値（左/右など）を指定する場合など）

## 解決策：限定する値をデータで指定する
- 参照テーブルを作成し、許可する値を1行に1つずつ格納する。

# 11章 ファントムファイル（幻のファイル）
## 目的：画像をはじめとする大容量メディアファイルを格納する

## アンチパターン：物理ファイルの使用を必須と思い込む
- 大多数のプログラマーは、ファイルを参照する場合、ファイルを常にデータベースの外部に格納し、データベースではファイルのパスを格納するという意見を持っている。
- ファイル削除時の問題
- ロールバック時における問題
- など　デメリットがある

## アンチパターンを用いてもよい場合
- 画像のようなデータサイズの大きいオブジェクトをデータベース外部のファイルに格納することには、いくつもの正当な理由がある。　データベースの容量を減らせるなど。
- それらの利点がプロジェクトにとって特に重要であり、この章で述べた問題点も深刻にならないなら、画像をDB外部に格納するという方法を採用してもよい。

## 解決策：必要に応じてBLOB型を採用する
- MySQLのLOAD_FILE関数は、ファイルの読み込みと、内容のBLOB列への格納に使用できる。BLOB列の内容をファイルに保存することもできる。

# 12章 インデックスショットガン（闇雲インデックス）
## 目的：パフォーマンスを最適化する
- データベースのパフォーマンスを改善する最善の方法は、インデックスを効果的に使用すること。

## アンチパターン：闇雲にインデックスを使用する
- インデックスをまったく定義しないか、少ししかインデックスを定義しなくなってしまう。
- インデックスを多く定義しすぎるか、役立たないインデックスを定義してしまう。
- インデックスを活用しないクエリを実行してしまう。

## 解決策：「MENTOR」の原則に基づいて効果的なインデックス管理を行う
- MENTORとは、Measure（測定）, Explain（解析）, Nominate（指名）, Test（テスト）, Optimize（最適化）, Rebuild（再構築）の頭文字をとったもの
- 最重要なルールは、推測のみに基づいて、闇雲にインデックスをつけてはならないということ。

### Measure
- MySQLでは、スロークエリログという機能がある。閾値より実行時間が長くかかったクエリを記録できる。
- 本番環境に配備したアプリケーションに対してプロファイリングを行うことで、より正確な情報を取得できる。

### Explain
- クエリ実行計画（QEP）

### Nominate
#### カバーリングインデックス
- クエリがインデックスのデータ構造に含まれている列のみを参照する場合、データベースはインデックスのみを読み込んで（インデックスの対象テーブルの行を読み込まず）クエリ結果を生成する。

## Optimize
- キャッシュメモリ　キャッシュに割り当てるメモリの量はどのくらいにすべきか。絶対的な答えはない。

## Rebuild
- 定期的なメンテナンスを行う価値はある。各種DB製品では、インデックスのメンテナンス機能を有している。

# Ⅲ部 クエリのアンチパターン

# 13章 フィア・オブ・ジ・アンノウン（恐怖のunknown）
## 目的：欠けている値を区別する
- この章の目的は、NULLを含む列に対してクエリを書くこと

## アンチパターン：NULLを一般値として使う、または一般値をNULLとして使う
- NULLを含む行(例えばhours)に対して、hours + 10のような操作をすると、hoursがNULLの場合は結果がNULLになってしまう。

## 解決策：NULLを一意な値として使う
- NULLの問題のほとんどは、SQLの3値論理の振る舞いについての誤解に基づいている。
- 理解の鍵は、「NULLはTRUEでもFALSEでもない」という概念である。
- IS NULL, IS NOT NULL, IS DISTINCT FROM
- NULLがアプリケーションのポリシーに反する場合や、その列においてNULLが意味をなさない場合には、列にNOT NULL制約を宣言するのがよい。
- COALESCE関数　可変長引数をとり、最初の非NULLの引数を返す。

# 14章 アンビギュアスグループ（曖昧なグループ）
## 目的：グループ内で最大値を持つ行を取得する
- この章の目的は、グループ内の最大値（または最小値や平均値）だけでなく、その最大値が見つかった行の他の属性も取得するクエリを実行すること。

## アンチパターン：非グループ化列を参照する
- 単一値の原則：　GOURP BYを使ったクエリで、SELECT句の選択リストに列挙されるすべての列は、グループごとに単一の値でなければならない
- 単一値の原則に反するクエリは、多くの場合は曖昧な結果を返すことになる。
- ほとんどのDB製品では、単一値の原則に反するクエリを作成すると、エラーが返される。ただし、SQLiteとMySQLでは、曖昧な列に予期しない値や信頼性が低い値が返されることがある。

## アンチパターンを用いてもよい場合
- 関数従属を期待したクエリを使う場合
  - グループ化列に対して関数従属となる列をSELECT句に含むようなケース

## 解決策：曖昧でない列を使用する
- 関数従属性のある列のみにクエリを実行する
- 相関サブクエリを使用する
- 導出テーブルを使用する
- JOINを使用する　仕組みを理解するのは簡単でなく、保守も難しいが、概してサブクエリベースの解決策よりもパフォーマンスが優れている
- 他の列に対しても集約関数を使用する
- グループごとにすべての値を連結する　GROUP_CONCAT（MySQL, SQLiteの場合）
- 結論：曖昧なクエリ結果を避けるために、単一値の原則に従う

# 15章 ランダムセレクション
## 目的：（ランダムな）サンプル行をフェッチする

## アンチパターン：データをランダムにソートする
- ランダム行を取得するための最も一般的な方法は、ランダムにソートを行、最初の行を取得するというもの。
- 非決定性を持つ式（RAND関数）によってソートを行うということは、インデックスからメリットを得られないということを意味する。
- データセットのサイズが大きくなるにつれて、パフォーマンスの違いが顕著になる
- テーブルスキャン：　DBが、クエリ結果をインデックスを使わずに「手作業で」ソートすること

## 解決策：特定の順番に依存しない
- 1と最大値の間のランダムなキー値を選択する
- 欠番の穴の後にあるキー値を選択する
- すべてのキー値のリストを受け取り、ランダムに1つを選択する
- オフセットを用いてランダムに行を選択する　データセットの行数をカウントし、0と行数までの間の乱数を取得。次に、取得した乱数分のOFFSETをかけてLIMIT 1と合わせてクエリを実行する。
- ベンダー依存の解決策

# 16章 プアマンズ・サーチエンジン（貧者のサーチエンジン）
## 目的：全文検索を行う

## アンチパターン：パターンマッチ述語を使用する
- パターンマッチ述語　LIKE述語など
- パターンマッチ述語の最も大きな問題点は、パフォーマンスの低下。インデックスのメリットを得られないため、テーブルのすべての行をスキャンしなければならない。また、LIKEや正規表現を用いた単純なパターンマッチでは、意図しないマッチが生じてしまう。

## 解決策：適切なツールを使用する
- 最善の方法は、SQLの代わりに専用の全文検索エンジンを使うこと。次善の策は、繰り返しのコストを減らすために検索結果を保存すること。
- MySQLのフルテキストインデックス
- Oracleでのテキストインデックス
- Microsoft SQL Serverでの全文検索
- PostgreSQLでのテキスト検索
- SQLiteでの全文検索（FTS）
- サードパーティーのサーチエンジン
  - Sphinx Search
  - Apache Lucene
- 転置インデックスの自作

# 17章 スパゲッティクエリ
## 目的：SQLクエリの数を減らす

## アンチパターン：複雑な問題をワンステップで解決しようとする
- 1つのクエリで2つのタスクを実現しようとした結果、意図しないデカルト積が頻繁に生まれる。

## 解決策：分割統治を行う
- 節約の原則：　まったく同じ予測をする2つの競合する理論があるときは、単純な方が優れている
- クエリを複数に分割する
- 複数のクエリの結果は、UNIONによって1つの結果セットにまとめることができる。結果をソートしなければならない場合などに効果的。
- CASE式とSUM関数を組み合わせる
- SQLを用いたSQLの自動的な記述　コード生成

# 18章 インプリシットカラム（暗黙の列）
## 目的：タイプ数（=タイピングの量）を減らす
- SQLクエリで、すべての列名を指定せず、ワイルドカード機能を使ったり、列を明示的に書かないことでステートメントを短くできる。

## アンチパターン：ショートカットの罠に陥る
- しかし、ワイルドカードや暗黙的な列の指定を行った場合、列の追加や削除によって、既存のクエリが使えなくなったり、テーブルを参照するアプリケーションコードにおいて予期せぬ結果を得るようになることがある。

## 解決策：列名を明示的に指定する
- ワイルドカードや暗黙的な列指定は使わずに、必要な列名は明示的に指定するようにする。

# Ⅳ部 アプリケーション開発のアンチパターン

# 19章 リーダブルパスワード（読み取り可能パスワード）
## 目的：パスワードのリカバリーとリセットを行う

## アンチパターン：パスワードを平文で格納する

## 解決策：ソルトを付けてパスワードハッシュを格納する
- 暗号学的ハッシュ関数
- 辞書攻撃を防ぐ方法の1つは、暗号化前のパスワードへの「ソルト」の付加である。

### SQLからパスワードを隠す
- APサーバーからDBサーバーにパスワードを含むSQLを送る時
  - SQL文の中に平文のパスワードが含まれると、パケットが傍受された場合などにパスワードを読み取られる。
  - アプリケーションコードでハッシュを計算し、SQLクエリではハッシュのみを用いるようにする。
- ユーザーのブラウザからwebサーバーにパスワードを送る時
  - セキュアHTTPを使用する方法がよく用いられる。

## パスワードをリカバリーするのではなく、リセットする
- アプリケーションが生成した一時パスワードを電子メールで送る方法
- リクエストをDBテーブルに記録し、一意のトークンを識別子として割り当てる方法
- 極めてセキュアなシステムを開発する必要がある場合は、以下の採用を検討する
  - PBKDF2
  - Bcrypt

# 20章 SQLインジェクション
## 目的：動的SQLを記述する

## アンチパターン：未検証の入力をコードとして実行する
- SQLインジェクションは、SQLステートメントが解析される前に構文を改変する

### 対処法
- 状況に応じて適切な技法を使い分ける必要がある。
- 値のエスケープ
- プリペアドステートメント　最も強力な防御手段
- ストアドプロシージャ
- データアクセスフレームワーク

## 解決策：誰も信用してはならない
- 以下の技法を状況に応じて適切に使い分ける。
- 入力のフィルタリング
- 動的値のパラメータ化
- 動的値を引用符で囲む　この際、成熟した、よくテストされた関数を使うこと
- ユーザーの入力をコードから隔離する
- 他の開発者にコードをレビューしてもらう　SQLインジェクション対策のコードレビューのガイドライン

# 21章 シュードキー・ニートフリーク（疑似キー潔癖症）
## 目的：欠番を詰める

## アンチパターン：隙間を埋める
- 削除した疑似キーを再割り当てしてはならない。

## 解決策：疑似キーの欠番は埋めない
- 主キーは連続している必要はない
- 疑似キーと行番号は異なる。行番号を使用する場合は、ウィンドウ関数（ROW _NUMBER関数など）を使うなどする。
- ランダムな疑似キー値を生成する方法もある　グローバル一意識別子（GUID）
- 最も重要な問題は上司からの欠番を埋めろという要求をどう回避するか
  - 技術について説明する
  - コストの見積もりを提示する
  - 自然キー（ナチュラルキー）を使用する

# 22章 シー・ノー・エビル（臭いものに蓋）
- コードを簡潔に保つために、エラー処理を疎かにするとデバッグが大変になるという話

## 目的：簡潔なコードを書く

## アンチパターン：肝心な部分を見逃す

## 解決策：エラーから優雅に回復する
- データベースAPI呼び出しの戻り値と例外のチェックは、ステップにミスがないことを保証するための最善策
- デバッグには、SQLクエリを構築するコードではなく、実際に構築されたSQLクエリを使用することも重要

# 23章 ディプロマティック・イミュニティ（外交特権）
## 目的：ベストプラクティスを採用する

## アンチパターン：SQLを特別扱いする（DBを特別扱いし、DBコードでベストプラクティスを適用しようとしない）

## アンチパターンを用いてもよい場合
- その場限りのコードを書く場合

## 解決策：包括的に品質問題に取り組む
- 品質保証は3つの部分からなる。
  1. プロジェクト要件の明確な定義・文書化
  2. 要件に対する解決策の設計・構築
  3. 解決策が要件を満たしていることの確認・テスト
- DB開発における品質保証は、文書化、バージョン管理、テスティングのベストプラクティスに従うことで達成できる。

### 文書化
- 以下のチェックリストを使ってDBを文書化する。
  - ER図
  - テーブル、列、ビュー　テーブルが表現しているエンティティの分類についての説明など
  - 関連（リレーションシップ）
  - トリガー
  - ストアドプロシージャ
  - SQLセキュリティ
  - データベースインフラストラクチャ
  - オブジェクトリレーショナルマッピング（ORM）
- アプリケーションコードの文書化の価値は低いが、DBの文書化には価値がある

### バージョン管理
- 以下をバージョン管理システムの管理下に入れる
  - データ定義スクリプト
  - トリガーとプロシージャ
  - ブートストラップデータ（シードデータ）
  - ER図とドキュメント
  - データベース管理スクリプト
- アプリケーションコードとデータベースコードは、同じバージョン管理リポジトリを用いるようにする

### テスティング
- 品質管理
- テスティングの重要な原則の1つは、独立（isolation）
- テストのためのチェックリスト
  - テーブル、列、ビュー
  - 制約
  - トリガー
  - ストアドプロシージャ
  - ブートストラップデータ
  - クエリ
  - オブジェクトリレーショナルマッピング（ORM）を使用したクラス

# 24章 マジックビーンズ（魔法の豆）
## 目的：MVCのM(モデル)を単純化する

## アンチパターン：モデルがアクティブレコードそのもの
-　アクティブレコード自体に問題があるのではなく、アンチパターンになるのは、MVCアプリケーションのすべてのモデルクラスがアクティブレコードの基底クラスを継承するという規約である

## 解決策：モデルがアクティブレコードを「持つ」ようにする
### モデルを理解する
- 情報エキスパート
  - アクティブレコードのようなDAOとモデルとの間の関係は、is-a（継承）ではなくhas-a（集約）であるべき。
- 生成者
- 疎結合性
- 高凝集性

### ドメインモデルの使用
- DBの構造ではなく、アプリケーションの概念に基づいてモデルを設計すると、データベースの操作をモデルクラスに完全に隠蔽して実装できるようになる。

### プレーンなオブジェクトのテスト
- モデルからDAOを分離させると、DAOのスタブやモックを作成できるようになり、モデルのユニットテストをデータベースから独立して行うことができる。

## 25章 砂の城
## 目的：サービスの安定稼働

## アンチパターン：想定不足

## 解決策
- どのようなトラブルが起こりうるかということを可能な限り想定しておく
- 代表的な対策
  - ベンチマーク　どの程度のトラフィックやデータ量まで耐えられるかベンチマークをとっておく
  - テスト環境の構築
  - 例外処理
  - バックアップ
  - 高可用性
    - 一般的な高可用性構成は、クラスタリングソフトウェアを用い、マシンがクラッシュした際にフェイルオーバーさせるものを指す。
  - ディザスタリカバリ
  - 運用ポリシーの策定

# Ⅴ部 付録

# 付録A 正規化のルール
## リレーショナルとは何か
- 関係（リレーション）という用語は、テーブル間の関連（リレーションシップ）を指すものではない。
- リレーションとはテーブルそれ自体のことを意味するか、もしくは同じテーブル内の列間の関係性を意味する。

## 正規化は常識的なもの

SQLアンチパターン

# 2章 ナイーブツリー（素朴な木）
## 目的
- 階層構造を格納し、クエリを発行する

## アンチパターン
- 隣接リスト　parent_idを持たせて親子関係を表す方法
  - DBで本来シンプルかつ効率的に行えるべきことでも、多くのコードが必要になってしまう。

## 解決策
- 隣接リストモデルの代替となるものには、経路列挙モデル、入子集合モデル、閉包テーブルモデルなどがある。

# 3章 IDリクワイアド（とりあえずID）
## 目的：主キーの規約を確立する
- 意味を持たない人工的な値を主キーにする場合（例：id列）、このタイプの主キー列を疑似キーや代理キーと呼ぶ場合がある。

## アンチパターン：すべてのテーブルに「id」列を用いる

## アンチパターンを用いても良い場合
- 「設定より規約」を原則としたORMフレームワークを使い、その規約で列名id・データ型整数の疑似キーを採用している場合

## 解決策：状況に応じて適切に調整する
- わかりやすい列名にしよう
  - メタデータの命名規則について、Joe Celko 「SQL Programming Style」でSQLに焦点を当てた解説が読める。
- 規約に縛られない
- 自然キー（自然に主キーに使えそうな列）と復号キーの活用

# 4章 キーレスエントリ（外部キー嫌い）
## 目的：データベースのアーキテクチャを単純化する
- 参照整合性は極めて重要。
- 外部キー制約

## アンチパターン：外部キー制約を使用しない
- 外部キー制約が邪魔になると考える開発者もいるが、外部キーを用いてシンプルかつ効率的に複数テーブルの更新と削除を行う方法はある。（後述）

## 解決策：外部キー制約を宣言する
- DBへの登録時点でデータ不整合のミスを防止できる。
- 外部キーには、カスケード更新という機能がある
  - これを使うと、親の行の更新や削除が可能になり、さらにその行を参照しているあらゆる子の行もDBが適切に処理してくれる。

# 5章 EAV(エンティティ・アトリビュート・バリュー)
## 目的：可変属性をサポートする

## アンチパターン：汎用的な属性テーブルを使用する
- EAVは、属性をattr_name, attr_valueのような形式で行ごとに格納する方法
- この方法はメリットが期待されるように見えるが、従来型のDB設計で得られるいくつもの利点を失ってしまう。

## 解決策：サブタイプのモデリングを行う
- 解決策がうまく機能するのは、サブタイプの数が限られ、開発者が各サブタイプの属性をよく知っているとき

### シングルテーブル継承
- 関連するすべてのサブタイプを1つのテーブルに格納
- この採用が適切なのは、サブタイプの数とサブタイプ固有の属性の数が少なく、アクティブレコードのような単一のテーブルに対するデータベースアクセスパターンを使う必要がある場合

### 具象テーブル継承
- サブタイプごとにテーブルを作成
- すべてのサブタイプをまたいだ検索を実行する頻度が低い場合に適切

### クラステーブル継承
- テーブルをオブジェクト指向のクラスであるかのようにみなして、継承を模倣するという方法
- すべてのサブタイプに共通する列を参照するクエリが頻繁に実行されるときに適している

### 半構造化データ
- LOB（Large Object）列にJSONなどの形式で属性名と値をともに格納する
- この設計の長所は、拡張性が極めて高いこと。短所は、SQLが特定の属性にアクセスする手段をほとんど持たないこと。
- サブタイプの数を制限できない場合や、新しい属性を随時定義するための高い柔軟性が必要な場合に適している。

# 6章 ポリモーフィック関連
## 目的：複数の親テーブルを参照する

## アンチパターン：二重目的の外部キーを使用する
- ポリモーフィック関連
- 外部キー制約を使えないので、参照整合性が保証されない
- 色々と注意点が出てくる

## アンチパターンを用いても良い場合
- 成熟した実績あるフレームワークを選べば、ポリモーフィック関連がきちんと実装されていることが期待できる場合もある。

## 解決策：関連（リレーションシップ）を単純化する
- ポリモーフィック関連では、「本来あるべき関連が、逆さまになっている」
- 交差テーブルを作成する方法
- 共通の親テーブルを作成する方法

# 7章 マルチカラムアトリビュート（複数列属性）
## 目的：複数の値を持つ属性を格納する

## アンチパターン：複数の列を定義する

## アンチパターンを用いてもよい場合
- 属性値の選択肢の順番が重大な意味を持つ場合

## 解決策：従属テーブルを作成する
- 最善の解決策は、属性を格納する列を1つ持つ従属テーブルを作壊死し、属性を格納すること。属性値を複数の列ではなく、複数の行に格納する。

# 8章 メタデータトリブル（メタデータ大増殖）
## 目的：スケーラビリティを高める
- この章の目的は、クエリの実行速度を劣化させずに、データが増加し続けるテーブルに対応できるよう、データベースの構造を設計すること。

## アンチパターン：テーブルや列をコピーする
- 「すべてのテーブルの行は少ない方がいい」という誤った考えのもと、以下のアンチパターンに陥る。
  - 行数の多いテーブルを、複数のテーブルに分割する
  - 列を複数列に分割する

## 解決策：パーティショニングと正規化を行う
- テーブルサイズが巨大化した場合に、パフォーマンスを改善するよい方法は下記
  - 水平パーティショニング、垂直パーティショニング、従属テーブルの導入
- 水平パーティショニング（シャーディング）の使用：　テーブルを行で分割
- 垂直パーティショニングの使用：　テーブルを列で分割する。列の一部のサイズが大きい場合や、めったに使用されない場合にメリットがある。

# II部 データベース物理設計のアンチパターン

# 9章 ラウンディングエラー（丸め誤差)
## 目的：整数の代わりに小数値を使用する

## アンチパターン：FLOATデータ型を使用する
- 丸めが避けられない。10進数で有限精度で表せる値でも、2進数形式では無限精度が必要になり、丸められることがある。
- 実質上、FLOAT、REAL、DOUBLE PRECISIONなどのデータ型を用いると、完全に正確な値は期待できないと考えるべき。

## 解決策：NUMERICデータ型を使用する
- NUMERICまたはDECIMALを用いて、固定精度の小数点数を表すようにする。
- 精度（使用可能な10進数の桁数の総数）、スケール（小数点以下に格納できる桁数）を指定する。
- NUMERICおよびDECIMAL型の長所は、有理数を丸めることなく格納できる点

# 10章 サーティワンのフレーバー（３１のフレーバー）
## 目的：列を特定の値に限定する

## アンチパターン：限定する値を（テーブルの）列定義で指定する
- 許可されている列挙値を取得するのが厄介
- 列を再定義する場合も厄介な作業となる

## アンチパターンを用いてもよい場合
- 有効値の変更が不要だと断言できる場合（例：相互排他的な2つの値（左/右など）を指定する場合など）

## 解決策：限定する値をデータで指定する
- 参照テーブルを作成し、許可する値を1行に1つずつ格納する。

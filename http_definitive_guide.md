HTTP: The Definitive Guide

# Part I: HTTP: The Web's Foundation
- Ch1 ~ Ch4

# Ch1. Overview of HTTP
## 1.1 

## 1.2 Web Clients and Servers
- HTTPサーバーはインターネットのデータを保持し、HTTPクライアントからリクエストされたらそれを渡す。
- 最も一般的なクライアントはWebブラウザ。

## 1.3 Resources
- webサーバーはwebリソースをホストする。webリソースは、webコンテンツの元となるもの。
- 最も単純なwebリソースは、HTMLなどの静的ファイルであるが、静的ファイルでなくても良い。リソースは要求に応じたコンテンツを生成するプログラムでも良い。
- 要約すると、リソースとはあらゆる種類のコンテンツソースのこと。

### 1.3.1 Media Types
- HTTPは、MIMEというデータフォーマットラベルを各オブジェクトに付与して転送する。
- Webサーバは、すべてのHTTPオブジェクトデータにMIMEタイプを付加する。
  - ヘッダー Content-type: image/jpeg のimage/jpegがMIME typeにあたる。
- MIMEタイプは、主なオブジェクトタイプと特定のサブタイプをスラッシュで区切って表現したテキストラベルである。
  - HTMLからなるテキストドキュメントは、text/html となる。

### 1.3.2 URIs
- クライアントは、自分が興味のあるリソースを指摘することができる。サーバーリソース名をURIと呼ぶ。
- URIはインターネットの郵便番号のようなもので、世界中の情報資源を一意に識別し、位置を特定する。
- URIはURLとURNからなる。

### 1.3.3 URLs
- URLは、特定のサーバー上のリソースの特定の場所を示す。
- スキーマ、アドレス、リソースの３箇所に主に分かれる。

### 1.3.4 URNs
- URNは、 リソースが現在どこにあるかに関係なく、特定のコンテンツのユニークな名前を提供する。
- まだ広く採用されていない。対応するインフラが必要なため。

## 1.4 Transactions

### 1.4.1 Methods

### 1.4.2 Status Codes

### 1.4.3 Web pages can consist of multiple objects
- アプリケーションは、タスクを達成するために複数のHTTPトランザクションを発行することがよくある。
- 埋め込まれたリソースは、異なるサーバーに存在することもある。

## 1.5 Messages
- HTTPメッセージはStart line、Header fields、Body からなる。
- ボディには任意のバイナリデータを格納可能

## 1.6 Connection
- TCP
  - エラーのないデータ転送
  - in-order delivery（データは常に送信された順に届く）
  - セグメント化されていないデータストリーム（任意のサイズのデータをいつでも垂れ流すことができる）
- TCP/IPは個々のネットワークやハードウェアの特殊性・欠点を隠す。

## 1.7 Protocol Versions

## 1.8 Architectural components of the web
### 1.8.1 Proxies
- HTTPプロキシサーバーは、Webセキュリティ、アプリケーション統合、パフォーマンス最適化のための重要な構成要素。
- ユーザーの代理として、ユーザーに代わってサーバーにアクセスするアプリケーション。
- プロキシはセキュリティのために使用されることが多く、すべてのウェブトラフィックが流れる信頼できる仲介者として機能する。

### 1.8.2 Caches
- webキャッシュやキャッシングプロキシは、プロキシを通過する主要なドキュメントのコピーを保持する特殊なHTTPプロキシサーバーである。
- クライアントは、離れたwebサーバーからよりも近くのキャッシュを利用することで、はるかに早くドキュメントを取得できる。HTTPは、キャッシュをより効果的にし、キャッシュされたコンテンツの鮮度やプライバシーを管理するための多くの機能を定義している。

### 1.8.3 Gateways
- ゲートウェイとは、他のサーバーを仲介する特別なサーバー。一般にHTTPトラフィックを別のプロトコルに変換する。ゲートウェイはオリジンサーバーのように振る舞うので、クライアントはゲートウェイと通信していると気づかない。

### 1.8.4 Tunnels
- トンネルは、セットアップ後、2つの接続間で生データを盲目的に中継するHTTPアプリケーション。HTTPトンネルは、HTTP以外のデータを1つまたは複数のHTTP接続を介して、データを見ることなく転送するためによく使用される。
- HTTPトンネルは、暗号化されたセキュア・ソケット・レイヤー（SSL）トラフィックをHTTP接続で伝送することで、Webトラフィックのみを許可する企業のファイアウォールを介してSSLトラフィックを許可するという使い方が一般的である。

### 1.8.5 Agents
- ユーザーエージェント（または単にエージェント）は、ユーザーに代わってHTTPリクエストを行うクライアントプログラムである。ブラウザ以外のユーザーエージェントが多くある。
- 例えば、人間が監視することなく、自律的にウェブを歩き回り、HTTPトランザクションを発行したり、コンテンツを取得したりする機械によって自動化されたユーザーエージェントがある。これらの自動化されたエージェントには、「スパイダー」や「ウェブロボット」などのカラフルな名前がついていることが多い。スパイダーは、検索エンジンのデータベースや比較ショッピングロボットの製品カタログなど、ウェブコンテンツの有用なアーカイブを構築するためにウェブを徘徊する。

# Ch2. URLs and Resources
- URLはインターネットリソースの標準的な名前である。

## 2.1 Navigating the Internet's Resources
- URLは、ブラウザが情報を検索する際に必要となるリソースの位置情報です。インターネット上の何十億ものデータリソースを人々やアプリケーションが見つけ、利用し、共有するためのものです。URLは、HTTPやその他のプロトコルに対する人間の通常のアクセスポイントです。人間がブラウザでURLを指定すると、裏ではブラウザが適切なプロトコルメッセージを送信し、人間が求めるリソースを取得します。
- URLの最初の部分はURLスキーマ。webクライアントに「どうやって」リソースにアクセスするかを伝える。
- URLの第二の部分はサーバーの場所。webクライアントに、リソースが「どこに」ホストされているかを伝える。
- URLの第三の部分は、リソースパス。これはサーバー上の「何の」ローカルリソースがリクエストされているかを伝える。
- 世の中にあるすべてのリソースと、そのリソースを得るためのすべての方法に対して、それぞれのリソースに単一の名前を付けることで、誰もがその名前を使ってリソースを見つけることができるようになっているのです。しかし、これは必ずしもそうではありませんでした。

### 2.1.1 The dark days before URLs

## 2.2 URL Syntax
- ほとんどのURLは一般的なURL構文に準拠しており、異なるURLスキームの間でスタイルや構文が大きく重複しています。
- ほとんどのURLは9つのパートに分かれる。

```
<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<qu
ery>#<frag>
```
- これらの構成要素をすべて含むURLはほとんどありません。最も重要な要素はscheme, host, pathです。

### 2.2.1 Schemes: What Protocol to Use
- schemeは与えられたリソースにアクセスする方法についての主要なIDである。schemeはURLを解釈するアプリケーションに、どのプロトコルを使う必要があるかを伝える。

### 2.2.2 hosts and ports
- インターネット上のリソースを見つけるために、アプリケーションはリソースをホストしているマシンを知り、そのマシンのどこに目的のリソースにアクセスできるサーバーがあるのかを知る必要があります。
- hostコンポーネントは、リソースにアクセスできるインターネット上のホストマシンを特定します。名前は、上記のようにホスト名（「www.joes-hardware.com」）として提供することも、IPアドレスとして提供することもできます。
- portコンポーネントは、サーバーがリッスンしているネットワークポートを特定します。基本的にTCPプロトコルを使用するHTTPの場合、デフォルトのポートは80です。

### 2.2.3 usernames and passwords

### 2.2.4 Paths
- URLのpathコンポーネントは、サーバーマシン上のどこにリソースがあるかを指定します。

### 2.2.5 parameters
- アプリケーションがサーバーと正しく対話するために必要な入力パラメータを与えるために、URLにはparamsコンポーネントがあります。このコンポーネントは、URL内の名前と値のペアのリストで、URLの他の部分と（そしてお互いに）「;」文字で区切られています。このコンポーネントは、アプリケーションがリソースにアクセスするために必要な追加情報を提供します。

### 2.2.6 query strings
- データベースサービスなどの一部のリソースでは、要求されているリソースの種類を絞り込むために、質問や問い合わせをすることができます。
- URLのqueryコンポーネントはゲートウェイ・リソースに渡され、URLのpathコンポーネントはゲートウェイ・リソースを特定します。基本的に、ゲートウェイは他のアプリケーションへのアクセスポイントと考えることができます。

### 2.2.7 fragments
- リソースの一部や断片を参照できるように、URLはリソース内の断片を識別するfragコンポーネントをサポートしています。例えば、URLは、HTMLドキュメント内の特定の画像やセクションを指し示すことができます。
- フラグメントは、URLの右端に#文字を付けてぶら下げます。
- クライアントはリソース全体を取得した後、fragmentで指定するリソースの部分を表示する。（ブラウザの場合、そこまでスクロールする。）

## 2.3 URL Shortcuts
- Web クライアントは、いくつかの URL ショートカットを理解して使用しています。相対URLは、リソースの中にリソースを指定する便利な略語です。また、多くのブラウザはURLの「自動展開」をサポートしています。ユーザーがURLの重要な（記憶に残る）部分を入力すると、ブラウザが残りの部分を埋めてくれます。

### 2.3.1 Relative URLs - 相対URL
- URLには、絶対URLと相対URLの2種類があります。
- ここまでは、絶対URLについてのみ説明してきました。絶対URLには、リソースにアクセスするために必要な情報がすべて含まれています。一方、相対URLは不完全なものです。相対URLからリソースへのアクセスに必要なすべての情報を得るためには、ベースと呼ばれる別のURLから相対的に解釈しなければなりません。相対URLは、URLの便利な略記法です。
- 省略可能な相対URL構文により、HTML作成者はURLからスキームやホストなどの構成要素を省略することができます。これらの要素は、それらが含まれるリソースのベースURLから推測できます。他のリソースのURLもこの短縮形で指定することができます。
- また、相対URLは、一連のリソース（HTMLページなど）をポータブルに保つための便利な方法です。相対URLを使用すると、一連のドキュメントを移動しても、新しいベースに対して相対的に解釈されるため、リンクが機能します。これにより、他のサーバにコンテンツをミラーリングすることなどが可能になります。

#### 2.3.1.1 Base URLs
- 変換プロセスの最初のステップは、ベースURLを見つけることです。ベースURLは、相対URLを参照するためのポイントとなります。ベースURLはいくつかの場所から得られます。
  - リソースで明示されている
  - カプセル化されたリソースのベースURL　（HTMLなど）相対URLが埋め込まれているリソースのURLをベースにすることができる。
  - ベースとなるURLがない

#### 2.3.1.2 Resolving relative references
- 相対URLを絶対URLに変換するアルゴリズムがある。もともとRFC1808で規定され、その後RFC2396に組み込まれた。

### 2.3.2 Expandomatic URLs - URLの拡大
- 一部のブラウザでは、URLを送信した後や入力中に、自動的にURLを展開しようとするものがあります。これにより、ユーザーは完全なURLを入力する必要がなく、自動的に展開されるため、ショートカットを得ることができます。
- これらの「expandomatic」機能には、2つの種類があります。
  - ホスト名展開
    - ブラウザは簡単なヒューリスティクスを利用して、ユーザーの助けを借りずに、入力したホスト名を完全なホスト名に展開することができます。
  - 履歴の展開
    - URLを入力する手間を省くためにブラウザが採用しているもうひとつのテクニックが、過去にアクセスしたURLの履歴を保存することです。URLを入力する際に、入力した内容と履歴に残っているURLの接頭辞を照合することで、完成度の高い選択肢を提供することができます。

## 2.4 Shady Characters
- URLには、比較的小さく、普遍的に安全なアルファベットの文字のみを含めることが許可されている。
- URLは完全でなければなりません。URL の設計者は、URL にバイナリデータや、普遍的に安全なアルファベット以外の文字を含めたいと思う場合があることに気付きました。そこで、安全でない文字を安全な文字にエンコードして転送できるように、エスケープメカニズムを追加しました。

### 2.4.1 The URL Character Set
- URL設計者は、完全性の必要性を認識して、エスケープシーケンスを取り入れました。エスケープシーケンスは、任意の文字値やデータをUS-ASCII文字セットの限定されたサブセットを使ってエンコードすることで、移植性と完全性を実現します。

### 2.4.2 Encoding Mechanisms
- 安全な文字セットの表現の限界を回避するために、安全ではないURLの文字を表現するエンコード方式が考案されました。このエンコーディングでは、安全でない文字を、パーセント記号（%）と、その文字のASCIIコードを表す2つの16進数からなる「エスケープ」表記で単純に表します。

### 2.4.3 Character Restrictions - 文字の制限
- いくつかの文字は、URLの中で特別な意味を持つように予約されています。

### 2.4.4 A Bit More

## 2.5 A sea of schemes
- httpスキーマは、usernameとpasswordがないこと以外は一般的なURLフォーマットと同じ。デフォルトポートは80。
- https
- mailto

## 2.6 the future
- URN
- PURL

# Ch3 HTTP Messages
- HTTP がインターネットの運び屋であるとすれば、HTTP メッセージは物を移動するためのパッケージです。この章では以下を学びます。
  - メッセージの流れ
  - HTTP メッセージの 3 つの部分 (開始行、ヘッダー、エンティティボディ)
  - リクエストメッセージとレスポンスメッセージの違い
  - リクエストメッセージがサポートするさまざまな機能（メソッド）について
  - レスポンスメッセージで返されるさまざまなステータスコード
  - 各種 HTTP ヘッダーの役割 

## 3.1 The Flow of Messages
- HTTPメッセージは、HTTPアプリケーション間で送信されるデータのブロックです。これらのデータブロックは、メッセージの内容や意味を説明するテキストのメタ情報で始まり、その後にオプションのデータが続きます。これらのメッセージは、クライアント、サーバー、およびプロキシの間を流れます。メッセージの方向性を示す用語として、「インバウンド」、「アウトバウンド」、「アップストリーム」、「ダウンストリーム」があります。

### 3.1.1 Messages Commute Inbound to the Origin Server
- HTTPでは、トランザクションの方向性を表すために、インバウンドとアウトバウンドという用語を使用しています。メッセージはオリジンサーバーに向かってインバウンドで送信され、その作業が終わるとユーザーエージェントに向かってアウトバウンドで送信されます（図3-1参照）。

### 3.1.2 Messages Flow Downstream
- HTTP メッセージは川のように流れます。すべてのメッセージは、リクエスト・メッセージかレスポンス・メッセージかにかかわらず、下流に向かって流れます（図3-2参照）。メッセージの送信者は受信者の上流に位置します。

## 3.2 The Parts of a Message
- HTTPメッセージは、フォーマットされたシンプルなデータの塊です。図3-3にその例を示していますのでご覧ください。各メッセージには、クライアントからのリクエストまたはサーバからのレスポンスが含まれています。メッセージは3つの部分から構成されています。メッセージを説明するスタートライン、属性を含むヘッダーのブロック、そしてデータを含むオプションのボディです。
- 開始行とヘッダーは単なるASCIIテキストで、行ごとに区切られています。各行の終わりには、キャリッジリターン（ASCII 13）とラインフィード（ASCII 10）の2文字の行末シーケンスがあります。
- この行末記号は "CRLF "と表記されます。HTTPの行末仕様はCRLFですが、堅牢なアプリケーションでは、ラインフィード文字だけを受け入れるべきであることを指摘しておきます。古いHTTPアプリケーションや壊れたHTTPアプリケーションの中には、キャリッジリターンとラインフィードの両方を送るとは限らないものもあります。
- エンティティボディまたはメッセージボディ（または単に「ボディ」）は、単なるオプションのデータチャンクです。開始行やヘッダーとは異なり、ボディにはテキストやバイナリデータを含めることができ、また空にすることもできます。

### 3.2.1 Message Syntax
- すべてのHTTPメッセージは、「リクエストメッセージ」と「レスポンスメッセージ」の2種類に分類されます。リクエストメッセージはウェブサーバに動作を要求し，レスポンスメッセージはリクエストの結果をクライアントに返します。
```
// リクエストメッセージのフォーマット
<method> <request-URL> <version>
<headers>

<entity-body> 

// レスポンスメッセージのフォーマット
<version> <status> <reason-phrase>
<headers>

<entity-body>
```
- method
  - クライアントがサーバーにリソースに対して実行してほしいアクション。GET"、"HEAD"、"POST "などの単一の単語で構成されます。この章の後半では、メソッドについて詳しく説明します。
- request-URL
  - 要求されたリソースを指定する完全なURL、またはURLのパスコンポーネントです。サーバーと直接やりとりする場合は、リソースへの絶対パスであれば、通常、URLのパスコンポーネントは問題ありません（サーバーは自分自身をURLのホスト／ポートとみなすことができます）。
- version
- status-code
- reason-phrase
  - ステータスコードの数値を人間が読めるようにしたもので、行末までのすべてのテキストで構成される。理由のフレーズは、人間が消費するためだけのものです。
- headers
  - 0個以上のヘッダは、名前の後にコロン(:)、任意のホワイトスペース、値、CRLFが続きます。ヘッダーは空行 (CRLF) で終了し、ヘッダーのリストの終わりと、エンティティボディの始まりを示します。HTTP/1.1 などの一部のバージョンの HTTP では、リクエストやレスポンスのメッセージが有効であるために、特定のヘッダが存在することが要求されます。様々な HTTP ヘッダーについては、この章の後半で説明します。
- entity-body
  - エンティティボディは、任意のデータブロックを含みます。すべてのメッセージにエンティティ・ボディが含まれているわけではないので、メッセージが CRLF で終了することもあります。エンティティについては第 15 章で詳しく説明します。
- HTTP ヘッダは、ヘッダがなくても、エンティティボディがなくても、常に空行(CRLF)で終わるべきであることに注意してください。しかし、これまで多くのクライアントやサーバーは、エンティティボディがない場合、最後のCRLFを（誤って）省略していました。

### 3.2.2 Start Lines

#### 3.2.2.1 リクエスト・ライン
- リクエスト・メッセージは、リソースに対して何かをするようサーバに要求します。リクエスト・メッセージのスタート・ライン（リクエスト・ライン）には、サーバが実行すべき操作を記述したメソッドと、そのメソッドを実行するリソースを記述したリクエストURLが含まれます。また、リクエストラインには、クライアントが使用しているHTTPの方言をサーバーに伝えるHTTPバージョンも含まれています。
- これらのフィールドはすべてホワイトスペースで区切られています。

#### 3.2.2.2 レスポンスライン
- レスポンス・メッセージは、操作によって得られたステータス情報や結果のデータをクライアントに返します。レスポンスメッセージの開始行（レスポンスライン）には、レスポンスメッセージが使用しているHTTPバージョン、数値化されたステータスコード、操作のステータスを説明するテキストの理由フレーズが含まれます。これらのフィールドはすべて、ホワイトスペースで区切られています。

#### 3.2.2.2 メソッド
- メソッドは、リクエストの開始行を開始し、サーバーに何をすべきかを伝えます。たとえば、「GET /specials/saw-blade.gif HTTP/1.0」という行では、メソッドはGETです。
- HTTPの仕様では、一般的なリクエストメソッドのセットが定義されています。例えば、GETメソッドはサーバーからドキュメントを取得し、POSTメソッドはサーバーにデータを送信して処理を行い、OPTIONSメソッドはWebサーバーの一般的な機能や特定のリソースに対するWebサーバーの機能を決定します。
- 表3-1では、これらのうち7つのメソッドについて説明しています。なお、リクエストメッセージにボディがあるメソッドと、ボディのないリクエストがあるメソッドがあります。
- すべてのサーバーが表3-1の7つのメソッドをすべて実装しているわけではありません。また、HTTPは拡張性を重視して設計されているため、他のサーバーがこれらに加えて独自のリクエストメソッドを実装している場合もあります。これらの追加メソッドは、HTTPの仕様を拡張するものであるため、拡張メソッドと呼ばれます。

#### 3.2.2.4 ステータスコード
- ステータスコードは、各応答メッセージの開始行に返されます。ステータスには、数字と人間が読める文字の両方が含まれます。数字はプログラムのエラー処理を容易にし、理由は人間が理解しやすいようになっています。
- それぞれのステータスコードは、3桁の数値コードによってクラス分けされています。200から299までのステータスコードは成功を表す。300から399までのコードは、リソースが移動されたことを示す。400から499までのコードは、クライアントがリクエストで何か間違ったことをしたことを意味します。500から599までのコードは、サーバー上で何か問題が発生したことを意味します。
- 現在のバージョンのHTTPでは、各ステータスカテゴリにいくつかのコードしか定義されていません。プロトコルの進化に伴い、より多くのステータスコードがHTTP仕様で公式に定義される予定です。見覚えのないステータスコードを受け取った場合は、誰かが現在のプロトコルの拡張として定義した可能性があります。そのコードは、そのコードが含まれるクラスの一般的なメンバーとして扱われるべきです。

#### 3.2.2.5 reason phrases
- HTTPの仕様では、理由を示す語句がどのようなものであるべきか、明確なルールは定められていません。

#### 3.2.2.6 Version numbers
- バージョン番号は、HTTP アプリケーションが相互にどのバージョンのプロトコルに準拠しているかを伝える手段となります。バージョン番号は、HTTP を使用するアプリケーションに、互いの能力やメッセージの形式についての手がかりを提供することを目的としています。HTTP バージョン 1.1 のアプリケーションと通信する HTTP バージョン 1.2 のアプリケーションは、1.2 の新機能を使用すべきではないことを知るべきです。なぜなら、それらの機能は、古いバージョンのプロトコルを使用するアプリケーションによって実装されていない可能性が高いからです。

### 3.2.3 Headers
- HTTP ヘッダーフィールドは、リクエストとレスポンスのメッセージに追加の情報を与えます。これらは基本的に、名前と値のペアのリストです。

#### 3.2.3.1 Header classifications
- 各HTTPヘッダーは、名前の後にコロン（：）、任意のホワイトスペース、フィールド値、CRLFというシンプルな構文になっています。

### 3.2.4 Entity Bodies
- HTTPメッセージの第3の部分は、オプションのエンティティボディです。エンティティボディは、HTTPメッセージのペイロードです。エンティティボディは、HTTPメッセージのペイロードであり、HTTPが輸送するために設計されたものです。
- HTTPメッセージは、画像、ビデオ、HTML文書、ソフトウェアアプリケーション、クレジットカード、電子メールなど、さまざまな種類のデジタルデータを伝送することができます。

### 3.2.5 Version 0.9 Messages

## 3.3 Methods
- ここでは、表3-1に示した基本的なHTTPメソッドのいくつかについて詳しく説明します。ただし、すべてのサーバがすべてのメソッドを実装しているわけではありません。HTTP バージョン 1.1 に準拠するためには、サーバーはそのリソースに対して GET と HEAD メソッドのみを実装する必要があります。
- サーバーがこれらのメソッドをすべて実装していたとしても、そのメソッドはほとんどの場合、用途が制限されています。例えば、DELETEやPUT（後述）をサポートするサーバは、誰でもリソースを削除したり保存したりできることを望んでいません。このような制限は、一般的にはサーバーの設定で設定されるため、サイトやサーバーによって異なります。

### 3.3.1 Safe Methods
- HTTP では、安全なメソッドと呼ばれる一連のメソッドが定義されています。GET メソッドと HEAD メソッドは安全であると言われています。つまり、GET メソッドまたは HEAD メソッドを使用した HTTP リクエストの結果、何も起こらないことを意味します。何も起こらないというのは、HTTPリクエストの結果としてサーバー上で何も起こらないということです。
- 例えば、あなたがJoe's Hardwareでオンラインショッピングをしていて、「購入」ボタンをクリックしたとします。このボタンをクリックすると、クレジットカード情報を含むPOSTリクエスト(後述)が送信され、お客様に代わってサーバー上でアクションが実行されます。この場合のアクションとは、お客様のクレジットカードに購入代金が請求されることです。
- 安全なメソッドを使用しても、アクションが実行されないという保証はありません（実際には、ウェブ開発者次第ですが...）。安全なメソッドとは、何らかのアクションが実行される可能性のある安全でないメソッドが使用されている場合に、HTTPアプリケーションの開発者がユーザーに知らせるためのものです。Joe's Hardwareの例では、Webブラウザが警告メッセージを表示し、安全でないメソッドでリクエストを行っていること、その結果、サーバ上で何かが起こる可能性があることを知らせます（例：クレジットカードに課金される）。

### 3.3.2 GET
- GETは最も一般的なメソッドです。通常、サーバーにリソースの送信を依頼する際に使用されます。HTTP/1.1では、サーバーがこのメソッドを実装する必要があります。

### 3.3.3 HEAD
- ヘッダーだけを返すメソッド。下記用途で使う。
  - リソースを取得せずに、そのリソースについて調べる（例えば、タイプを決定する）。
  - レスポンスのステータスコードを見て、オブジェクトが存在するかどうかを確認する。
  - ヘッダを見て、リソースが変更されたかどうかを確認する。

- サーバの開発者は、返されるヘッダが、GETリクエストが返すヘッダと同じであることを確認する必要があります。HTTP/1.1 に準拠するためには、HEAD メソッドも必要です。

### 3.3.4 PUT
- PUTメソッドは、GETがサーバーからドキュメントを読み取るのとは逆に、サーバーにドキュメントを書き込むものである。パブリッシングシステムの中には、PUTを使ってWebページを作成し、Webサーバーに直接インストールできるものもある（図3-9参照）。
- PUTメソッドのセマンティクスは、サーバーがリクエストのボディを受け取り、それを使ってリクエストされたURLで名付けられた新しいドキュメントを作成するか、そのURLがすでに存在する場合は、ボディを使ってそれを置き換えるというものです。PUTはコンテンツの変更を可能にするため、多くのウェブサーバーではPUTを実行する前にパスワードによるログインを要求しています。パスワード認証については、第12章で詳しく説明しています。

### 3.3.5 POST
- OSTメソッドは、入力データをサーバーに送信するために設計されました *。 実際には、HTMLフォームをサポートするためによく使用されます。入力されたフォームからのデータは通常、サーバーに送信され、サーバーはそれを必要な場所（例えば、サーバー・ゲートウェイ・プログラムに送信し、それを処理します）に転送します。
- * POSTは、データをサーバーに送信するために使用されます。PUTは、サーバー上のリソース（ファイルなど）にデータを預けるために使用されます。

### 3.3.6 TRACE
- クライアントがリクエストを行う際、そのリクエストは、ファイアウォール、プロキシ、ゲートウェイ、その他のアプリケーションを経由しなければならない場合があります。これらのそれぞれが、オリジナルのHTTPリクエストを変更する機会を持っています。TRACEメソッドでは、クライアントは、リクエストが最終的にサーバに到達したときの様子を確認することができます。
- TRACEリクエストは、送信先のサーバで「ループバック」診断を開始します。最終目的地のサーバは、受け取ったバージンリクエストメッセージを本文に含んだTRACEレスポンスを返信します。クライアントは、元のメッセージが、HTTPアプリケーションのリクエスト／レスポンスチェーンに沿って、どのように、あるいはどのように変更されたかを確認することができます（図3-11参照）。
- TRACEメソッドは、主に診断のために使用されます。つまり、リクエストが意図したとおりにリクエスト／レスポンスチェーンを通過しているかどうかを検証します。また、プロキシや他のアプリケーションがリクエストに与える影響を確認するのにも適したツールです。TRACEは診断に適していますが、介在するアプリケーションが異なるタイプのリクエスト（異なるメソッド-GET、HEAD、POSTなど）を同じように扱うことを前提としているという欠点があります。多くの HTTP アプリケーションは、メソッドに応じて異なる処理を行います。一般的に、TRACEリクエストをどのように処理するかについては、介在するアプリケーションが判断します。
- TRACEリクエストでは、エンティティボディを送信することはできません。TRACEレスポンスのエンティティボディには、応答サーバが受け取ったリクエストがそのまま含まれています。

### 3.3.7 OPTIONS
- OPTIONSメソッドは、ウェブサーバがサポートしている様々な機能について、サーバに問い合わせるものです。一般的に、あるいは特定のリソースに対してどのようなメソッドをサポートしているかをサーバーに尋ねることができます。(サーバーによっては、特定の種類のオブジェクトに対してのみ特定の操作をサポートしている場合もあります)。
- これにより、クライアントアプリケーションは、様々なリソースに実際にアクセスすることなく、どのようにアクセスするのが最適かを判断することができます。

### 3.3.8 DELETE
- DELETEメソッドは、イメージ通り、リクエストURLで指定されたリソースの削除をサーバーに依頼するものです。しかし、クライアントアプリケーションは、その削除が実行されることを保証されていません。これは、HTTPの仕様では、サーバーがクライアントに断りなくリクエストを上書きすることができるためです。

### 3.3.9 Extension Methods
- HTTPは、新しい機能が旧来のソフトウェアの障害とならないように、フィールド拡張可能な設計となっています。
- 注意すべき点は、すべての拡張メソッドが正式な仕様で定義されているわけではないということです。拡張メソッドを定義しても、ほとんどの HTTP アプリケーションでは理解できない可能性があります。同様に、他のアプリケーションが使用している、理解できない拡張メソッドにHTTPアプリケーションが遭遇する可能性もあります。
- このような場合には、拡張メソッドに対して寛容であることが最善です。プロキシは、エンドツーエンドの動作を壊すことなく、未知のメソッドを持つメッセージを下流のサーバに中継することが可能であれば、それを試みるべきです。そうでない場合は、501 Not Implementedのステータスコードで応答すべきです。

## 3.4 Status Codes
- HTTPステータスコードは、前述の表3-2に示すように、大きく5つのクラスに分類されます。ここでは、5つのクラスごとにHTTPステータスコードをまとめています。

### 3.4.1 100-199: Informational Status Codes

### 3.4.2 200-299: Success Status Codes

### 3.4.3 300-399: Redirection Status Codes
- リダイレクションのステータスコードは、クライアントが興味を持っているリソー スのために別の場所を使用するように伝えるか、あるいはコンテンツの代わりに別の 応答を提供する。リソースが移動した場合には、リダイレクト・ステータス・コードとオプションのLocationヘッダを送信して、リソースが移動したことと、現在どこで見つけられるかをクライアントに伝えることができます（図3-14参照）。これにより、ブラウザは人間のユーザに迷惑をかけることなく、透過的に新しい場所に移動することができます。
- リダイレクトステータスコードの中には、アプリケーションのリソースのローカルコピーをオリジンサーバーで検証するために使用できるものがあります。例えば、HTTPアプリケーションは、リソースのローカルコピーがまだ最新であるかどうか、またはリソースがオリジンサーバーで変更されているかどうかを確認することができます。確認して変更がない旨のレスポンス（304 Not Modified）が返ってきたら、ローカルコピー（キャッシュなど）を表示する。
- 304
  - クライアントは、リクエストヘッダーを含めることで、リクエストを条件付きで行うことができます。条件付きヘッダの詳細については、第3章を参照してください。クライアントが、リソースが最近変更されていない場合のGETなど、条件付きのリクエストを行う場合、リソースが変更されていないことを示すためにこのコードが使用されます。

### 3.4.4 400-499: Client Error Status Codes

### 3.4.5 500-599: Server Error Status Codes

## 3.5 Headers
- ヘッダーとメソッドが連携して、クライアントとサーバーの動作を決定します。このセクションでは、標準的な HTTP ヘッダーと、HTTP/1.1 仕様 (RFC 2616) で明示的に定義されていないいくつかのヘッダーの目的について、簡単に説明します。付録Cでは、これらすべてのヘッダーの詳細をまとめています。
- ヘッダーには、メッセージの種類ごとに固有のものと、リクエストメッセージとレスポンスメッセージの両方に情報を提供する、より一般的な目的のものとがあります。ヘッダーには、大きく分けて5つのクラスがあります。
  - General headers
  - Request headers
  - Response headers
  - Entity headers
    - エンティティ・ヘッダとは、エンティティ・ボディを扱うヘッダのことです。例えば、エンティティヘッダは、エンティティボディ内のデータのタイプを伝えることができます。
  - Extension headers

### 3.5.1 General Headers

### 3.5.2 Request Headers

### 3.5.3 Response Headers

### 3.5.4 Entity Headers
- HTTP メッセージのペイロードを記述するヘッダは数多くあります。リクエストメッセージにもレスポンスメッセージにもエンティティが含まれるため、これらのヘッダはどちらのタイプのメッセージにも含まれます。エンティティヘッダーは、オブジェクトのタイプに関する情報から、リソース上で実行可能な有効なリクエストメソッドまで、エンティティとそのコンテンツに関する幅広い情報を提供します。一般的に、エンティティヘッダーは、メッセージの受信者に何を扱っているかを伝えます。表3-21は、エンティティ情報ヘッダーの一覧です。

#### 3.5.4.1 Content headers
- コンテンツヘッダーは、エンティティのコンテンツに関する特定の情報を提供し、そのタイプ、サイズ、その他処理に役立つ情報を明らかにします。例えば、Webブラウザは返されたコンテンツタイプを見て、オブジェクトをどのように表示するかを知ることができます。表3-22は、さまざまなコンテンツヘッダーの一覧です。

#### 3.5.4.2 Entity caching headers
- 一般的なキャッシュヘッダは、いつ、どのようにキャッシュするかを指示します。エンティティキャッシュヘッダは、キャッシュされるエンティティに関する情報を提供します。たとえば、リソースのキャッシュされたコピーがまだ有効であるかどうかを検証するために必要な情報や、キャッシュされたリソースがいつ無効になるかをよりよく見積もるためのヒントを提供します。
- 第7章では、HTTPリクエストとレスポンスのキャッシュについて詳しく説明します。これらのヘッダは、そこで再び目にすることになるでしょう。表3-23は、エンティティキャッシュヘッダーの一覧です。

# Ch4 Connection Management
- HTTP仕様では、HTTPメッセージについてはよく説明されていますが、HTTPメッセージが流れる際の重要な配管であるHTTPコネクションについてはあまり説明されていません。もしあなたがHTTPアプリケーションを書いているプログラマーならば、HTTPコネクションの裏と表、そしてその使い方を理解する必要があります。
- HTTP 接続の管理は、ちょっとしたブラックアートのようなもので、出版された文献からだけでなく、実験や見習いからも学ぶことができます。この章では、以下のことを学びます。
  - HTTPのTCPコネクションの使い方
  - TCP 接続の遅延、ボトルネック、詰まり
  - HTTP の最適化 (並列接続、キープアライブ接続、パイプライン接続など)
  - 接続を管理する上での注意点 

## 4.1 TCP Connections
- 世界中のHTTP通信は、世界中のコンピュータやネットワーク機器で使用されているパケットスイッチネットワークプロトコルであるTCP/IPを介して行われています。クライアントアプリケーションは、世界中のあらゆる場所で動作しているサーバーアプリケーションとのTCP/IP接続を開くことができます。いったん接続が確立されると、クライアントとサーバーのコンピュータ間で交換されたメッセージが失われたり、破損したり、順番が狂って受信されることはありません。

### 4.1.1 TCP Reliable Data Pipes
- HTTP接続の正体は、TCP接続と、その使い方に関するいくつかのルールに過ぎません。TCP接続は、インターネットの信頼できる接続です。データを正確かつ迅速に送信するためには、TCPの基本的な知識が必要です。
- TCP は HTTP に信頼性の高いビットパイプを提供します。TCPコネクションの片側に詰め込まれたバイトは、正しい順序で反対側に出てきます（図4-2参照）。

### 4.1.2 TCP Streams Are Segmented and Shipped by IP Packets - TCPストリームを分割してIPパケットで出荷する
- TCPは、IPパケット（またはIPデータグラム）と呼ばれる小さな塊でデータを送信します。このように、HTTP は「HTTP over TCP over IP」という「プロトコル・スタック」の最上位の層です（図 4-3a）。安全なバージョンであるHTTPSは、HTTPとTCPの間に暗号化層（TLSまたはSSLと呼ばれる）を挿入します（図4-3b）。
- HTTP は、メッセージを送信する際に、開いている TCP コネクションを介して、メッセージデータのコンテンツを順にストリームします。TCP は、データのストリームを受け取り、セグメントと呼ばれる塊に切り分け、IP パケットと呼ばれるエンベロープ内でセグメントをインターネット上に転送します (図 4-4 参照)。これらはすべてTCP/IPソフトウェアによって処理され、HTTPプログラマーには何も見えません。
各TCPセグメントは、IPパケットによって、あるIPアドレスから別のIPアドレスへと運ばれます。これらのIPパケットには、以下のものが含まれます。

  - IPパケットヘッダ（通常20バイト
  - TCPセグメントのヘッダ（通常20バイト
  - TCPデータのチャンク（0バイトまたはそれ以上

- IPヘッダには、送信元と送信先のIPアドレス、サイズ、その他のフラグが含まれています。TCPセグメントヘッダには、TCPポート番号、TCP制御フラグ、データの順序付けや整合性チェックに使用する数値などが含まれます。

### 4.1.3 Keeping TCP Connections Straight
- コンピュータは、一度に複数のTCPコネクションを開いていることがあります。TCPは、これらの接続をポート番号で管理しています。ポート番号は、社員の電話の内線番号のようなものです。会社の電話番号がフロントデスクにつながり、内線番号が適切な従業員につながるように、IPアドレスが適切なコンピュータにつながり、ポート番号が適切なアプリケーションにつながるのです。TCP接続は4つの値で区別されます。

```
<source-IP-address, source-port, destination-IP-address,
destination-port>
```

- これらの4つの値を組み合わせることで、接続を一意に定義します。2つの異なるTCPコネクションは、4つのアドレス構成要素すべてに同じ値を持つことはできません（ただし、異なるコネクションが、いくつかの構成要素に同じ値を持つことは可能です）。図4-5では、4つのコネクションがあります。各ポートの関連情報を表4-1に示します。

### 4.1.4 Programming with TCP Sockets
- オペレーティングシステムは、TCP接続を操作するためのさまざまな機能を提供しています。
- ソケットAPIは、TCPとIPの詳細をすべてHTTPプログラマから隠しています。
- ソケット API では、TCP エンドポイントのデータ構造を作成したり、これらのエンドポイントをリモート・サーバの TCP エンドポイントに接続したり、データ・ストリームを読み書きしたりすることができます。TCP APIでは、基礎となるネットワーク・プロトコルのハンドシェイクや、IPパケットとの間で行われるTCPデータ・ストリームのセグメント化と再構成などの詳細はすべて隠されています。

### 4.2 TCP Performance Considerations
- HTTP は TCP に直接レイヤリングされているため、HTTP トランザクションのパフォーマンスは、基礎となる TCP 配管のパフォーマンスに決定的に依存します。このセクションでは、これらのTCP接続のパフォーマンスに関するいくつかの重要な検討事項を紹介します。TCP の基本的なパフォーマンス特性を理解することで、HTTP の接続最適化機能をよりよく理解することができ、よりパフォーマンスの高い HTTP アプリケーションを設計、実装することができます。

### 4.2.1 HTTP Transaction Delays
- 基本的に、ほとんどのHTTPの遅延はTCPネットワークの遅延が原因である。
  - DNSルックアップ　ローカルにキャッシュされていない場合、数十秒かかることもある。
  - TCPコネクション確立　新しいTCP接続ごとに発生する。通常はせいぜい1,2秒だが、HTTPトランザクションが多数発生すると累積する。
  - TCP接続確立後のリクエスト、レスポンスがインターネット上を移動し、処理されるまでの時間がかかる。

### 4.2.2 Performance Focus Areas
- このセクションでは、HTTPプログラマに影響を与える最も一般的なTCP関連の遅延について、その原因やパフォーマンスへの影響などを説明します。

  - TCP 接続設定のハンドシェイク
  - TCP スロースタート輻輳制御
  - データ集約のためのNagleのアルゴリズム
  - TCPの遅延確認応答アルゴリズムによるピギーバック確認応答
  - TIME_WAITの遅延とポートの枯渇

### 4.2.3 TCP Connection Handshake Delays

### 4.2.4 Delayed Acknowledgments

### 4.2.5 TCP Slow Start

### 4.2.6 Nagle's Algorithm and TCP_NODELAY

### 4.2.7 TIME_WAIT Accumulation and Port Exhaustion

## 4.3 HTTP Connection Handling
- この章の残りの部分では、接続を操作して最適化するための HTTP 技術について説明します。まず、誤解されがちですが、HTTP接続管理の重要な部分であるHTTP Connectionヘッダーについて説明します。次に、HTTP の接続最適化技術について説明します。

### 4.3.1 The Oft-Misunderstood Connection Header - 意外と知られていない接続用ヘッダー
- HTTPでは、クライアントと最終的なオリジンサーバーの間に、一連のHTTP中間体が存在します。(プロキシ、キャッシュなど)があります。HTTPメッセージは、クライアントから仲介装置を経由して、オリジンサーバー（またはその逆）にホップ・バイ・ホップで転送されます。
- 場合によっては、隣接する2つのHTTPアプリケーションが、共有された コネクションにオプションセットを適用したい場合があります。HTTP Connection ヘッダーフィールドには、他のコネクションに伝搬されないコネクションのオプションを指定するコネクショントークンがコンマで区切られて表示されます。例えば、次のメッセージを送信した後に閉じなければならないコネクションは、Connection: closeで示されます。Connectionヘッダーには、3つの異なるタイプのトークンが含まれているため、混乱することがあります。

  - HTTP ヘッダーフィールド名（この接続のみに関連するヘッダーのリスト）
  - 任意のトークンの値：この接続の非標準的なオプションを示します。
  - closeという値は、接続が完了したときに永続的な接続が閉じられることを示します。

- ConnectionトークンにHTTPヘッダーフィールド名が含まれている場合、そのヘッダーフィールドには接続固有の情報が含まれており、転送してはいけません。Connection ヘッダーに記載されているヘッダーフィールドは、メッセージを転送する前に削除する必要があります。ホップバイホップのヘッダー名を Connection ヘッダーに置くことは、「ヘッダーの保護」として知られています。これは、Connection ヘッダーが、ローカルヘッダーの偶発的な転送から保護するためです。その例を図4-9に示します。
- HTTP アプリケーションが Connection ヘッダーを持つメッセージを受信すると、受信者は、送信者が要求したすべてのオプションを解析して適用します。その後、Connection ヘッダーと Connection ヘッダーに記載されているすべてのヘッダーを削除してから、メッセージを次のホップに転送します。さらに、Connectionヘッダーの値としてリストアップされていないが、プロキシされてはならないいくつかのhop-by-hopヘッダーがあります。これらには、Proxy-Authenticate、Proxy-Connection、Transfer-Encoding、および Upgrade が含まれます。Connectionヘッダーの詳細については、付録Cを参照してください。

### 4.3.2 Serial Transaction Delays
- TCPのパフォーマンスの遅延は、接続が単純に管理されている場合（シリアルローディング）、累積することがあります。
- HTTP接続のパフォーマンスを向上させるために、いくつかの最新の技術があります。次のいくつかのセクションでは、そのような技術のうち4つについて説明します。
  - Parallel connections：複数のTCPコネクションで同時にHTTPリクエストを行う 
  - Persistent connections：TCPコネクションを再利用することで、接続/終了時の遅延を解消
  - Pipelined connections：共有されたTCPコネクション上で、同時にHTTPリクエストを実行
  - Multiplexed connections：リクエストとレスポンスのチャンクをインターリーブする（実験的）

## 4.4 Parallel Connections
- HTTPでは、図4-11に示すように、クライアントが複数のコネクションを開き、複数のHTTPトランザクションを並行して実行することができます。この例では，4つの埋め込み画像が並行して読み込まれ，各トランザクションが独自のTCPコネクションを取得しています。

### 4.4.1 Parallel Connections May Make Pages Load Faster
- 埋め込みオブジェクトで構成された複合ページは、単一の接続によるデッドタイムと帯域幅の制限を利用すると、より速く読み込まれることがあります。

### 4.4.2 Parallel Connections Are Not Always Faster
- しかし、並列接続の方が速いといっても、必ずしも速いとは限りません。クライアントのネットワーク帯域幅が狭い場合（例えば、28.8Kbpsのモデムでインターネットに接続しているブラウザなど）、ほとんどの時間がデータの転送だけに費やされてしまうことがあります。このような状況では、高速なサーバーへの1つのHTTPトランザクションが、利用可能なモデムの帯域幅のすべてを簡単に消費してしまいます。複数のオブジェクトを並行してロードする場合、各オブジェクトは限られた帯域幅を奪い合うことになるため、各オブジェクトのロード速度は比例して遅くなり、パフォーマンス上の利点はほとんどありません
- また、多数のオープンコネクションは大量のメモリを消費し、それ自体がパフォーマンス問題を引き起こす可能性があります。複雑なWebページでは、数十から数百のオブジェクトが埋め込まれている場合があります。クライアントは何百もの接続を開くことができるかもしれませんが、ウェブサーバーは他の多くのユーザーのリクエストを同時に処理していることが多いため、その状況を望むサーバーはほとんどいないでしょう。100人のユーザーが同時に100個の接続を開くと、サーバーには1万個の接続の負担がかかります。これは、サーバーの大幅なスローダウンの原因となります。このような状況は、高負荷のプロキシについても同様です。実際には、ブラウザは並列接続を使用しますが、並列接続の総数は少数（多くは4）に制限されています。サーバーは、特定のクライアントからの過剰な接続を自由に閉じることができます。

### 4.4.3 Parallel Connections May "Feel" Faster
- なるほど、並列接続をすれば必ずページの読み込みが速くなるわけではありません。しかし、実際にページの転送速度が速くならなくても、先に述べたように、並列接続によって、ユーザーがページの読み込みが速くなったと感じることはよくあります。人間は、たとえストップウォッチで実際にページのダウンロード時間の合計が遅くなったとしても、画面全体でたくさんのアクションが行われていると、ウェブページの読み込みが速くなったと感じるのです 

## 4.5 Persistent Connections
- ウェブクライアントは、しばしば同じサイトへの接続を開きます。例えば、Webページに埋め込まれている画像のほとんどは、同じWebサイトから来ていることが多く、他のオブジェクトへのハイパーリンクのかなりの数が同じサイトを指しています。このように、あるサーバーにHTTPリクエストを開始したアプリケーションは、近い将来、そのサーバーにさらにリクエストを行う可能性があります（例えば、インライン画像を取得するために）。この性質をサイトロカリティといいます。
- このような理由から、HTTP/1.1 (およびHTTP/1.0の拡張版) では、HTTPデバイスが、トランザクションが完了した後もTCPコネクションを開いたままにしておき、将来のHTTPリクエストに既存のコネクションを再利用できるようになっています。トランザクションが完了した後も開かれているTCPコネクションは、持続的なコネクションと呼ばれます。非持続的な接続は、各トランザクションの後に閉じられます。持続的な接続は、クライアントまたはサーバのいずれかが接続を閉じると決定するまで、トランザクションを超えて開かれたままになります。
- 対象となるサーバーに対してすでにオープンしているアイドル状態の持続的な接続を再利用することで、遅い接続設定を回避することができます。また、すでに開いている接続を利用することで、開始時に時間のかかる輻輳適応フェーズを回避でき、より高速なデータ転送が可能になります。

### 4.5.1 Persistent Versus Parallel Connections
- 並列接続は速いが欠点もあった。
  - 各トランザクションが新しいコネクションを開閉するため、時間と帯域幅を消費する
  - それぞれの新しいコネクションはTCPスロースタートのためにパフォーマンスが低下する
  - 開いている並列接続数には実用上の制限がある
- 持続的な接続は、並列接続に比べていくつかの利点があります。接続確立の遅延とオーバーヘッドを減らし、接続を調整済みの状態に保ち、潜在的なオープンコネクションの数を減らすことができます。しかし、持続的接続は慎重に管理する必要があります。そうしないと、多数のアイドル接続が蓄積され、ローカルリソースやリモートクライアントおよびサーバーのリソースを消費してしまう可能性があります。
- 持続的な接続は、並列接続と組み合わせて使用すると最も効果的です。現在、多くのウェブアプリケーションでは、少数の並列接続を開き、それぞれを持続的に使用しています。持続的接続には、古い HTTP/1.0+ の "keep-alive "接続と、新しい HTTP/1.1 の "persistent "接続の2種類があります。次のいくつかのセクションでは、この2つのタイプについて説明します。

### 4.5.2 HTTP/1.0+ Keep-Alive Connections
- 多くのHTTP/1.0ブラウザやサーバーは、（1996年頃から）キープアライブ接続と呼ばれる初期の実験的なタイプの持続的な接続をサポートするように拡張されました。この初期の持続的接続には、相互運用性の設計上の問題があり、後のHTTP/1.1の改訂で修正されましたが、多くのクライアントやサーバーは今でもこの初期のキープアライブ接続を使用しています。
- 図4-13は、シリアル接続による4つのHTTPトランザクションのタイムラインと、単一の持続的接続による同じトランザクションのタイムラインを比較したものです。タイムラインが短縮されているのは、コネクトとクローズのオーバーヘッドが取り除かれているからです[16]。

### 4.5.3 Keep-Alive Operation
- Keep-alive は非推奨で、現在の HTTP/1.1 仕様では文書化されていません。しかし、Keep-alive ハンドシェイクはブラウザやサーバで比較的よく使われていますので、HTTP 実装者は相互運用の準備をしておく必要があります。ここでは、キープアライブの動作について簡単に説明します。keep-alive ハンドシェイクについてのより詳細な説明は、古いバージョンの HTTP/1.1 仕様 (RFC 2068 など) を参照してください。
- HTTP/1.0 のキープアライブ接続を実装するクライアントは、Connection:Keep-Alive リクエストヘッダを含めることで、接続を維持することを要求できます。
- サーバは、次のリクエストに対して接続を維持することを希望する場合は、同じヘッダをレスポンスに含めて応答します（図4-14参照）。応答に Connection: keep-alive ヘッダがない場合、クライアントは、サーバが keep-alive をサポートしておらず、応答メッセージが返送された時点でサーバが接続を終了するものと想定します。

### 4.5.4 Keep-Alive Options
- keep-aliveヘッダーは、接続を維持するための単なる要求であることに注意してください。クライアントとサーバーは、keep-aliveセッションが要求されても、それに同意する必要はありません。クライアントとサーバーは、アイドル状態のkeep-alive接続をいつでも閉じることができ、keep-alive接続で処理されるトランザクションの数を自由に制限することができます。
Keep-Aliveの動作は、Keep-Alive一般ヘッダで指定されるコンマ区切りのオプションによって調整できます。

  - timeoutパラメータは、Keep-Aliveレスポンスヘッダで送信されます。このパラメータは、サーバが接続を維持する可能性のある時間を推定します。これは保証されるものではありません。
  - max パラメーターは、Keep-Alive 応答ヘッダーで送信されます。これは、サーバーがあと何回のHTTPトランザクションの間、接続を維持できるかを示します。これは保証されるものではありません。
  - Keep-Alive ヘッダーは、主に診断やデバッグを目的とした、任意の未処理属性もサポートしています。構文は name [= value] です。

- Keep-Alive ヘッダーは完全にオプションですが、Connection.Keep-Alive も存在する場合にのみ許可されます。

### 4.5.5 Keep-Alive Connection Restrictions and Rules

### 4.5.6 Keep-Alive and Dumb Proxies
- ウェブクライアントのConnection: Keep-Aliveヘッダーは、クライアントから出て行く1つのTCPリンクだけに影響を与えることを目的としています。これが、「コネクション」ヘッダーと名付けられた理由です。クライアントがWebサーバーと通信している場合、クライアントはConnection: Keep-Aliveヘッダを送信して、キープアライブを希望することをサーバに伝えます。
- サーバーは、キープアライブをサポートしている場合はConnection: Keep-Aliveヘッダーを送り返し、サポートしていない場合は送らない。

#### 4.5.6.1 The Connection header and blind relays
- 問題はプロキシにあります。特に、Connectionヘッダを理解しておらず、プロキシ処理を行う前にこのヘッダを削除する必要があることを知らないプロキシです。古いプロキシやシンプルなプロキシの多くは、Connectionヘッダを特別に処理することなく、あるコネクションから別のコネクションへとバイトをトンネリングするブラインドリレーとして動作します。
- プロキシがConnectionヘッダーを知らないことにより、keep-alive接続をしようとするとハングアップが起こる。

#### 4.5.6.2 Proxies and hop-by-hop headers
- このようなプロキシのミスコミュニケーションを避けるために、最近のプロキシはConnectionヘッダーやConnectionの値の中に名前が出てくるヘッダーを決してプロキシしてはいけません。つまり、プロキシが Connection: Keep-Aliveヘッダを受け取った場合、プロキシはConnectionヘッダもKeep-Aliveという名前のヘッダもプロキシしてはいけません。
- さらに、Connectionヘッダーの値としてリストされていないが、プロキシしたり、キャッシュ応答として提供してはならないいくつかのhop-by-hopヘッダーがある。これには、ProxyAuthenticate、Proxy-Connection、Transfer-Encoding、および Upgrade が含まれます。詳細については、4.3.1項を参照してください。

### 4.5.7 The Proxy-Connection Hack
- ネットスケープ社のブラウザとプロキシの実装者たちは、ブラインドリレーの問題を解決するために、すべてのウェブアプリケーションが高度なバージョンのHTTPをサポートする必要のない、巧妙な回避策を提案した。この回避策では、Proxy-Connectionと呼ばれる新しいヘッダを導入し、クライアントの直後に介在する単一のブラインドリレーの問題を解決しましたが、他のすべての状況を解決することはできませんでした。
- Proxy-Connectionは、最近のブラウザではプロキシが明示的に設定されている場合に実装され、多くのプロキシが理解しています。ダムプロキシが問題になるのは、Connection:Keep-Aliveなどのhop-by-hopヘッダをやみくもに転送するからだということです。
- ホップバイホップヘッダは、その単一の特定の接続にのみ関連しており、転送してはいけません。これは、転送されたヘッダが下流のサーバによって、プロキシ自身が接続を制御するための要求であると誤解された場合に問題となります。
- ネットスケープの回避策では、ブラウザは公式にサポートされている有名なConnectionヘッダーの代わりに、非標準のProxy-Connection拡張ヘッダーをプロキシに送信します。プロキシがブラインド・リレーの場合、プロキシは無意味なProxy-Connectionヘッダをwebサーバに中継し、webサーバはそのヘッダを無害に無視します。しかし、プロキシがスマートプロキシ(持続的な接続ハンドシェイクを理解できる)であれば、無意味なProxy-ConnectionヘッダをConnectionヘッダに置き換え、それをサーバに送信することで望ましい効果を得ることができます。
- この方式は、クライアントとサーバーの間にプロキシが1台しかない場合に有効だが、ダムプロキシの両側にスマートプロキシがある場合、再び問題が出てくる。
- さらに、ファイアウォール、インターセプトキャッシュ、リバースプロキシサーバアクセラレータなど、「見えない」プロキシがネットワーク上に登場することが非常に多くなっています。これらのデバイスはブラウザからは見えないため、ブラウザはProxy-Connectionヘッダを送信しません。透過的なWebアプリケーションでは、持続的な接続を正しく実装することが重要です。

### 4.5.8 HTTP/1.1 Persistent Connections
- HTTP/1.1では、キープアライブ接続のサポートを段階的に廃止し、代わりに持続的接続と呼ばれる改良された設計を採用しました。持続的接続の目的は keep-alive 接続と同じですが、メカニズムの動作が改善されています。
- HTTP/1.0+ のキープアライブ接続とは異なり、HTTP/1.1 の持続的な接続はデフォルトで有効です。
- HTTP/1.1 は、他に指示がない限り、すべての接続が持続的であると仮定します。HTTP/1.1 アプリケーションは、トランザクションの完了後に接続を閉じることを示すために、メッセージに Connection: close ヘッダを明示的に追加する必要があります。これは、キープアライブ接続が任意であるか、完全にサポートされていなかった以前のバージョンの HTTP プロトコルとの大きな違いです。
- HTTP/1.1 クライアントは、レスポンスに Connection: close ヘッダーが含まれていない限り、レスポンス後も HTTP/1.1 コネクションが開いたままであることを想定します。しかし、クライアントやサーバーは、いつでもアイドル状態のコネクションを閉じることができます。Connection: close を送信しないことは、サーバーがコネクションを永遠に開いたままにすることを約束するものではありません。

### 4.5.9 Persistent Connection Restrictions and Rules
- Connection: close request headerを送信した後、クライアントはそのコネクション上でそれ以上のリクエストを送信することはできません。
- クライアントがそのコネクション上で他のリクエストを送りたくない場合は、最終リクエストの中でConnection: close request headerを送るべきです。
- コネクション上のすべてのメッセージが、正しく自己定義されたメッセージ長を持つ場合のみ、コネクションを持続させることができます。すなわち、エンティティボディが正しい Content-Length を持つか、chunked transfer エンコーディングでエンコードされていなければなりません。
- HTTP/1.1 プロキシは、クライアントとサーバーとの間の永続的な接続を別々に管理しなければならず、各永続的な接続は単一のトランスポートホップに適用される。
- HTTP/1.1 プロキシサーバーは、クライアントの能力について何かを知らない限り、HTTP/1.0 クライアントとの持続的な接続を確立すべきではありません (Connection ヘッダを転送する古いプロキシの問題のため)。
クライアントの能力を知らない限り、HTTP/1.0クライアントとの持続的な接続を確立してはいけません。これは実際には難しく、多くのベンダーがこのルールを曲げています。
- Connection ヘッダの値にかかわらず、HTTP/1.1 デバイスはいつでも接続を閉じることができますが、サーバーはメッセージ送信の途中で閉じることは避け、閉じる前に少なくとも 1 つのリクエストに応答する必要があります。
- HTTP/1.1 アプリケーションは、非同期のクローズから回復できなければなりません。クライアントは、蓄積されるような副作用がない限り、リクエストを再試行するべきです。
- クライアントは、レスポンス全体を受け取る前にコネクションがクローズした場合、リクエストが繰り返されると副作用が発生する可能性がない限り、リクエストを再試行する準備をしなければなりません。
- シングルユーザーのクライアントは、サーバーの過負荷を防ぐために、どのサーバーやプロキシに対しても最大で2つの持続的な接続を維持する必要があります。プロキシは、同時ユーザをサポートするためにサーバへのより多くの 接続を必要とするかもしれないので、サーバにアクセスしようとする ユーザがN人いる場合、プロキシはいかなるサーバまたは親プロキシに 対しても最大で2N個の接続を維持すべきである。

## 4.6 Pipelined Connections
- HTTP/1.1では、持続的な接続におけるオプションのリクエストパイプライニングが可能です。これは、キープアライブ接続よりもさらにパフォーマンスが向上します。複数のリクエストを、レスポンスの到着前に待ち受けることができます。最初のリクエストが地球の反対側にあるサーバーにネットワークを介してストリーミングされている間に、2番目と3番目のリクエストが進行します。これにより、ネットワークのラウンドトリップを減らすことができ、高レイテンシーのネットワーク環境でのパフォーマンスを向上させることができます。
- 図4-18a-cは、持続的な接続によってTCP接続の遅延を解消し、パイプライン化されたリクエスト（図4-18c）によって転送の遅延を解消する方法を示しています。
- パイプラインにはいくつかの制限があります。
  - HTTPクライアントは、接続が持続することを確認するまでパイプラインを使用してはいけません。
  - HTTP レスポンスは、リクエストと同じ順序で返されなければなりません。HTTP メッセージはシーケンス番号でタグ付けされていないため、レスポンスを順不同で受信した場合、レスポンスとリクエストを一致させる方法はありません。
  - HTTP クライアントは、接続がいつでも閉じられるように準備しておく必要があります。 HTTP クライアントは、いつでも接続を閉じることができるように準備し、終了しなかったパイプライン化されたリクエストをやり直す準備をしておく必要があります。クライアントが永続的な接続を開き、すぐに10個のリクエストを発行した場合、サーバーは例えば5個のリクエストだけを処理した後に自由に接続を閉じることができます。残りの5つのリクエストは失敗します。クライアントは、このような早すぎるクローズを処理して、リクエストを再発行することを望まなければなりません。
  - HTTP クライアントは、副作用のあるリクエスト（POST など）をパイプラインで処理すべきではありません。一般に、エラー時にパイプライン化すると、クライアントはパイプライン化された一連のリクエストのうち、どのリクエストがサーバーで実行されたかを知ることができません。POST のような非一時的なリクエストは安全に再試行できないため、エラー状態では一部のメソッドが実行されないというリスクがあります。

## 4.7 The Mysteries of Connection Close
- 接続管理、特にいつ、どのように接続を閉じるかということは、HTTPの実用的なブラックアートの1つです。この問題は、多くの開発者が最初に認識しているよりも微妙なもので、この問題について書かれたものはほとんどありません。

### 4.7.1 "At Will" Disconnection
- HTTP クライアント、サーバ、プロキシは、いつでも TCP トランスポート接続を閉じることができます。コネクションは通常、メッセージの最後で閉じられますが、エラー状態の時には、ヘッダー行の途中やその他の奇妙な場所で閉じられることがあります。
- この状況は、パイプライン化された持続的な接続でよく見られます。HTTPアプリケーションは、任意の期間後に永続的な接続を閉じることができます。例えば、持続的な接続がしばらくアイドル状態になった後、サーバーはその接続をシャットダウンすることができます。
- しかし、サーバーは、「アイドル」接続がサーバーによってシャットダウンされている間に、回線の反対側にいるクライアントがデータを送信しようとしていなかったことを確実に知ることはできません。これが起こると、クライアントはリクエストメッセージを書いている最中に接続エラーを確認します。

### 4.7.2 Content-Length and Truncation
- 各 HTTP レスポンスには、レスポンスボディのサイズを示す正確な Content-Length ヘッダーが必要です。古い HTTP サーバーの中には、データの実際の終了を示すサーバーのコネクションクローズに依存して、Content-Length ヘッダーを省略したり、誤った長さを含めたりするものがあります。
- クライアントやプロキシがコネクションクローズで終了する HTTP レスポンスを受け取り、実際に転送されたエンティティの長さが Content-Length と一致しない (または Content-Length がない) 場合、受信者は長さの正しさを疑うべきです。
- 受信者がキャッシュプロキシの場合、受信者は応答をキャッシュすべきではない(潜在的なエラーの将来的な複合化を最小限にするため)。プロキシは、セマンティックな透明性を維持するために、Content-Lengthの「修正」を試みることなく、疑わしいメッセージをそのまま転送すべきである。

### 4.7.3 Connection Close Tolerance, Retries, and Idempotency
- 接続は、エラーが発生していない状態でも、いつでも閉じることができます。HTTP アプリケーションは、予期せぬクローズを適切に処理する準備をしなければなりません。クライアントがトランザクションを実行しているときにトランスポート接続が閉じた場合、トランザクションに副作用がない限り、クライアントは接続を再度開き、1回だけ再試行する必要があります。
- パイプライン接続の場合、状況はさらに悪化します。クライアントは多数のリクエストをエンキューすることができますが、オリジンサーバーは接続を閉じることができ、多数のリクエストが処理されずに残り、再スケジューリングが必要になります。
- 副作用は重要です。あるリクエストデータが送信された後、レスポンスが返される前にコネクションがクローズされた場合、クライアントは、トランザクションのうちどれだけが実際にサーバによって呼び出されたかを100％確信することはできません。静的なHTMLページをGETするようなトランザクションは、何も変更せずに何度でも繰り返すことができます。他のトランザクション、例えばオンライン書店への注文のPOSTなどは繰り返すべきではありません、さもないと複数の注文を受ける危険性があります。
- トランザクションは、一度実行されても何度も実行されても同じ結果が得られる場合、冪等であると言えます。実装者は、GET、HEAD、PUT、DELETE、TRACE、OPTIONSの各メソッドがこの性質を持つと仮定することができます。
メソッドがこの性質を持っていると仮定することができます。 クライアントは（POSTのような）冪等でないリクエストをパイプラインで送るべきではありません。
- そうしないと、トランスポート接続の早期終了により、不確定な結果になる可能性があります。非冪等のリクエストを送信したい場合は、前のリクエストのレスポンスステータスを待つべきです。
- 非べき等のメソッドやシーケンスは自動的に再試行されてはならないが、ユーザエージェントは人間のオペレータにリクエストを再試行する選択肢を提供することができる。例えば、ほとんどのブラウザは、キャッシュされたPOSTレスポンスを再読み込みする際に、トランザクションを再度投稿するかどうかを尋ねるダイアログボックスを提供します。

### 4.7.4 Graceful Connection Close
- 図4-19に示すように、TCPコネクションは双方向である。TCPコネクションの各側には、データの読み書きのための入力キューと出力キューがあります。

#### 4.7.4.1 Full and half closes
- アプリケーションは、TCP の入力チャネルと出力チャネルのいずれか、または両方を閉じることができます。close()ソケット・コールは、TCP 接続の入力チャネルと出力チャネルの両方を閉じます。これは「フル・クローズ」と呼ばれ、図 4-20a に示されています。shutdown()ソケット・コールを使用すると、入力チャネルまたは出力チャネルを個別に閉じることができます。これは「ハーフクローズ」と呼ばれるもので、図 4-20b に示されています。

a. server full close
<--|
---|
b. server output half close (graceful close)
<--|
--->
c. server input half close
<---
---|

#### 4.7.4.2 TCP close and reset errors
- 単純なHTTPアプリケーションでは、フルクローズしか使用できません。しかし、アプリケーションが他の多くのタイプのHTTPクライアント、サーバー、プロキシと通信するようになったり、パイプラインによる持続的な接続を使用するようになると、相手が予期しない書き込みエラーを起こさないようにするために、ハーフクローズを使用することが重要になります。
- 一般的に、接続の出力チャネルを閉じることは常に安全です。接続の反対側にいるピアは、バッファからすべてのデータが読み込まれると、end-of-stream通知を受け取って、接続を閉じたことが通知されます。
- 接続の入力チャネルを閉じることは、相手側がこれ以上データを送る予定がないことがわかっている場合を除き、リスクが高くなります。相手側があなたの閉じた入力チャネルにデータを送信すると、オペレーティングシステムは、図4-21に示すように、TCPの「Connection reset by peer」メッセージを相手側のマシンに返します。ほとんどのオペレーティングシステムはこれを重大なエラーとして扱い、相手側がまだ読んでいないバッファリングされたデータを消去します。これは、パイプライン接続にとって非常に悪いことです。
- 持続的な接続でパイプライン化された10個のリクエストを送信し、レスポンスはすでに到着してオペレーティングシステムのバッファに置かれているとします（ただし、アプリケーションはまだ読んでいません）。ここで、あなたがリクエスト#11を送信したとします。しかし、サーバーはあなたがこの接続を十分に使用したと判断し、接続を閉じました。あなたのリクエスト#11は閉じたコネクションに到着し、あなたにリセットを返します。このリセットにより、入力バッファが消去されます。ようやくデータを読めるようになったとき、ピアエラーによるコネクションリセットが発生し、バッファリングされた未読のレスポンスデータは、その多くが正常にあなたのマシンに到着したにもかかわらず、失われてしまいます。

### 4.7.4.3 Graceful close
- HTTP仕様では、クライアントやサーバが予期せずに接続を閉じたい場合、「トランスポート接続にグレースフルクローズを発行する」ことが推奨されていますが、その方法については記述されていません。
- 一般的に、グレースフルクローズを実装するアプリケーションは、まず自分の出力チャンネルを閉じ、次に接続の反対側にいる相手が自分の出力チャンネルを閉じるのを待ちます。双方がもうデータを送信しないことを伝え終わったら（つまり、出力チャンネルを閉じたら）、リセットのリスクなしに、接続を完全に閉じることができます。
- 残念ながら、相手側がハーフクローズを実装しているかどうか、チェックしているかどうかは保証されていません。このため、gracefullyに閉じたいアプリケーションは、出力チャネルをハーフクローズし、入力チャネルの状態を定期的にチェックする必要があります（データの有無やストリームの終了を確認する）。あるタイムアウト時間内に入力チャネルがピアによってクローズされなかった場合、アプリケーションはリソースを節約するために強制的に接続をクローズすることができます。

# Part II: HTTP Architecture
- Ch5 ~ 10

# Ch5 Web Servers
- ウェブサーバは、1日に何十億ものウェブページを配信しています。天気予報を伝えたり、オンラインショッピングのカートを積み込んだり、懐かしい高校時代の友人を探したりしています。ウェブサーバは、World Wide Webの主力製品です。この章では、以下のことを説明します。

  - ソフトウェアおよびハードウェアのウェブサーバのさまざまな種類について説明します。
  - Perlで簡単な診断用Webサーバを書く方法を説明します。
  - ウェブサーバがどのようにHTTPトランザクションを処理するのか、順を追って説明します。

- 物事を具体的に説明するために、例ではApache Webサーバとその設定オプションを使用します。

## 5.1 Web Servers Come in All Shapes and Sizes
- Webサーバーは、HTTPリクエストを処理し、レスポンスを提供します。「Webサーバー」という言葉は、Webサーバーソフトウェアを指す場合と、Webページを提供するための専用のデバイスやコンピューターを指す場合があります。
- ウェブサーバーには、さまざまな種類、形、サイズがあります。些細な10行のPerlスクリプトのウェブサーバもあれば、50MBの安全なコマースエンジンもありますし、小さなカード型のサーバもあります。しかし、機能的な違いはあっても、すべてのウェブサーバはリソースに対するHTTPリクエストを受け取り、クライアントにコンテンツを提供します（図1-5を参照）。

### 5.1.1 Web Server Implementations
- Webサーバは、HTTPとそれに関連するTCPコネクションの処理を実装します。また、ウェブサーバーが提供するリソースを管理し、ウェブサーバーを設定、制御、強化するための管理機能を提供します。
- Webサーバーロジックは、HTTPプロトコルを実装し、Webリソースを管理し、Webサーバーの管理機能を提供します。Webサーバのロジックは、TCPコネクションの管理をOSと分担しています。
- オペレーティングシステムは、基礎となるコンピュータシステムのハードウェアの詳細を管理し、TCP/IPネットワークのサポート、ウェブリソースを保持するファイルシステム、および現在のコンピューティングアクティビティを制御するプロセス管理を提供します。
- Webサーバーにはさまざまな種類があります。

  - 一般的なコンピュータシステムに、汎用ソフトウェアのウェブサーバーをインストールして実行することができます。
  - ソフトウェアをインストールするのが面倒な場合は、ウェブサーバーアプライアンスを購入することができます。このアプライアンスは、ソフトウェアがあらかじめコンピュータにインストールされ、設定された状態で、スタイリッシュな筐体に収められています。
  - また、マイクロプロセッサの進歩により、少数のチップで構成された組み込み型のウェブサーバーを提供している企業もあり、コンシューマー機器の管理コンソールとしても最適です。

- それでは、それぞれのタイプの実装を見ていきましょう。

### 5.1.2 General-Purpose Software Web Servers
- 汎用ソフトウェアのウェブサーバーは、ネットワークに接続された標準的なコンピュータシステム上で動作する。オープンソースのソフトウェア（ApacheやW3CのJigsawなど）や商用ソフトウェア（MicrosoftやiPlanetのWebサーバーなど）を選択することができます。Webサーバーのソフトウェアは、ほぼすべてのコンピュータとOSに対応しています。
- 何万種類ものウェブサーバープログラム（カスタムメイドの特別な目的のウェブサーバーを含む）がありますが、ほとんどのウェブサーバーソフトウェアは、少数の組織から提供されています。
- 比率としてはApacheソフトウェアが多いとされる。

### 5.1.3 Web Server Appliances
- Webサーバーアプライアンスは、ソフトウェアとハードウェアがパッケージ化されたソリューションです。ベンダーは、ベンダーが選択したコンピュータプラットフォームにソフトウェアサーバーをあらかじめインストールし、ソフトウェアを事前に設定します。以下の例があります。
- Webサーバーアプライアンスの例としては、次のようなものがあります。

  - Sun/Cobalt RaQ Webアプライアンス (http://www.cobalt.com)
  - 東芝Magnia SG10 (http://www.toshiba.com)
  - IBM Whistle Webサーバーアプライアンス (http://www.whistle.com) 

- アプライアンスソリューションは、ソフトウェアのインストールや設定の必要性を排除し、多くの場合、管理を大幅に簡素化します。しかし、Webサーバーの柔軟性や機能性は低く、サーバーハードウェアの再利用やアップグレードも容易ではありません。

### 5.1.4 Embedded Web Servers
- 組み込み型サーバーは、プリンターや家電製品などのコンシューマー製品に組み込むことを目的とした小型のウェブサーバーです。
- 組込み型Webサーバを使用することで、ユーザは便利なWebブラウザのインターフェースを使用して、コンシューマ機器を管理することができます。
- 組み込み型Webサーバの中には、1平方インチ以下の大きさで実装できるものもありますが、通常は最小限の機能しか提供されていません。

## 5.2 A Minimal Perl Web Server
- フル機能のHTTPサーバーを構築するには、いくつかの作業が必要になります。Apacheウェブサーバのコア部分には5万行以上のコードがあり、オプションの処理モジュールを使えば、その数はもっと多くなります。
- これらのソフトウェアは、HTTP/1.1の機能をサポートするために必要です。リッチリソースサポート、バーチャルホスティング、アクセスコントロール、ロギング、コンフィギュレーション、モニタリング、パフォーマンス機能などです。とはいえ、最低限の機能を備えたHTTPサーバは、30行以下のPerlで作ることができます。（例5-1 type-o-serveというPerlのプログラム）

## 5.3 What Real Web Servers Do
- 最新の商用Webサーバは例5-1よりもっと複雑ですが、図5-3に示すように、いくつかの一般的なタスクを実行します。

  1. 接続の設定：クライアントの接続を受け入れるか、クライアントが不要な場合は閉じる。
  2. リクエストの受信：ネットワークからのHTTPリクエストメッセージを読み込みます。
  3. リクエストの処理：リクエストメッセージを解釈してアクションを起こす。
  4. Access resource：メッセージで指定されたリソースにアクセスする。
  5. Construct response：正しいヘッダーを持つ HTTP レスポンスメッセージを作成する。
  6. レスポンスの送信：レスポンスをクライアントに返信します。
  7. トランザクションの記録：完了したトランザクションに関するメモをログファイルに記録します。

- 次の7つのセクションでは、ウェブサーバーがこれらの基本的なタスクをどのように実行するかを説明します。

## 5.4 Step 1: Accepting Client Connections
- クライアントは、サーバーとの持続的接続がすでに開かれている場合は、その接続を使用してリクエストを送信することができます。そうでない場合は、クライアントはサーバーへの新しい接続を開く必要があります

### 5.4.1 Handling New Connections
- クライアントがウェブサーバへのTCP接続を要求すると、ウェブサーバは接続を確立し、TCP接続からIPアドレスを抽出して、接続の相手方がどのクライアントであるかを判断します。 新しい接続が確立されて受け入れられると、サーバは新しい接続を既存のウェブサーバの接続リストに追加し、接続上のデータを監視する準備をします。
- ウェブサーバは、どのような接続も自由に拒否し、直ちに閉鎖することができます。ウェブサーバの中には、クライアントのIPアドレスやホスト名が不正なものであったり、既知の悪意のあるクライアントであったりするために、接続を閉じるものもあります。その他の識別技術を使用することもできます。

### 5.4.2 Client Hostname Identification
- ほとんどのウェブサーバは、"リバースDNS "を使用して、クライアントのIPアドレスをクライアントのホスト名に変換するように設定できます。ウェブサーバは、クライアントのホスト名を利用して、詳細なアクセス制御やロギングを行うことができます。ただし、ホスト名の検索には非常に長い時間がかかるため、Webトランザクションの速度が低下する可能性があることに注意してください。大容量のウェブサーバの多くは、ホスト名解決を無効にしたり、特定のコンテンツに対してのみ有効にしたりしています。
- Apache では Hostname Lookups 設定ディレクティブを使ってホスト名検索を有効にすることができます。（例ではHTML、CGIリソースが設定されているが、これはクライアントがこれらの種類のリソース取得を依頼した場合にはクライアントのIPをホスト名に変換するということか？）

### 5.4.3 Determining the Client User Through ident
- 一部のウェブサーバーは、IETFのidentプロトコルをサポートしています。identプロトコルでは、どのユーザーがHTTP接続を開始したかをサーバーが知ることができます。この情報は、ウェブサーバのログ収集に特に役立ちます。一般的なCommon Log Formatの第2フィールドには、各HTTPリクエストのidentユーザー名が含まれています。
- クライアントがidentプロトコルをサポートしている場合、クライアントはTCPポート113でidentリクエストを待ち受けます。図5-4にidentプロトコルの仕組みを示します。図5-4aでは、クライアントがHTTPコネクションを開きます。サーバは、クライアントのidentdサーバポート（113）に戻る独自の接続を開き、新しい接続（クライアントとサーバのポート番号で指定）に対応するユーザ名を求める単純なリクエストを送信し、ユーザ名を含む応答をクライアントから取得します。
- identは組織内では機能しますが、公共のインターネット上では、以下のような多くの理由でうまく機能しません。

  - 多くのクライアントPCでは、Identification Protocolのデーモンソフトウェアであるidentdが動作しません。
  - identプロトコルは、HTTPトランザクションを大幅に遅延させます。
  - 多くのファイアウォールがidentのトラフィックの受信を許可しない。
  - identプロトコルは安全ではなく、偽造も容易です。
  - identプロトコルは、仮想IPアドレスをうまくサポートできません。
  - クライアントのユーザ名を公開することには、プライバシーの問題があります。

- ApacheのIdentityCheck onディレクティブを使って、Identルックアップを使うようにApacheのウェブサーバに伝えることができます。ident の情報が得られない場合、Apache は ident のログフィールドをハイフン (-) で埋めます。Common Log Format のログファイルは、ID 情報がないため、通常 2 番目のフィールドにハイフンが含まれています。

## 5.5 Step 2: Receiving Request Messages
- コネクションにデータが到着すると、ウェブサーバーはネットワークコネクションからデータを読み取って リクエストメッセージの一部を解析します（図5-5）。
- リクエストメッセージを解析する際、ウェブサーバーは以下の作業を行います。

  - リクエスト行を解析して，リクエストメソッド，指定されたリソース識別子（URI），バージョン番号を探し[3]，それぞれを1つのスペースで区切り，最後にCRLF（carriage-return line-feed）シーケンスで終了する[4]。
    - [3] HTTPの初期バージョンであるHTTP/0.9は、バージョン番号をサポートしていません。一部のウェブサーバーはバージョン番号の欠落をサポートしており、メッセージをHTTP/0.9のリクエストとして解釈します。
    - [4] クライアントの中には、LF を行末のターミネーターとして誤って送信するものがあるため、多くのウェブサーバーは行末のシーケンスとして LF または CRLF をサポートしています。
  - CRLF で終わるメッセージヘッダーを読み取ります。
  - CRLF で終わるヘッダの空行を検出します（存在する場合）。
  - リクエストボディがあれば読み取る（Content-Length ヘッダーで指定された長さ）。

- リクエストメッセージを解析する際、ウェブサーバーはネットワークから不規則に入力データを受け取ります。ネットワーク接続はどの時点でも失速する可能性があります。Web サーバーは、ネットワークからデータを読み取り、メッセージの部分的なデータを一時的にメモリに格納してから、メッセージを解析して意味を理解するのに十分なデータを受け取る必要があります。

### 5.5.1 Internal Representations of Messages
- ウェブサーバの中には、リクエストメッセージを内部のデータ構造に格納して、メッセージの操作を容易にしているものもあります。例えば、データ構造にはリクエストメッセージの各部分のポインタと長さが格納され、ヘッダは高速ルックアップテーブルに格納され、特定のヘッダの特定の値に素早くアクセスできるようになっているかもしれません（図5-6）。

### 5.5.2 Connection Input/Output Processing Architectures
- 高性能なウェブサーバは、数千の同時接続をサポートしています。これらの接続により、ウェブサーバは世界中のクライアントと通信することができ、各クライアントはサーバに対して1つまたは複数の接続を開いています。これらの接続の中には、ウェブサーバーに素早くリクエストを送信しているものもあれば、ゆっくりと、あるいはまれにしかリクエストを送信しないものもあります。また、将来の活動を静かに待っているアイドル状態の接続もあります。
- リクエストはいつでも発生する可能性があるため、Webサーバは常に新しいWebリクエストを監視しています。図5-7に示すように、ウェブサーバのアーキテクチャによって、リクエストの処理方法は異なります。

- シングルスレッドのウェブサーバ（図5-7a）
  - シングルスレッドのウェブサーバは、一度に1つのリクエストを完了するまで処理します。トランザクションが完了すると、次の接続が処理されます。このアーキテクチャは実装が簡単ですが、処理中は他のすべての接続が無視されます。これは深刻なパフォーマンス問題を引き起こすので、負荷の低いサーバーやtype-o-serveのような診断ツールにのみ適しています。

- マルチプロセス・マルチスレッドWebサーバ（図5-7b）
  - マルチプロセス・マルチスレッドWebサーバは、複数のプロセスや効率の良いスレッドを使用して、リクエストを同時に処理します[5]。スレッド/プロセスは、必要に応じて作成される場合もあれば、事前に作成される場合もあります[6]。接続ごとにスレッドやプロセスを割り当てるサーバもありますが、サーバが数百、数千、あるいは数万の同時接続を処理する場合、結果としてプロセスやスレッドの数が多くなり、メモリやシステムリソースを消費してしまう可能性があります。そのため、マルチスレッド対応のウェブサーバーの多くは、スレッド/プロセスの最大数に制限を設けています。
  - [5]プロセスとは、個々のプログラムの制御の流れであり、独自の変数群を持つものです。スレッドは、プロセスのより高速で効率的なバージョンです。スレッドもプロセスも、1つのプログラムで複数のことを同時に行うことができます。説明を簡単にするために、ここではプロセスとスレッドを同じように扱います。しかし、性能の違いから、多くの高性能サーバーはマルチプロセスとマルチスレッドの両方を採用している。
  - [6]スレッドをあらかじめ作成しておくシステムを「ワーカープール」と呼びますが、これはスレッドの集合体がプールで仕事を待っているからです。

- 多重化されたI/Oサーバー（図5-7c）
  - 大量の接続をサポートするために、多くのウェブサーバは多重化アーキテクチャを採用しています。多重化されたアーキテクチャでは、すべての接続が同時に監視され、活動が行われます。接続の状態が変化したとき（データが利用可能になったときや、エラー状態が発生したときなど）、その接続に対して少量の処理が行われ、その処理が完了すると、その接続は次の状態変化のために開いている接続リストに戻される。処理が完了すると、次の状態変更のために接続がオープンリストに戻されます。処理すべきことがある場合にのみ、接続上で作業が行われ、スレッドやプロセスがアイドル状態の接続を待つことはありません。

- 多重化されたマルチスレッドのWebサーバ（図5-7d）
  - マルチスレッドとマルチプレックスを組み合わせて、コンピュータ・プラットフォームの複数のCPUを活用するシステムもあります。複数のスレッド（多くの場合、物理的なプロセッサごとに1つ）がそれぞれ開いている接続（または開いている接続のサブセット）を監視し、各接続に対して少量の作業を行います。

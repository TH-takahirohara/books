HTTP: The Definitive Guide

# Part I: HTTP: The Web's Foundation
- Ch1 ~ Ch4

# Ch1. Overview of HTTP
## 1.1 

## 1.2 Web Clients and Servers
- HTTPサーバーはインターネットのデータを保持し、HTTPクライアントからリクエストされたらそれを渡す。
- 最も一般的なクライアントはWebブラウザ。

## 1.3 Resources
- webサーバーはwebリソースをホストする。webリソースは、webコンテンツの元となるもの。
- 最も単純なwebリソースは、HTMLなどの静的ファイルであるが、静的ファイルでなくても良い。リソースは要求に応じたコンテンツを生成するプログラムでも良い。
- 要約すると、リソースとはあらゆる種類のコンテンツソースのこと。

### 1.3.1 Media Types
- HTTPは、MIMEというデータフォーマットラベルを各オブジェクトに付与して転送する。
- Webサーバは、すべてのHTTPオブジェクトデータにMIMEタイプを付加する。
  - ヘッダー Content-type: image/jpeg のimage/jpegがMIME typeにあたる。
- MIMEタイプは、主なオブジェクトタイプと特定のサブタイプをスラッシュで区切って表現したテキストラベルである。
  - HTMLからなるテキストドキュメントは、text/html となる。

### 1.3.2 URIs
- クライアントは、自分が興味のあるリソースを指摘することができる。サーバーリソース名をURIと呼ぶ。
- URIはインターネットの郵便番号のようなもので、世界中の情報資源を一意に識別し、位置を特定する。
- URIはURLとURNからなる。

### 1.3.3 URLs
- URLは、特定のサーバー上のリソースの特定の場所を示す。
- スキーマ、アドレス、リソースの３箇所に主に分かれる。

### 1.3.4 URNs
- URNは、 リソースが現在どこにあるかに関係なく、特定のコンテンツのユニークな名前を提供する。
- まだ広く採用されていない。対応するインフラが必要なため。

## 1.4 Transactions

### 1.4.1 Methods

### 1.4.2 Status Codes

### 1.4.3 Web pages can consist of multiple objects
- アプリケーションは、タスクを達成するために複数のHTTPトランザクションを発行することがよくある。
- 埋め込まれたリソースは、異なるサーバーに存在することもある。

## 1.5 Messages
- HTTPメッセージはStart line、Header fields、Body からなる。
- ボディには任意のバイナリデータを格納可能

## 1.6 Connection
- TCP
  - エラーのないデータ転送
  - in-order delivery（データは常に送信された順に届く）
  - セグメント化されていないデータストリーム（任意のサイズのデータをいつでも垂れ流すことができる）
- TCP/IPは個々のネットワークやハードウェアの特殊性・欠点を隠す。

## 1.7 Protocol Versions

## 1.8 Architectural components of the web
### 1.8.1 Proxies
- HTTPプロキシサーバーは、Webセキュリティ、アプリケーション統合、パフォーマンス最適化のための重要な構成要素。
- ユーザーの代理として、ユーザーに代わってサーバーにアクセスするアプリケーション。
- プロキシはセキュリティのために使用されることが多く、すべてのウェブトラフィックが流れる信頼できる仲介者として機能する。

### 1.8.2 Caches
- webキャッシュやキャッシングプロキシは、プロキシを通過する主要なドキュメントのコピーを保持する特殊なHTTPプロキシサーバーである。
- クライアントは、離れたwebサーバーからよりも近くのキャッシュを利用することで、はるかに早くドキュメントを取得できる。HTTPは、キャッシュをより効果的にし、キャッシュされたコンテンツの鮮度やプライバシーを管理するための多くの機能を定義している。

### 1.8.3 Gateways
- ゲートウェイとは、他のサーバーを仲介する特別なサーバー。一般にHTTPトラフィックを別のプロトコルに変換する。ゲートウェイはオリジンサーバーのように振る舞うので、クライアントはゲートウェイと通信していると気づかない。

### 1.8.4 Tunnels
- トンネルは、セットアップ後、2つの接続間で生データを盲目的に中継するHTTPアプリケーション。HTTPトンネルは、HTTP以外のデータを1つまたは複数のHTTP接続を介して、データを見ることなく転送するためによく使用される。
- HTTPトンネルは、暗号化されたセキュア・ソケット・レイヤー（SSL）トラフィックをHTTP接続で伝送することで、Webトラフィックのみを許可する企業のファイアウォールを介してSSLトラフィックを許可するという使い方が一般的である。

### 1.8.5 Agents
- ユーザーエージェント（または単にエージェント）は、ユーザーに代わってHTTPリクエストを行うクライアントプログラムである。ブラウザ以外のユーザーエージェントが多くある。
- 例えば、人間が監視することなく、自律的にウェブを歩き回り、HTTPトランザクションを発行したり、コンテンツを取得したりする機械によって自動化されたユーザーエージェントがある。これらの自動化されたエージェントには、「スパイダー」や「ウェブロボット」などのカラフルな名前がついていることが多い。スパイダーは、検索エンジンのデータベースや比較ショッピングロボットの製品カタログなど、ウェブコンテンツの有用なアーカイブを構築するためにウェブを徘徊する。

# Ch2. URLs and Resources
- URLはインターネットリソースの標準的な名前である。

## 2.1 Navigating the Internet's Resources
- URLは、ブラウザが情報を検索する際に必要となるリソースの位置情報です。インターネット上の何十億ものデータリソースを人々やアプリケーションが見つけ、利用し、共有するためのものです。URLは、HTTPやその他のプロトコルに対する人間の通常のアクセスポイントです。人間がブラウザでURLを指定すると、裏ではブラウザが適切なプロトコルメッセージを送信し、人間が求めるリソースを取得します。
- URLの最初の部分はURLスキーマ。webクライアントに「どうやって」リソースにアクセスするかを伝える。
- URLの第二の部分はサーバーの場所。webクライアントに、リソースが「どこに」ホストされているかを伝える。
- URLの第三の部分は、リソースパス。これはサーバー上の「何の」ローカルリソースがリクエストされているかを伝える。
- 世の中にあるすべてのリソースと、そのリソースを得るためのすべての方法に対して、それぞれのリソースに単一の名前を付けることで、誰もがその名前を使ってリソースを見つけることができるようになっているのです。しかし、これは必ずしもそうではありませんでした。

### 2.1.1 The dark days before URLs

## 2.2 URL Syntax
- ほとんどのURLは一般的なURL構文に準拠しており、異なるURLスキームの間でスタイルや構文が大きく重複しています。
- ほとんどのURLは9つのパートに分かれる。

```
<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<qu
ery>#<frag>
```
- これらの構成要素をすべて含むURLはほとんどありません。最も重要な要素はscheme, host, pathです。

### 2.2.1 Schemes: What Protocol to Use
- schemeは与えられたリソースにアクセスする方法についての主要なIDである。schemeはURLを解釈するアプリケーションに、どのプロトコルを使う必要があるかを伝える。

### 2.2.2 hosts and ports
- インターネット上のリソースを見つけるために、アプリケーションはリソースをホストしているマシンを知り、そのマシンのどこに目的のリソースにアクセスできるサーバーがあるのかを知る必要があります。
- hostコンポーネントは、リソースにアクセスできるインターネット上のホストマシンを特定します。名前は、上記のようにホスト名（「www.joes-hardware.com」）として提供することも、IPアドレスとして提供することもできます。
- portコンポーネントは、サーバーがリッスンしているネットワークポートを特定します。基本的にTCPプロトコルを使用するHTTPの場合、デフォルトのポートは80です。

### 2.2.3 usernames and passwords

### 2.2.4 Paths
- URLのpathコンポーネントは、サーバーマシン上のどこにリソースがあるかを指定します。

### 2.2.5 parameters
- アプリケーションがサーバーと正しく対話するために必要な入力パラメータを与えるために、URLにはparamsコンポーネントがあります。このコンポーネントは、URL内の名前と値のペアのリストで、URLの他の部分と（そしてお互いに）「;」文字で区切られています。このコンポーネントは、アプリケーションがリソースにアクセスするために必要な追加情報を提供します。

### 2.2.6 query strings
- データベースサービスなどの一部のリソースでは、要求されているリソースの種類を絞り込むために、質問や問い合わせをすることができます。
- URLのqueryコンポーネントはゲートウェイ・リソースに渡され、URLのpathコンポーネントはゲートウェイ・リソースを特定します。基本的に、ゲートウェイは他のアプリケーションへのアクセスポイントと考えることができます。

### 2.2.7 fragments
- リソースの一部や断片を参照できるように、URLはリソース内の断片を識別するfragコンポーネントをサポートしています。例えば、URLは、HTMLドキュメント内の特定の画像やセクションを指し示すことができます。
- フラグメントは、URLの右端に#文字を付けてぶら下げます。
- クライアントはリソース全体を取得した後、fragmentで指定するリソースの部分を表示する。（ブラウザの場合、そこまでスクロールする。）

## 2.3 URL Shortcuts
- Web クライアントは、いくつかの URL ショートカットを理解して使用しています。相対URLは、リソースの中にリソースを指定する便利な略語です。また、多くのブラウザはURLの「自動展開」をサポートしています。ユーザーがURLの重要な（記憶に残る）部分を入力すると、ブラウザが残りの部分を埋めてくれます。

### 2.3.1 Relative URLs - 相対URL
- URLには、絶対URLと相対URLの2種類があります。
- ここまでは、絶対URLについてのみ説明してきました。絶対URLには、リソースにアクセスするために必要な情報がすべて含まれています。一方、相対URLは不完全なものです。相対URLからリソースへのアクセスに必要なすべての情報を得るためには、ベースと呼ばれる別のURLから相対的に解釈しなければなりません。相対URLは、URLの便利な略記法です。
- 省略可能な相対URL構文により、HTML作成者はURLからスキームやホストなどの構成要素を省略することができます。これらの要素は、それらが含まれるリソースのベースURLから推測できます。他のリソースのURLもこの短縮形で指定することができます。
- また、相対URLは、一連のリソース（HTMLページなど）をポータブルに保つための便利な方法です。相対URLを使用すると、一連のドキュメントを移動しても、新しいベースに対して相対的に解釈されるため、リンクが機能します。これにより、他のサーバにコンテンツをミラーリングすることなどが可能になります。

#### 2.3.1.1 Base URLs
- 変換プロセスの最初のステップは、ベースURLを見つけることです。ベースURLは、相対URLを参照するためのポイントとなります。ベースURLはいくつかの場所から得られます。
  - リソースで明示されている
  - カプセル化されたリソースのベースURL　（HTMLなど）相対URLが埋め込まれているリソースのURLをベースにすることができる。
  - ベースとなるURLがない

#### 2.3.1.2 Resolving relative references
- 相対URLを絶対URLに変換するアルゴリズムがある。もともとRFC1808で規定され、その後RFC2396に組み込まれた。

### 2.3.2 Expandomatic URLs - URLの拡大
- 一部のブラウザでは、URLを送信した後や入力中に、自動的にURLを展開しようとするものがあります。これにより、ユーザーは完全なURLを入力する必要がなく、自動的に展開されるため、ショートカットを得ることができます。
- これらの「expandomatic」機能には、2つの種類があります。
  - ホスト名展開
    - ブラウザは簡単なヒューリスティクスを利用して、ユーザーの助けを借りずに、入力したホスト名を完全なホスト名に展開することができます。
  - 履歴の展開
    - URLを入力する手間を省くためにブラウザが採用しているもうひとつのテクニックが、過去にアクセスしたURLの履歴を保存することです。URLを入力する際に、入力した内容と履歴に残っているURLの接頭辞を照合することで、完成度の高い選択肢を提供することができます。

## 2.4 Shady Characters
- URLには、比較的小さく、普遍的に安全なアルファベットの文字のみを含めることが許可されている。
- URLは完全でなければなりません。URL の設計者は、URL にバイナリデータや、普遍的に安全なアルファベット以外の文字を含めたいと思う場合があることに気付きました。そこで、安全でない文字を安全な文字にエンコードして転送できるように、エスケープメカニズムを追加しました。

### 2.4.1 The URL Character Set
- URL設計者は、完全性の必要性を認識して、エスケープシーケンスを取り入れました。エスケープシーケンスは、任意の文字値やデータをUS-ASCII文字セットの限定されたサブセットを使ってエンコードすることで、移植性と完全性を実現します。

### 2.4.2 Encoding Mechanisms
- 安全な文字セットの表現の限界を回避するために、安全ではないURLの文字を表現するエンコード方式が考案されました。このエンコーディングでは、安全でない文字を、パーセント記号（%）と、その文字のASCIIコードを表す2つの16進数からなる「エスケープ」表記で単純に表します。

### 2.4.3 Character Restrictions - 文字の制限
- いくつかの文字は、URLの中で特別な意味を持つように予約されています。

### 2.4.4 A Bit More

## 2.5 A sea of schemes
- httpスキーマは、usernameとpasswordがないこと以外は一般的なURLフォーマットと同じ。デフォルトポートは80。
- https
- mailto

## 2.6 the future
- URN
- PURL

# Ch3 HTTP Messages
- HTTP がインターネットの運び屋であるとすれば、HTTP メッセージは物を移動するためのパッケージです。この章では以下を学びます。
  - メッセージの流れ
  - HTTP メッセージの 3 つの部分 (開始行、ヘッダー、エンティティボディ)
  - リクエストメッセージとレスポンスメッセージの違い
  - リクエストメッセージがサポートするさまざまな機能（メソッド）について
  - レスポンスメッセージで返されるさまざまなステータスコード
  - 各種 HTTP ヘッダーの役割 

## 3.1 The Flow of Messages
- HTTPメッセージは、HTTPアプリケーション間で送信されるデータのブロックです。これらのデータブロックは、メッセージの内容や意味を説明するテキストのメタ情報で始まり、その後にオプションのデータが続きます。これらのメッセージは、クライアント、サーバー、およびプロキシの間を流れます。メッセージの方向性を示す用語として、「インバウンド」、「アウトバウンド」、「アップストリーム」、「ダウンストリーム」があります。

### 3.1.1 Messages Commute Inbound to the Origin Server
- HTTPでは、トランザクションの方向性を表すために、インバウンドとアウトバウンドという用語を使用しています。メッセージはオリジンサーバーに向かってインバウンドで送信され、その作業が終わるとユーザーエージェントに向かってアウトバウンドで送信されます（図3-1参照）。

### 3.1.2 Messages Flow Downstream
- HTTP メッセージは川のように流れます。すべてのメッセージは、リクエスト・メッセージかレスポンス・メッセージかにかかわらず、下流に向かって流れます（図3-2参照）。メッセージの送信者は受信者の上流に位置します。

## 3.2 The Parts of a Message
- HTTPメッセージは、フォーマットされたシンプルなデータの塊です。図3-3にその例を示していますのでご覧ください。各メッセージには、クライアントからのリクエストまたはサーバからのレスポンスが含まれています。メッセージは3つの部分から構成されています。メッセージを説明するスタートライン、属性を含むヘッダーのブロック、そしてデータを含むオプションのボディです。
- 開始行とヘッダーは単なるASCIIテキストで、行ごとに区切られています。各行の終わりには、キャリッジリターン（ASCII 13）とラインフィード（ASCII 10）の2文字の行末シーケンスがあります。
- この行末記号は "CRLF "と表記されます。HTTPの行末仕様はCRLFですが、堅牢なアプリケーションでは、ラインフィード文字だけを受け入れるべきであることを指摘しておきます。古いHTTPアプリケーションや壊れたHTTPアプリケーションの中には、キャリッジリターンとラインフィードの両方を送るとは限らないものもあります。
- エンティティボディまたはメッセージボディ（または単に「ボディ」）は、単なるオプションのデータチャンクです。開始行やヘッダーとは異なり、ボディにはテキストやバイナリデータを含めることができ、また空にすることもできます。

### 3.2.1 Message Syntax
- すべてのHTTPメッセージは、「リクエストメッセージ」と「レスポンスメッセージ」の2種類に分類されます。リクエストメッセージはウェブサーバに動作を要求し，レスポンスメッセージはリクエストの結果をクライアントに返します。
```
// リクエストメッセージのフォーマット
<method> <request-URL> <version>
<headers>

<entity-body> 

// レスポンスメッセージのフォーマット
<version> <status> <reason-phrase>
<headers>

<entity-body>
```
- method
  - クライアントがサーバーにリソースに対して実行してほしいアクション。GET"、"HEAD"、"POST "などの単一の単語で構成されます。この章の後半では、メソッドについて詳しく説明します。
- request-URL
  - 要求されたリソースを指定する完全なURL、またはURLのパスコンポーネントです。サーバーと直接やりとりする場合は、リソースへの絶対パスであれば、通常、URLのパスコンポーネントは問題ありません（サーバーは自分自身をURLのホスト／ポートとみなすことができます）。
- version
- status-code
- reason-phrase
  - ステータスコードの数値を人間が読めるようにしたもので、行末までのすべてのテキストで構成される。理由のフレーズは、人間が消費するためだけのものです。
- headers
  - 0個以上のヘッダは、名前の後にコロン(:)、任意のホワイトスペース、値、CRLFが続きます。ヘッダーは空行 (CRLF) で終了し、ヘッダーのリストの終わりと、エンティティボディの始まりを示します。HTTP/1.1 などの一部のバージョンの HTTP では、リクエストやレスポンスのメッセージが有効であるために、特定のヘッダが存在することが要求されます。様々な HTTP ヘッダーについては、この章の後半で説明します。
- entity-body
  - エンティティボディは、任意のデータブロックを含みます。すべてのメッセージにエンティティ・ボディが含まれているわけではないので、メッセージが CRLF で終了することもあります。エンティティについては第 15 章で詳しく説明します。
- HTTP ヘッダは、ヘッダがなくても、エンティティボディがなくても、常に空行(CRLF)で終わるべきであることに注意してください。しかし、これまで多くのクライアントやサーバーは、エンティティボディがない場合、最後のCRLFを（誤って）省略していました。

### 3.2.2 Start Lines

#### 3.2.2.1 リクエスト・ライン
- リクエスト・メッセージは、リソースに対して何かをするようサーバに要求します。リクエスト・メッセージのスタート・ライン（リクエスト・ライン）には、サーバが実行すべき操作を記述したメソッドと、そのメソッドを実行するリソースを記述したリクエストURLが含まれます。また、リクエストラインには、クライアントが使用しているHTTPの方言をサーバーに伝えるHTTPバージョンも含まれています。
- これらのフィールドはすべてホワイトスペースで区切られています。

#### 3.2.2.2 レスポンスライン
- レスポンス・メッセージは、操作によって得られたステータス情報や結果のデータをクライアントに返します。レスポンスメッセージの開始行（レスポンスライン）には、レスポンスメッセージが使用しているHTTPバージョン、数値化されたステータスコード、操作のステータスを説明するテキストの理由フレーズが含まれます。これらのフィールドはすべて、ホワイトスペースで区切られています。

#### 3.2.2.2 メソッド
- メソッドは、リクエストの開始行を開始し、サーバーに何をすべきかを伝えます。たとえば、「GET /specials/saw-blade.gif HTTP/1.0」という行では、メソッドはGETです。
- HTTPの仕様では、一般的なリクエストメソッドのセットが定義されています。例えば、GETメソッドはサーバーからドキュメントを取得し、POSTメソッドはサーバーにデータを送信して処理を行い、OPTIONSメソッドはWebサーバーの一般的な機能や特定のリソースに対するWebサーバーの機能を決定します。
- 表3-1では、これらのうち7つのメソッドについて説明しています。なお、リクエストメッセージにボディがあるメソッドと、ボディのないリクエストがあるメソッドがあります。
- すべてのサーバーが表3-1の7つのメソッドをすべて実装しているわけではありません。また、HTTPは拡張性を重視して設計されているため、他のサーバーがこれらに加えて独自のリクエストメソッドを実装している場合もあります。これらの追加メソッドは、HTTPの仕様を拡張するものであるため、拡張メソッドと呼ばれます。

#### 3.2.2.4 ステータスコード
- ステータスコードは、各応答メッセージの開始行に返されます。ステータスには、数字と人間が読める文字の両方が含まれます。数字はプログラムのエラー処理を容易にし、理由は人間が理解しやすいようになっています。
- それぞれのステータスコードは、3桁の数値コードによってクラス分けされています。200から299までのステータスコードは成功を表す。300から399までのコードは、リソースが移動されたことを示す。400から499までのコードは、クライアントがリクエストで何か間違ったことをしたことを意味します。500から599までのコードは、サーバー上で何か問題が発生したことを意味します。
- 現在のバージョンのHTTPでは、各ステータスカテゴリにいくつかのコードしか定義されていません。プロトコルの進化に伴い、より多くのステータスコードがHTTP仕様で公式に定義される予定です。見覚えのないステータスコードを受け取った場合は、誰かが現在のプロトコルの拡張として定義した可能性があります。そのコードは、そのコードが含まれるクラスの一般的なメンバーとして扱われるべきです。

#### 3.2.2.5 reason phrases
- HTTPの仕様では、理由を示す語句がどのようなものであるべきか、明確なルールは定められていません。

#### 3.2.2.6 Version numbers
- バージョン番号は、HTTP アプリケーションが相互にどのバージョンのプロトコルに準拠しているかを伝える手段となります。バージョン番号は、HTTP を使用するアプリケーションに、互いの能力やメッセージの形式についての手がかりを提供することを目的としています。HTTP バージョン 1.1 のアプリケーションと通信する HTTP バージョン 1.2 のアプリケーションは、1.2 の新機能を使用すべきではないことを知るべきです。なぜなら、それらの機能は、古いバージョンのプロトコルを使用するアプリケーションによって実装されていない可能性が高いからです。

### 3.2.3 Headers
- HTTP ヘッダーフィールドは、リクエストとレスポンスのメッセージに追加の情報を与えます。これらは基本的に、名前と値のペアのリストです。

#### 3.2.3.1 Header classifications
- 各HTTPヘッダーは、名前の後にコロン（：）、任意のホワイトスペース、フィールド値、CRLFというシンプルな構文になっています。

### 3.2.4 Entity Bodies
- HTTPメッセージの第3の部分は、オプションのエンティティボディです。エンティティボディは、HTTPメッセージのペイロードです。エンティティボディは、HTTPメッセージのペイロードであり、HTTPが輸送するために設計されたものです。
- HTTPメッセージは、画像、ビデオ、HTML文書、ソフトウェアアプリケーション、クレジットカード、電子メールなど、さまざまな種類のデジタルデータを伝送することができます。

### 3.2.5 Version 0.9 Messages

## 3.3 Methods
- ここでは、表3-1に示した基本的なHTTPメソッドのいくつかについて詳しく説明します。ただし、すべてのサーバがすべてのメソッドを実装しているわけではありません。HTTP バージョン 1.1 に準拠するためには、サーバーはそのリソースに対して GET と HEAD メソッドのみを実装する必要があります。
- サーバーがこれらのメソッドをすべて実装していたとしても、そのメソッドはほとんどの場合、用途が制限されています。例えば、DELETEやPUT（後述）をサポートするサーバは、誰でもリソースを削除したり保存したりできることを望んでいません。このような制限は、一般的にはサーバーの設定で設定されるため、サイトやサーバーによって異なります。

### 3.3.1 Safe Methods
- HTTP では、安全なメソッドと呼ばれる一連のメソッドが定義されています。GET メソッドと HEAD メソッドは安全であると言われています。つまり、GET メソッドまたは HEAD メソッドを使用した HTTP リクエストの結果、何も起こらないことを意味します。何も起こらないというのは、HTTPリクエストの結果としてサーバー上で何も起こらないということです。
- 例えば、あなたがJoe's Hardwareでオンラインショッピングをしていて、「購入」ボタンをクリックしたとします。このボタンをクリックすると、クレジットカード情報を含むPOSTリクエスト(後述)が送信され、お客様に代わってサーバー上でアクションが実行されます。この場合のアクションとは、お客様のクレジットカードに購入代金が請求されることです。
- 安全なメソッドを使用しても、アクションが実行されないという保証はありません（実際には、ウェブ開発者次第ですが...）。安全なメソッドとは、何らかのアクションが実行される可能性のある安全でないメソッドが使用されている場合に、HTTPアプリケーションの開発者がユーザーに知らせるためのものです。Joe's Hardwareの例では、Webブラウザが警告メッセージを表示し、安全でないメソッドでリクエストを行っていること、その結果、サーバ上で何かが起こる可能性があることを知らせます（例：クレジットカードに課金される）。

### 3.3.2 GET
- GETは最も一般的なメソッドです。通常、サーバーにリソースの送信を依頼する際に使用されます。HTTP/1.1では、サーバーがこのメソッドを実装する必要があります。

### 3.3.3 HEAD
- ヘッダーだけを返すメソッド。下記用途で使う。
  - リソースを取得せずに、そのリソースについて調べる（例えば、タイプを決定する）。
  - レスポンスのステータスコードを見て、オブジェクトが存在するかどうかを確認する。
  - ヘッダを見て、リソースが変更されたかどうかを確認する。

- サーバの開発者は、返されるヘッダが、GETリクエストが返すヘッダと同じであることを確認する必要があります。HTTP/1.1 に準拠するためには、HEAD メソッドも必要です。

### 3.3.4 PUT
- PUTメソッドは、GETがサーバーからドキュメントを読み取るのとは逆に、サーバーにドキュメントを書き込むものである。パブリッシングシステムの中には、PUTを使ってWebページを作成し、Webサーバーに直接インストールできるものもある（図3-9参照）。
- PUTメソッドのセマンティクスは、サーバーがリクエストのボディを受け取り、それを使ってリクエストされたURLで名付けられた新しいドキュメントを作成するか、そのURLがすでに存在する場合は、ボディを使ってそれを置き換えるというものです。PUTはコンテンツの変更を可能にするため、多くのウェブサーバーではPUTを実行する前にパスワードによるログインを要求しています。パスワード認証については、第12章で詳しく説明しています。

### 3.3.5 POST
- OSTメソッドは、入力データをサーバーに送信するために設計されました *。 実際には、HTMLフォームをサポートするためによく使用されます。入力されたフォームからのデータは通常、サーバーに送信され、サーバーはそれを必要な場所（例えば、サーバー・ゲートウェイ・プログラムに送信し、それを処理します）に転送します。
- * POSTは、データをサーバーに送信するために使用されます。PUTは、サーバー上のリソース（ファイルなど）にデータを預けるために使用されます。

### 3.3.6 TRACE
- クライアントがリクエストを行う際、そのリクエストは、ファイアウォール、プロキシ、ゲートウェイ、その他のアプリケーションを経由しなければならない場合があります。これらのそれぞれが、オリジナルのHTTPリクエストを変更する機会を持っています。TRACEメソッドでは、クライアントは、リクエストが最終的にサーバに到達したときの様子を確認することができます。
- TRACEリクエストは、送信先のサーバで「ループバック」診断を開始します。最終目的地のサーバは、受け取ったバージンリクエストメッセージを本文に含んだTRACEレスポンスを返信します。クライアントは、元のメッセージが、HTTPアプリケーションのリクエスト／レスポンスチェーンに沿って、どのように、あるいはどのように変更されたかを確認することができます（図3-11参照）。
- TRACEメソッドは、主に診断のために使用されます。つまり、リクエストが意図したとおりにリクエスト／レスポンスチェーンを通過しているかどうかを検証します。また、プロキシや他のアプリケーションがリクエストに与える影響を確認するのにも適したツールです。TRACEは診断に適していますが、介在するアプリケーションが異なるタイプのリクエスト（異なるメソッド-GET、HEAD、POSTなど）を同じように扱うことを前提としているという欠点があります。多くの HTTP アプリケーションは、メソッドに応じて異なる処理を行います。一般的に、TRACEリクエストをどのように処理するかについては、介在するアプリケーションが判断します。
- TRACEリクエストでは、エンティティボディを送信することはできません。TRACEレスポンスのエンティティボディには、応答サーバが受け取ったリクエストがそのまま含まれています。

### 3.3.7 OPTIONS
- OPTIONSメソッドは、ウェブサーバがサポートしている様々な機能について、サーバに問い合わせるものです。一般的に、あるいは特定のリソースに対してどのようなメソッドをサポートしているかをサーバーに尋ねることができます。(サーバーによっては、特定の種類のオブジェクトに対してのみ特定の操作をサポートしている場合もあります)。
- これにより、クライアントアプリケーションは、様々なリソースに実際にアクセスすることなく、どのようにアクセスするのが最適かを判断することができます。

### 3.3.8 DELETE
- DELETEメソッドは、イメージ通り、リクエストURLで指定されたリソースの削除をサーバーに依頼するものです。しかし、クライアントアプリケーションは、その削除が実行されることを保証されていません。これは、HTTPの仕様では、サーバーがクライアントに断りなくリクエストを上書きすることができるためです。

### 3.3.9 Extension Methods
- HTTPは、新しい機能が旧来のソフトウェアの障害とならないように、フィールド拡張可能な設計となっています。
- 注意すべき点は、すべての拡張メソッドが正式な仕様で定義されているわけではないということです。拡張メソッドを定義しても、ほとんどの HTTP アプリケーションでは理解できない可能性があります。同様に、他のアプリケーションが使用している、理解できない拡張メソッドにHTTPアプリケーションが遭遇する可能性もあります。
- このような場合には、拡張メソッドに対して寛容であることが最善です。プロキシは、エンドツーエンドの動作を壊すことなく、未知のメソッドを持つメッセージを下流のサーバに中継することが可能であれば、それを試みるべきです。そうでない場合は、501 Not Implementedのステータスコードで応答すべきです。

## 3.4 Status Codes
- HTTPステータスコードは、前述の表3-2に示すように、大きく5つのクラスに分類されます。ここでは、5つのクラスごとにHTTPステータスコードをまとめています。

### 3.4.1 100-199: Informational Status Codes

### 3.4.2 200-299: Success Status Codes

### 3.4.3 300-399: Redirection Status Codes
- リダイレクションのステータスコードは、クライアントが興味を持っているリソー スのために別の場所を使用するように伝えるか、あるいはコンテンツの代わりに別の 応答を提供する。リソースが移動した場合には、リダイレクト・ステータス・コードとオプションのLocationヘッダを送信して、リソースが移動したことと、現在どこで見つけられるかをクライアントに伝えることができます（図3-14参照）。これにより、ブラウザは人間のユーザに迷惑をかけることなく、透過的に新しい場所に移動することができます。
- リダイレクトステータスコードの中には、アプリケーションのリソースのローカルコピーをオリジンサーバーで検証するために使用できるものがあります。例えば、HTTPアプリケーションは、リソースのローカルコピーがまだ最新であるかどうか、またはリソースがオリジンサーバーで変更されているかどうかを確認することができます。確認して変更がない旨のレスポンス（304 Not Modified）が返ってきたら、ローカルコピー（キャッシュなど）を表示する。
- 304
  - クライアントは、リクエストヘッダーを含めることで、リクエストを条件付きで行うことができます。条件付きヘッダの詳細については、第3章を参照してください。クライアントが、リソースが最近変更されていない場合のGETなど、条件付きのリクエストを行う場合、リソースが変更されていないことを示すためにこのコードが使用されます。

### 3.4.4 400-499: Client Error Status Codes

### 3.4.5 500-599: Server Error Status Codes

## 3.5 Headers
- ヘッダーとメソッドが連携して、クライアントとサーバーの動作を決定します。このセクションでは、標準的な HTTP ヘッダーと、HTTP/1.1 仕様 (RFC 2616) で明示的に定義されていないいくつかのヘッダーの目的について、簡単に説明します。付録Cでは、これらすべてのヘッダーの詳細をまとめています。
- ヘッダーには、メッセージの種類ごとに固有のものと、リクエストメッセージとレスポンスメッセージの両方に情報を提供する、より一般的な目的のものとがあります。ヘッダーには、大きく分けて5つのクラスがあります。
  - General headers
  - Request headers
  - Response headers
  - Entity headers
    - エンティティ・ヘッダとは、エンティティ・ボディを扱うヘッダのことです。例えば、エンティティヘッダは、エンティティボディ内のデータのタイプを伝えることができます。
  - Extension headers

### 3.5.1 General Headers

### 3.5.2 Request Headers

### 3.5.3 Response Headers

### 3.5.4 Entity Headers
- HTTP メッセージのペイロードを記述するヘッダは数多くあります。リクエストメッセージにもレスポンスメッセージにもエンティティが含まれるため、これらのヘッダはどちらのタイプのメッセージにも含まれます。エンティティヘッダーは、オブジェクトのタイプに関する情報から、リソース上で実行可能な有効なリクエストメソッドまで、エンティティとそのコンテンツに関する幅広い情報を提供します。一般的に、エンティティヘッダーは、メッセージの受信者に何を扱っているかを伝えます。表3-21は、エンティティ情報ヘッダーの一覧です。

#### 3.5.4.1 Content headers
- コンテンツヘッダーは、エンティティのコンテンツに関する特定の情報を提供し、そのタイプ、サイズ、その他処理に役立つ情報を明らかにします。例えば、Webブラウザは返されたコンテンツタイプを見て、オブジェクトをどのように表示するかを知ることができます。表3-22は、さまざまなコンテンツヘッダーの一覧です。

#### 3.5.4.2 Entity caching headers
- 一般的なキャッシュヘッダは、いつ、どのようにキャッシュするかを指示します。エンティティキャッシュヘッダは、キャッシュされるエンティティに関する情報を提供します。たとえば、リソースのキャッシュされたコピーがまだ有効であるかどうかを検証するために必要な情報や、キャッシュされたリソースがいつ無効になるかをよりよく見積もるためのヒントを提供します。
- 第7章では、HTTPリクエストとレスポンスのキャッシュについて詳しく説明します。これらのヘッダは、そこで再び目にすることになるでしょう。表3-23は、エンティティキャッシュヘッダーの一覧です。

# Ch4 Connection Management
- HTTP仕様では、HTTPメッセージについてはよく説明されていますが、HTTPメッセージが流れる際の重要な配管であるHTTPコネクションについてはあまり説明されていません。もしあなたがHTTPアプリケーションを書いているプログラマーならば、HTTPコネクションの裏と表、そしてその使い方を理解する必要があります。
- HTTP 接続の管理は、ちょっとしたブラックアートのようなもので、出版された文献からだけでなく、実験や見習いからも学ぶことができます。この章では、以下のことを学びます。
  - HTTPのTCPコネクションの使い方
  - TCP 接続の遅延、ボトルネック、詰まり
  - HTTP の最適化 (並列接続、キープアライブ接続、パイプライン接続など)
  - 接続を管理する上での注意点 

## 4.1 TCP Connections
- 世界中のHTTP通信は、世界中のコンピュータやネットワーク機器で使用されているパケットスイッチネットワークプロトコルであるTCP/IPを介して行われています。クライアントアプリケーションは、世界中のあらゆる場所で動作しているサーバーアプリケーションとのTCP/IP接続を開くことができます。いったん接続が確立されると、クライアントとサーバーのコンピュータ間で交換されたメッセージが失われたり、破損したり、順番が狂って受信されることはありません。

### 4.1.1 TCP Reliable Data Pipes
- HTTP接続の正体は、TCP接続と、その使い方に関するいくつかのルールに過ぎません。TCP接続は、インターネットの信頼できる接続です。データを正確かつ迅速に送信するためには、TCPの基本的な知識が必要です。
- TCP は HTTP に信頼性の高いビットパイプを提供します。TCPコネクションの片側に詰め込まれたバイトは、正しい順序で反対側に出てきます（図4-2参照）。

### 4.1.2 TCP Streams Are Segmented and Shipped by IP Packets - TCPストリームを分割してIPパケットで出荷する
- TCPは、IPパケット（またはIPデータグラム）と呼ばれる小さな塊でデータを送信します。このように、HTTP は「HTTP over TCP over IP」という「プロトコル・スタック」の最上位の層です（図 4-3a）。安全なバージョンであるHTTPSは、HTTPとTCPの間に暗号化層（TLSまたはSSLと呼ばれる）を挿入します（図4-3b）。
- HTTP は、メッセージを送信する際に、開いている TCP コネクションを介して、メッセージデータのコンテンツを順にストリームします。TCP は、データのストリームを受け取り、セグメントと呼ばれる塊に切り分け、IP パケットと呼ばれるエンベロープ内でセグメントをインターネット上に転送します (図 4-4 参照)。これらはすべてTCP/IPソフトウェアによって処理され、HTTPプログラマーには何も見えません。
各TCPセグメントは、IPパケットによって、あるIPアドレスから別のIPアドレスへと運ばれます。これらのIPパケットには、以下のものが含まれます。

  - IPパケットヘッダ（通常20バイト
  - TCPセグメントのヘッダ（通常20バイト
  - TCPデータのチャンク（0バイトまたはそれ以上

- IPヘッダには、送信元と送信先のIPアドレス、サイズ、その他のフラグが含まれています。TCPセグメントヘッダには、TCPポート番号、TCP制御フラグ、データの順序付けや整合性チェックに使用する数値などが含まれます。

### 4.1.3 Keeping TCP Connections Straight
- コンピュータは、一度に複数のTCPコネクションを開いていることがあります。TCPは、これらの接続をポート番号で管理しています。ポート番号は、社員の電話の内線番号のようなものです。会社の電話番号がフロントデスクにつながり、内線番号が適切な従業員につながるように、IPアドレスが適切なコンピュータにつながり、ポート番号が適切なアプリケーションにつながるのです。TCP接続は4つの値で区別されます。

```
<source-IP-address, source-port, destination-IP-address,
destination-port>
```

- これらの4つの値を組み合わせることで、接続を一意に定義します。2つの異なるTCPコネクションは、4つのアドレス構成要素すべてに同じ値を持つことはできません（ただし、異なるコネクションが、いくつかの構成要素に同じ値を持つことは可能です）。図4-5では、4つのコネクションがあります。各ポートの関連情報を表4-1に示します。

### 4.1.4 Programming with TCP Sockets
- オペレーティングシステムは、TCP接続を操作するためのさまざまな機能を提供しています。
- ソケットAPIは、TCPとIPの詳細をすべてHTTPプログラマから隠しています。
- ソケット API では、TCP エンドポイントのデータ構造を作成したり、これらのエンドポイントをリモート・サーバの TCP エンドポイントに接続したり、データ・ストリームを読み書きしたりすることができます。TCP APIでは、基礎となるネットワーク・プロトコルのハンドシェイクや、IPパケットとの間で行われるTCPデータ・ストリームのセグメント化と再構成などの詳細はすべて隠されています。

### 4.2 TCP Performance Considerations
- HTTP は TCP に直接レイヤリングされているため、HTTP トランザクションのパフォーマンスは、基礎となる TCP 配管のパフォーマンスに決定的に依存します。このセクションでは、これらのTCP接続のパフォーマンスに関するいくつかの重要な検討事項を紹介します。TCP の基本的なパフォーマンス特性を理解することで、HTTP の接続最適化機能をよりよく理解することができ、よりパフォーマンスの高い HTTP アプリケーションを設計、実装することができます。

### 4.2.1 HTTP Transaction Delays
- 基本的に、ほとんどのHTTPの遅延はTCPネットワークの遅延が原因である。
  - DNSルックアップ　ローカルにキャッシュされていない場合、数十秒かかることもある。
  - TCPコネクション確立　新しいTCP接続ごとに発生する。通常はせいぜい1,2秒だが、HTTPトランザクションが多数発生すると累積する。
  - TCP接続確立後のリクエスト、レスポンスがインターネット上を移動し、処理されるまでの時間がかかる。

### 4.2.2 Performance Focus Areas
- このセクションでは、HTTPプログラマに影響を与える最も一般的なTCP関連の遅延について、その原因やパフォーマンスへの影響などを説明します。

  - TCP 接続設定のハンドシェイク
  - TCP スロースタート輻輳制御
  - データ集約のためのNagleのアルゴリズム
  - TCPの遅延確認応答アルゴリズムによるピギーバック確認応答
  - TIME_WAITの遅延とポートの枯渇

### 4.2.3 TCP Connection Handshake Delays

### 4.2.4 Delayed Acknowledgments

### 4.2.5 TCP Slow Start

### 4.2.6 Nagle's Algorithm and TCP_NODELAY

### 4.2.7 TIME_WAIT Accumulation and Port Exhaustion

## 4.3 HTTP Connection Handling
- この章の残りの部分では、接続を操作して最適化するための HTTP 技術について説明します。まず、誤解されがちですが、HTTP接続管理の重要な部分であるHTTP Connectionヘッダーについて説明します。次に、HTTP の接続最適化技術について説明します。

### 4.3.1 The Oft-Misunderstood Connection Header - 意外と知られていない接続用ヘッダー
- HTTPでは、クライアントと最終的なオリジンサーバーの間に、一連のHTTP中間体が存在します。(プロキシ、キャッシュなど)があります。HTTPメッセージは、クライアントから仲介装置を経由して、オリジンサーバー（またはその逆）にホップ・バイ・ホップで転送されます。
- 場合によっては、隣接する2つのHTTPアプリケーションが、共有された コネクションにオプションセットを適用したい場合があります。HTTP Connection ヘッダーフィールドには、他のコネクションに伝搬されないコネクションのオプションを指定するコネクショントークンがコンマで区切られて表示されます。例えば、次のメッセージを送信した後に閉じなければならないコネクションは、Connection: closeで示されます。Connectionヘッダーには、3つの異なるタイプのトークンが含まれているため、混乱することがあります。

  - HTTP ヘッダーフィールド名（この接続のみに関連するヘッダーのリスト）
  - 任意のトークンの値：この接続の非標準的なオプションを示します。
  - closeという値は、接続が完了したときに永続的な接続が閉じられることを示します。

- ConnectionトークンにHTTPヘッダーフィールド名が含まれている場合、そのヘッダーフィールドには接続固有の情報が含まれており、転送してはいけません。Connection ヘッダーに記載されているヘッダーフィールドは、メッセージを転送する前に削除する必要があります。ホップバイホップのヘッダー名を Connection ヘッダーに置くことは、「ヘッダーの保護」として知られています。これは、Connection ヘッダーが、ローカルヘッダーの偶発的な転送から保護するためです。その例を図4-9に示します。
- HTTP アプリケーションが Connection ヘッダーを持つメッセージを受信すると、受信者は、送信者が要求したすべてのオプションを解析して適用します。その後、Connection ヘッダーと Connection ヘッダーに記載されているすべてのヘッダーを削除してから、メッセージを次のホップに転送します。さらに、Connectionヘッダーの値としてリストアップされていないが、プロキシされてはならないいくつかのhop-by-hopヘッダーがあります。これらには、Proxy-Authenticate、Proxy-Connection、Transfer-Encoding、および Upgrade が含まれます。Connectionヘッダーの詳細については、付録Cを参照してください。

### 4.3.2 Serial Transaction Delays
- TCPのパフォーマンスの遅延は、接続が単純に管理されている場合（シリアルローディング）、累積することがあります。
- HTTP接続のパフォーマンスを向上させるために、いくつかの最新の技術があります。次のいくつかのセクションでは、そのような技術のうち4つについて説明します。
  - Parallel connections：複数のTCPコネクションで同時にHTTPリクエストを行う 
  - Persistent connections：TCPコネクションを再利用することで、接続/終了時の遅延を解消
  - Pipelined connections：共有されたTCPコネクション上で、同時にHTTPリクエストを実行
  - Multiplexed connections：リクエストとレスポンスのチャンクをインターリーブする（実験的）

HTTP: The Definitive Guide

# Part I: HTTP: The Web's Foundation
- Ch1 ~ Ch4

# Ch1. Overview of HTTP
## 1.1 

## 1.2 Web Clients and Servers
- HTTPサーバーはインターネットのデータを保持し、HTTPクライアントからリクエストされたらそれを渡す。
- 最も一般的なクライアントはWebブラウザ。

## 1.3 Resources
- webサーバーはwebリソースをホストする。webリソースは、webコンテンツの元となるもの。
- 最も単純なwebリソースは、HTMLなどの静的ファイルであるが、静的ファイルでなくても良い。リソースは要求に応じたコンテンツを生成するプログラムでも良い。
- 要約すると、リソースとはあらゆる種類のコンテンツソースのこと。

### 1.3.1 Media Types
- HTTPは、MIMEというデータフォーマットラベルを各オブジェクトに付与して転送する。
- Webサーバは、すべてのHTTPオブジェクトデータにMIMEタイプを付加する。
  - ヘッダー Content-type: image/jpeg のimage/jpegがMIME typeにあたる。
- MIMEタイプは、主なオブジェクトタイプと特定のサブタイプをスラッシュで区切って表現したテキストラベルである。
  - HTMLからなるテキストドキュメントは、text/html となる。

### 1.3.2 URIs
- クライアントは、自分が興味のあるリソースを指摘することができる。サーバーリソース名をURIと呼ぶ。
- URIはインターネットの郵便番号のようなもので、世界中の情報資源を一意に識別し、位置を特定する。
- URIはURLとURNからなる。

### 1.3.3 URLs
- URLは、特定のサーバー上のリソースの特定の場所を示す。
- スキーマ、アドレス、リソースの３箇所に主に分かれる。

### 1.3.4 URNs
- URNは、 リソースが現在どこにあるかに関係なく、特定のコンテンツのユニークな名前を提供する。
- まだ広く採用されていない。対応するインフラが必要なため。

## 1.4 Transactions

### 1.4.1 Methods

### 1.4.2 Status Codes

### 1.4.3 Web pages can consist of multiple objects
- アプリケーションは、タスクを達成するために複数のHTTPトランザクションを発行することがよくある。
- 埋め込まれたリソースは、異なるサーバーに存在することもある。

## 1.5 Messages
- HTTPメッセージはStart line、Header fields、Body からなる。
- ボディには任意のバイナリデータを格納可能

## 1.6 Connection
- TCP
  - エラーのないデータ転送
  - in-order delivery（データは常に送信された順に届く）
  - セグメント化されていないデータストリーム（任意のサイズのデータをいつでも垂れ流すことができる）
- TCP/IPは個々のネットワークやハードウェアの特殊性・欠点を隠す。

## 1.7 Protocol Versions

## 1.8 Architectural components of the web
### 1.8.1 Proxies
- HTTPプロキシサーバーは、Webセキュリティ、アプリケーション統合、パフォーマンス最適化のための重要な構成要素。
- ユーザーの代理として、ユーザーに代わってサーバーにアクセスするアプリケーション。
- プロキシはセキュリティのために使用されることが多く、すべてのウェブトラフィックが流れる信頼できる仲介者として機能する。

### 1.8.2 Caches
- webキャッシュやキャッシングプロキシは、プロキシを通過する主要なドキュメントのコピーを保持する特殊なHTTPプロキシサーバーである。
- クライアントは、離れたwebサーバーからよりも近くのキャッシュを利用することで、はるかに早くドキュメントを取得できる。HTTPは、キャッシュをより効果的にし、キャッシュされたコンテンツの鮮度やプライバシーを管理するための多くの機能を定義している。

### 1.8.3 Gateways
- ゲートウェイとは、他のサーバーを仲介する特別なサーバー。一般にHTTPトラフィックを別のプロトコルに変換する。ゲートウェイはオリジンサーバーのように振る舞うので、クライアントはゲートウェイと通信していると気づかない。

### 1.8.4 Tunnels
- トンネルは、セットアップ後、2つの接続間で生データを盲目的に中継するHTTPアプリケーション。HTTPトンネルは、HTTP以外のデータを1つまたは複数のHTTP接続を介して、データを見ることなく転送するためによく使用される。
- HTTPトンネルは、暗号化されたセキュア・ソケット・レイヤー（SSL）トラフィックをHTTP接続で伝送することで、Webトラフィックのみを許可する企業のファイアウォールを介してSSLトラフィックを許可するという使い方が一般的である。

### 1.8.5 Agents
- ユーザーエージェント（または単にエージェント）は、ユーザーに代わってHTTPリクエストを行うクライアントプログラムである。ブラウザ以外のユーザーエージェントが多くある。
- 例えば、人間が監視することなく、自律的にウェブを歩き回り、HTTPトランザクションを発行したり、コンテンツを取得したりする機械によって自動化されたユーザーエージェントがある。これらの自動化されたエージェントには、「スパイダー」や「ウェブロボット」などのカラフルな名前がついていることが多い。スパイダーは、検索エンジンのデータベースや比較ショッピングロボットの製品カタログなど、ウェブコンテンツの有用なアーカイブを構築するためにウェブを徘徊する。

# Ch2. URLs and Resources
- URLはインターネットリソースの標準的な名前である。

## 2.1 Navigating the Internet's Resources
- URLは、ブラウザが情報を検索する際に必要となるリソースの位置情報です。インターネット上の何十億ものデータリソースを人々やアプリケーションが見つけ、利用し、共有するためのものです。URLは、HTTPやその他のプロトコルに対する人間の通常のアクセスポイントです。人間がブラウザでURLを指定すると、裏ではブラウザが適切なプロトコルメッセージを送信し、人間が求めるリソースを取得します。
- URLの最初の部分はURLスキーマ。webクライアントに「どうやって」リソースにアクセスするかを伝える。
- URLの第二の部分はサーバーの場所。webクライアントに、リソースが「どこに」ホストされているかを伝える。
- URLの第三の部分は、リソースパス。これはサーバー上の「何の」ローカルリソースがリクエストされているかを伝える。
- 世の中にあるすべてのリソースと、そのリソースを得るためのすべての方法に対して、それぞれのリソースに単一の名前を付けることで、誰もがその名前を使ってリソースを見つけることができるようになっているのです。しかし、これは必ずしもそうではありませんでした。

### 2.1.1 The dark days before URLs

## 2.2 URL Syntax
- ほとんどのURLは一般的なURL構文に準拠しており、異なるURLスキームの間でスタイルや構文が大きく重複しています。
- ほとんどのURLは9つのパートに分かれる。

```
<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<qu
ery>#<frag>
```
- これらの構成要素をすべて含むURLはほとんどありません。最も重要な要素はscheme, host, pathです。

### 2.2.1 Schemes: What Protocol to Use
- schemeは与えられたリソースにアクセスする方法についての主要なIDである。schemeはURLを解釈するアプリケーションに、どのプロトコルを使う必要があるかを伝える。

### 2.2.2 hosts and ports
- インターネット上のリソースを見つけるために、アプリケーションはリソースをホストしているマシンを知り、そのマシンのどこに目的のリソースにアクセスできるサーバーがあるのかを知る必要があります。
- hostコンポーネントは、リソースにアクセスできるインターネット上のホストマシンを特定します。名前は、上記のようにホスト名（「www.joes-hardware.com」）として提供することも、IPアドレスとして提供することもできます。
- portコンポーネントは、サーバーがリッスンしているネットワークポートを特定します。基本的にTCPプロトコルを使用するHTTPの場合、デフォルトのポートは80です。

### 2.2.3 usernames and passwords

### 2.2.4 Paths
- URLのpathコンポーネントは、サーバーマシン上のどこにリソースがあるかを指定します。

### 2.2.5 parameters
- アプリケーションがサーバーと正しく対話するために必要な入力パラメータを与えるために、URLにはparamsコンポーネントがあります。このコンポーネントは、URL内の名前と値のペアのリストで、URLの他の部分と（そしてお互いに）「;」文字で区切られています。このコンポーネントは、アプリケーションがリソースにアクセスするために必要な追加情報を提供します。

### 2.2.6 query strings
- データベースサービスなどの一部のリソースでは、要求されているリソースの種類を絞り込むために、質問や問い合わせをすることができます。
- URLのqueryコンポーネントはゲートウェイ・リソースに渡され、URLのpathコンポーネントはゲートウェイ・リソースを特定します。基本的に、ゲートウェイは他のアプリケーションへのアクセスポイントと考えることができます。

### 2.2.7 fragments
- リソースの一部や断片を参照できるように、URLはリソース内の断片を識別するfragコンポーネントをサポートしています。例えば、URLは、HTMLドキュメント内の特定の画像やセクションを指し示すことができます。
- フラグメントは、URLの右端に#文字を付けてぶら下げます。
- クライアントはリソース全体を取得した後、fragmentで指定するリソースの部分を表示する。（ブラウザの場合、そこまでスクロールする。）

## 2.3 URL Shortcuts
- Web クライアントは、いくつかの URL ショートカットを理解して使用しています。相対URLは、リソースの中にリソースを指定する便利な略語です。また、多くのブラウザはURLの「自動展開」をサポートしています。ユーザーがURLの重要な（記憶に残る）部分を入力すると、ブラウザが残りの部分を埋めてくれます。

### 2.3.1 Relative URLs - 相対URL
- URLには、絶対URLと相対URLの2種類があります。
- ここまでは、絶対URLについてのみ説明してきました。絶対URLには、リソースにアクセスするために必要な情報がすべて含まれています。一方、相対URLは不完全なものです。相対URLからリソースへのアクセスに必要なすべての情報を得るためには、ベースと呼ばれる別のURLから相対的に解釈しなければなりません。相対URLは、URLの便利な略記法です。
- 省略可能な相対URL構文により、HTML作成者はURLからスキームやホストなどの構成要素を省略することができます。これらの要素は、それらが含まれるリソースのベースURLから推測できます。他のリソースのURLもこの短縮形で指定することができます。
- また、相対URLは、一連のリソース（HTMLページなど）をポータブルに保つための便利な方法です。相対URLを使用すると、一連のドキュメントを移動しても、新しいベースに対して相対的に解釈されるため、リンクが機能します。これにより、他のサーバにコンテンツをミラーリングすることなどが可能になります。

#### 2.3.1.1 Base URLs
- 変換プロセスの最初のステップは、ベースURLを見つけることです。ベースURLは、相対URLを参照するためのポイントとなります。ベースURLはいくつかの場所から得られます。
  - リソースで明示されている
  - カプセル化されたリソースのベースURL　（HTMLなど）相対URLが埋め込まれているリソースのURLをベースにすることができる。
  - ベースとなるURLがない

#### 2.3.1.2 Resolving relative references
- 相対URLを絶対URLに変換するアルゴリズムがある。もともとRFC1808で規定され、その後RFC2396に組み込まれた。

### 2.3.2 Expandomatic URLs - URLの拡大
- 一部のブラウザでは、URLを送信した後や入力中に、自動的にURLを展開しようとするものがあります。これにより、ユーザーは完全なURLを入力する必要がなく、自動的に展開されるため、ショートカットを得ることができます。
- これらの「expandomatic」機能には、2つの種類があります。
  - ホスト名展開
    - ブラウザは簡単なヒューリスティクスを利用して、ユーザーの助けを借りずに、入力したホスト名を完全なホスト名に展開することができます。
  - 履歴の展開
    - URLを入力する手間を省くためにブラウザが採用しているもうひとつのテクニックが、過去にアクセスしたURLの履歴を保存することです。URLを入力する際に、入力した内容と履歴に残っているURLの接頭辞を照合することで、完成度の高い選択肢を提供することができます。

## 2.4 Shady Characters
- URLには、比較的小さく、普遍的に安全なアルファベットの文字のみを含めることが許可されている。
- URLは完全でなければなりません。URL の設計者は、URL にバイナリデータや、普遍的に安全なアルファベット以外の文字を含めたいと思う場合があることに気付きました。そこで、安全でない文字を安全な文字にエンコードして転送できるように、エスケープメカニズムを追加しました。

### 2.4.1 The URL Character Set
- URL設計者は、完全性の必要性を認識して、エスケープシーケンスを取り入れました。エスケープシーケンスは、任意の文字値やデータをUS-ASCII文字セットの限定されたサブセットを使ってエンコードすることで、移植性と完全性を実現します。

### 2.4.2 Encoding Mechanisms
- 安全な文字セットの表現の限界を回避するために、安全ではないURLの文字を表現するエンコード方式が考案されました。このエンコーディングでは、安全でない文字を、パーセント記号（%）と、その文字のASCIIコードを表す2つの16進数からなる「エスケープ」表記で単純に表します。

### 2.4.3 Character Restrictions - 文字の制限
- いくつかの文字は、URLの中で特別な意味を持つように予約されています。

### 2.4.4 A Bit More

## 2.5 A sea of schemes
- httpスキーマは、usernameとpasswordがないこと以外は一般的なURLフォーマットと同じ。デフォルトポートは80。
- https
- mailto

## 2.6 the future
- URN
- PURL

# Ch3 HTTP Messages
- HTTP がインターネットの運び屋であるとすれば、HTTP メッセージは物を移動するためのパッケージです。この章では以下を学びます。
  - メッセージの流れ
  - HTTP メッセージの 3 つの部分 (開始行、ヘッダー、エンティティボディ)
  - リクエストメッセージとレスポンスメッセージの違い
  - リクエストメッセージがサポートするさまざまな機能（メソッド）について
  - レスポンスメッセージで返されるさまざまなステータスコード
  - 各種 HTTP ヘッダーの役割 

## 3.1 The Flow of Messages
- HTTPメッセージは、HTTPアプリケーション間で送信されるデータのブロックです。これらのデータブロックは、メッセージの内容や意味を説明するテキストのメタ情報で始まり、その後にオプションのデータが続きます。これらのメッセージは、クライアント、サーバー、およびプロキシの間を流れます。メッセージの方向性を示す用語として、「インバウンド」、「アウトバウンド」、「アップストリーム」、「ダウンストリーム」があります。

### 3.1.1 Messages Commute Inbound to the Origin Server
- HTTPでは、トランザクションの方向性を表すために、インバウンドとアウトバウンドという用語を使用しています。メッセージはオリジンサーバーに向かってインバウンドで送信され、その作業が終わるとユーザーエージェントに向かってアウトバウンドで送信されます（図3-1参照）。

### 3.1.2 Messages Flow Downstream
- HTTP メッセージは川のように流れます。すべてのメッセージは、リクエスト・メッセージかレスポンス・メッセージかにかかわらず、下流に向かって流れます（図3-2参照）。メッセージの送信者は受信者の上流に位置します。

## 3.2 The Parts of a Message
- HTTPメッセージは、フォーマットされたシンプルなデータの塊です。図3-3にその例を示していますのでご覧ください。各メッセージには、クライアントからのリクエストまたはサーバからのレスポンスが含まれています。メッセージは3つの部分から構成されています。メッセージを説明するスタートライン、属性を含むヘッダーのブロック、そしてデータを含むオプションのボディです。
- 開始行とヘッダーは単なるASCIIテキストで、行ごとに区切られています。各行の終わりには、キャリッジリターン（ASCII 13）とラインフィード（ASCII 10）の2文字の行末シーケンスがあります。
- この行末記号は "CRLF "と表記されます。HTTPの行末仕様はCRLFですが、堅牢なアプリケーションでは、ラインフィード文字だけを受け入れるべきであることを指摘しておきます。古いHTTPアプリケーションや壊れたHTTPアプリケーションの中には、キャリッジリターンとラインフィードの両方を送るとは限らないものもあります。
- エンティティボディまたはメッセージボディ（または単に「ボディ」）は、単なるオプションのデータチャンクです。開始行やヘッダーとは異なり、ボディにはテキストやバイナリデータを含めることができ、また空にすることもできます。

### 3.2.1 Message Syntax
- すべてのHTTPメッセージは、「リクエストメッセージ」と「レスポンスメッセージ」の2種類に分類されます。リクエストメッセージはウェブサーバに動作を要求し，レスポンスメッセージはリクエストの結果をクライアントに返します。
```
// リクエストメッセージのフォーマット
<method> <request-URL> <version>
<headers>

<entity-body> 

// レスポンスメッセージのフォーマット
<version> <status> <reason-phrase>
<headers>

<entity-body>
```
- method
  - クライアントがサーバーにリソースに対して実行してほしいアクション。GET"、"HEAD"、"POST "などの単一の単語で構成されます。この章の後半では、メソッドについて詳しく説明します。
- request-URL
  - 要求されたリソースを指定する完全なURL、またはURLのパスコンポーネントです。サーバーと直接やりとりする場合は、リソースへの絶対パスであれば、通常、URLのパスコンポーネントは問題ありません（サーバーは自分自身をURLのホスト／ポートとみなすことができます）。
- version
- status-code
- reason-phrase
  - ステータスコードの数値を人間が読めるようにしたもので、行末までのすべてのテキストで構成される。理由のフレーズは、人間が消費するためだけのものです。
- headers
  - 0個以上のヘッダは、名前の後にコロン(:)、任意のホワイトスペース、値、CRLFが続きます。ヘッダーは空行 (CRLF) で終了し、ヘッダーのリストの終わりと、エンティティボディの始まりを示します。HTTP/1.1 などの一部のバージョンの HTTP では、リクエストやレスポンスのメッセージが有効であるために、特定のヘッダが存在することが要求されます。様々な HTTP ヘッダーについては、この章の後半で説明します。
- entity-body
  - エンティティボディは、任意のデータブロックを含みます。すべてのメッセージにエンティティ・ボディが含まれているわけではないので、メッセージが CRLF で終了することもあります。エンティティについては第 15 章で詳しく説明します。
- HTTP ヘッダは、ヘッダがなくても、エンティティボディがなくても、常に空行(CRLF)で終わるべきであることに注意してください。しかし、これまで多くのクライアントやサーバーは、エンティティボディがない場合、最後のCRLFを（誤って）省略していました。

### 3.2.2 Start Lines

#### 3.2.2.1 リクエスト・ライン
- リクエスト・メッセージは、リソースに対して何かをするようサーバに要求します。リクエスト・メッセージのスタート・ライン（リクエスト・ライン）には、サーバが実行すべき操作を記述したメソッドと、そのメソッドを実行するリソースを記述したリクエストURLが含まれます。また、リクエストラインには、クライアントが使用しているHTTPの方言をサーバーに伝えるHTTPバージョンも含まれています。
- これらのフィールドはすべてホワイトスペースで区切られています。

#### 3.2.2.2 レスポンスライン
- レスポンス・メッセージは、操作によって得られたステータス情報や結果のデータをクライアントに返します。レスポンスメッセージの開始行（レスポンスライン）には、レスポンスメッセージが使用しているHTTPバージョン、数値化されたステータスコード、操作のステータスを説明するテキストの理由フレーズが含まれます。これらのフィールドはすべて、ホワイトスペースで区切られています。

#### 3.2.2.2 メソッド
- メソッドは、リクエストの開始行を開始し、サーバーに何をすべきかを伝えます。たとえば、「GET /specials/saw-blade.gif HTTP/1.0」という行では、メソッドはGETです。
- HTTPの仕様では、一般的なリクエストメソッドのセットが定義されています。例えば、GETメソッドはサーバーからドキュメントを取得し、POSTメソッドはサーバーにデータを送信して処理を行い、OPTIONSメソッドはWebサーバーの一般的な機能や特定のリソースに対するWebサーバーの機能を決定します。
- 表3-1では、これらのうち7つのメソッドについて説明しています。なお、リクエストメッセージにボディがあるメソッドと、ボディのないリクエストがあるメソッドがあります。
- すべてのサーバーが表3-1の7つのメソッドをすべて実装しているわけではありません。また、HTTPは拡張性を重視して設計されているため、他のサーバーがこれらに加えて独自のリクエストメソッドを実装している場合もあります。これらの追加メソッドは、HTTPの仕様を拡張するものであるため、拡張メソッドと呼ばれます。

#### 3.2.2.4 ステータスコード
- ステータスコードは、各応答メッセージの開始行に返されます。ステータスには、数字と人間が読める文字の両方が含まれます。数字はプログラムのエラー処理を容易にし、理由は人間が理解しやすいようになっています。
- それぞれのステータスコードは、3桁の数値コードによってクラス分けされています。200から299までのステータスコードは成功を表す。300から399までのコードは、リソースが移動されたことを示す。400から499までのコードは、クライアントがリクエストで何か間違ったことをしたことを意味します。500から599までのコードは、サーバー上で何か問題が発生したことを意味します。
- 現在のバージョンのHTTPでは、各ステータスカテゴリにいくつかのコードしか定義されていません。プロトコルの進化に伴い、より多くのステータスコードがHTTP仕様で公式に定義される予定です。見覚えのないステータスコードを受け取った場合は、誰かが現在のプロトコルの拡張として定義した可能性があります。そのコードは、そのコードが含まれるクラスの一般的なメンバーとして扱われるべきです。

#### 3.2.2.5 reason phrases
- HTTPの仕様では、理由を示す語句がどのようなものであるべきか、明確なルールは定められていません。

#### 3.2.2.6 Version numbers
- バージョン番号は、HTTP アプリケーションが相互にどのバージョンのプロトコルに準拠しているかを伝える手段となります。バージョン番号は、HTTP を使用するアプリケーションに、互いの能力やメッセージの形式についての手がかりを提供することを目的としています。HTTP バージョン 1.1 のアプリケーションと通信する HTTP バージョン 1.2 のアプリケーションは、1.2 の新機能を使用すべきではないことを知るべきです。なぜなら、それらの機能は、古いバージョンのプロトコルを使用するアプリケーションによって実装されていない可能性が高いからです。

### 3.2.3 Headers
- HTTP ヘッダーフィールドは、リクエストとレスポンスのメッセージに追加の情報を与えます。これらは基本的に、名前と値のペアのリストです。

#### 3.2.3.1 Header classifications
- 各HTTPヘッダーは、名前の後にコロン（：）、任意のホワイトスペース、フィールド値、CRLFというシンプルな構文になっています。

### 3.2.4 Entity Bodies
- HTTPメッセージの第3の部分は、オプションのエンティティボディです。エンティティボディは、HTTPメッセージのペイロードです。エンティティボディは、HTTPメッセージのペイロードであり、HTTPが輸送するために設計されたものです。
- HTTPメッセージは、画像、ビデオ、HTML文書、ソフトウェアアプリケーション、クレジットカード、電子メールなど、さまざまな種類のデジタルデータを伝送することができます。

### 3.2.5 Version 0.9 Messages

## 3.3 Methods
- ここでは、表3-1に示した基本的なHTTPメソッドのいくつかについて詳しく説明します。ただし、すべてのサーバがすべてのメソッドを実装しているわけではありません。HTTP バージョン 1.1 に準拠するためには、サーバーはそのリソースに対して GET と HEAD メソッドのみを実装する必要があります。
- サーバーがこれらのメソッドをすべて実装していたとしても、そのメソッドはほとんどの場合、用途が制限されています。例えば、DELETEやPUT（後述）をサポートするサーバは、誰でもリソースを削除したり保存したりできることを望んでいません。このような制限は、一般的にはサーバーの設定で設定されるため、サイトやサーバーによって異なります。

### 3.3.1 Safe Methods
- HTTP では、安全なメソッドと呼ばれる一連のメソッドが定義されています。GET メソッドと HEAD メソッドは安全であると言われています。つまり、GET メソッドまたは HEAD メソッドを使用した HTTP リクエストの結果、何も起こらないことを意味します。何も起こらないというのは、HTTPリクエストの結果としてサーバー上で何も起こらないということです。
- 例えば、あなたがJoe's Hardwareでオンラインショッピングをしていて、「購入」ボタンをクリックしたとします。このボタンをクリックすると、クレジットカード情報を含むPOSTリクエスト(後述)が送信され、お客様に代わってサーバー上でアクションが実行されます。この場合のアクションとは、お客様のクレジットカードに購入代金が請求されることです。
- 安全なメソッドを使用しても、アクションが実行されないという保証はありません（実際には、ウェブ開発者次第ですが...）。安全なメソッドとは、何らかのアクションが実行される可能性のある安全でないメソッドが使用されている場合に、HTTPアプリケーションの開発者がユーザーに知らせるためのものです。Joe's Hardwareの例では、Webブラウザが警告メッセージを表示し、安全でないメソッドでリクエストを行っていること、その結果、サーバ上で何かが起こる可能性があることを知らせます（例：クレジットカードに課金される）。

### 3.3.2 GET
- GETは最も一般的なメソッドです。通常、サーバーにリソースの送信を依頼する際に使用されます。HTTP/1.1では、サーバーがこのメソッドを実装する必要があります。

### 3.3.3 HEAD
- ヘッダーだけを返すメソッド。下記用途で使う。
  - リソースを取得せずに、そのリソースについて調べる（例えば、タイプを決定する）。
  - レスポンスのステータスコードを見て、オブジェクトが存在するかどうかを確認する。
  - ヘッダを見て、リソースが変更されたかどうかを確認する。

- サーバの開発者は、返されるヘッダが、GETリクエストが返すヘッダと同じであることを確認する必要があります。HTTP/1.1 に準拠するためには、HEAD メソッドも必要です。

### 3.3.4 PUT
- PUTメソッドは、GETがサーバーからドキュメントを読み取るのとは逆に、サーバーにドキュメントを書き込むものである。パブリッシングシステムの中には、PUTを使ってWebページを作成し、Webサーバーに直接インストールできるものもある（図3-9参照）。
- PUTメソッドのセマンティクスは、サーバーがリクエストのボディを受け取り、それを使ってリクエストされたURLで名付けられた新しいドキュメントを作成するか、そのURLがすでに存在する場合は、ボディを使ってそれを置き換えるというものです。PUTはコンテンツの変更を可能にするため、多くのウェブサーバーではPUTを実行する前にパスワードによるログインを要求しています。パスワード認証については、第12章で詳しく説明しています。

### 3.3.5 POST
- OSTメソッドは、入力データをサーバーに送信するために設計されました *。 実際には、HTMLフォームをサポートするためによく使用されます。入力されたフォームからのデータは通常、サーバーに送信され、サーバーはそれを必要な場所（例えば、サーバー・ゲートウェイ・プログラムに送信し、それを処理します）に転送します。
- * POSTは、データをサーバーに送信するために使用されます。PUTは、サーバー上のリソース（ファイルなど）にデータを預けるために使用されます。

### 3.3.6 TRACE
- クライアントがリクエストを行う際、そのリクエストは、ファイアウォール、プロキシ、ゲートウェイ、その他のアプリケーションを経由しなければならない場合があります。これらのそれぞれが、オリジナルのHTTPリクエストを変更する機会を持っています。TRACEメソッドでは、クライアントは、リクエストが最終的にサーバに到達したときの様子を確認することができます。
- TRACEリクエストは、送信先のサーバで「ループバック」診断を開始します。最終目的地のサーバは、受け取ったバージンリクエストメッセージを本文に含んだTRACEレスポンスを返信します。クライアントは、元のメッセージが、HTTPアプリケーションのリクエスト／レスポンスチェーンに沿って、どのように、あるいはどのように変更されたかを確認することができます（図3-11参照）。
- TRACEメソッドは、主に診断のために使用されます。つまり、リクエストが意図したとおりにリクエスト／レスポンスチェーンを通過しているかどうかを検証します。また、プロキシや他のアプリケーションがリクエストに与える影響を確認するのにも適したツールです。TRACEは診断に適していますが、介在するアプリケーションが異なるタイプのリクエスト（異なるメソッド-GET、HEAD、POSTなど）を同じように扱うことを前提としているという欠点があります。多くの HTTP アプリケーションは、メソッドに応じて異なる処理を行います。一般的に、TRACEリクエストをどのように処理するかについては、介在するアプリケーションが判断します。
- TRACEリクエストでは、エンティティボディを送信することはできません。TRACEレスポンスのエンティティボディには、応答サーバが受け取ったリクエストがそのまま含まれています。

### 3.3.7 OPTIONS
- OPTIONSメソッドは、ウェブサーバがサポートしている様々な機能について、サーバに問い合わせるものです。一般的に、あるいは特定のリソースに対してどのようなメソッドをサポートしているかをサーバーに尋ねることができます。(サーバーによっては、特定の種類のオブジェクトに対してのみ特定の操作をサポートしている場合もあります)。
- これにより、クライアントアプリケーションは、様々なリソースに実際にアクセスすることなく、どのようにアクセスするのが最適かを判断することができます。

### 3.3.8 DELETE
- DELETEメソッドは、イメージ通り、リクエストURLで指定されたリソースの削除をサーバーに依頼するものです。しかし、クライアントアプリケーションは、その削除が実行されることを保証されていません。これは、HTTPの仕様では、サーバーがクライアントに断りなくリクエストを上書きすることができるためです。

### 3.3.9 Extension Methods
- HTTPは、新しい機能が旧来のソフトウェアの障害とならないように、フィールド拡張可能な設計となっています。
- 注意すべき点は、すべての拡張メソッドが正式な仕様で定義されているわけではないということです。拡張メソッドを定義しても、ほとんどの HTTP アプリケーションでは理解できない可能性があります。同様に、他のアプリケーションが使用している、理解できない拡張メソッドにHTTPアプリケーションが遭遇する可能性もあります。
- このような場合には、拡張メソッドに対して寛容であることが最善です。プロキシは、エンドツーエンドの動作を壊すことなく、未知のメソッドを持つメッセージを下流のサーバに中継することが可能であれば、それを試みるべきです。そうでない場合は、501 Not Implementedのステータスコードで応答すべきです。

達人に学ぶDB設計徹底指南書

# 第1章 データベースを制する者はシステムを制す
## 1-1 システムとデータベース
- データベースを使わないシステムは、この世に存在しない。
- 本書でのデータの定義は、「ある形式（フォーマット）に揃えられた事実」である。形式は二次元表など。データベースは、こうした一定の形式に従ったデータの蓄積である。
- 一方、情報という概念は、データと文脈を合成して生まれるものである。
- システムは、ユーザーが登録したデータを引き出して情報を作り出すという一連のサイクルの中に位置付けることもできる。

## 1-2 データベースあれこれ
- 現在商用利用されているデータベースには何種類かあるが、その分類はデータを保持するフォーマットを基準にして行われている。
  - リレーショナルデータベース：　最も広く利用されている。
  - オブジェクト指向データベース
  - XMLデータベース
  - キー・バリュー型ストア（Key-Value Store: KVS）
  - 階層型データベース
- モデルが異なれば設計技法も異なる。ただし、設計技法の達成したい目的（データの整合性の保持や冗長性排除など）はモデルが変わっても同じである。
- RDBでもDBMSは複数あるが、DBMSが異なっても、（基本的には）設計の方法は影響を受けない。

## 1-3 システム開発の工程と設計
- 開発の工程は以下に分解・分類できる。
  1. 要件定義：　要件（システムが満たすべき機能など）を決める工程
  2. 設計：　要件を満たすために必要なシステムを作るための設計を行う工程
  3. 開発（実装）：　設計書に従ってシステムを実際に作る工程
  4. テスト：　実装によって組み上がったシステムが、実用に耐える品質であるかを試験する工程
- 本書では設計工程に焦点を当てていく。
- システム開発の進め方（開発モデル）には大きく分けて二つの方法がある。
  - ウォーターフォールモデル
  - プロトタイピングモデル

## 1-4 設計工程とデータベース
- 本書では、データベースに保持するデータの設計（データベース設計と呼ぶ）について述べる。これが重要な理由は二つ。
  1. システムにおいて大半のデータ（少なくとも永続的に使用されるデータ）はデータベース内に保持される。そのため、普通、データ設計とはデータベース設計とほぼ同義である。
  2. データ設計がシステムの品質を最も大きく左右する。ソフトウェアというのは、言ってみれば「データの流通機構」であって、どのようなプログラムが必要になるかは、どのようなデータをどういうフォーマットで設計するかに左右される。

### DOAとPOA
- このうち特に重要なのが理由1である。近年のソフトウェア開発では、データ中心アプローチ（Data Oriented Approach:DOA）という考え方が主流となっているためである。かつて主流の考えであったプロセス中心アプローチ（POA）は現在では普通採用されることはない。
- POAはプロセス単位でデータ設計を行うことになるため、複数のプロセスで同じデータを別個に持つという冗長性が生じるなどの不都合が多い。
- DOAはPOAの欠点を克服するために登場した。その着眼のポイントは、データがあまり変化しない（永続的）という点である。データの意味や形式が先に決まっていれば、複数のプログラムで共用することも容易で、業務要件の仕様変更にも柔軟に対応できる。
- こうした理由から、システム開発においては、プログラム設計に先立ってまずデータ設計が優先されるのである。
- よって、データ設計（≒データベース設計）はシステムの品質を決める最も重要な要因と言っても過言ではない。

### 3層スキーマ
- DB設計で踏むべき具体的な段階について整理する上で重要となる概念が「スキーマ」である。DB設計においては、データベースのデータ構造やフォーマットという意味で使う。DB設計のステップは、このスキーマのレベルと密接に結びついている。スキーマは、一般的に三つのレベルに分けられる。
  1. 外部スキーマ
  2. 概念スキーマ
  3. 内部スキーマ
- この三つのスキーマに基づいてシステムを記述したモデルを、「3層スキーマモデル」と呼ぶ。

1. 外部スキーマ
  - ユーザーから見たデータベースの姿を定義するスキーマ。DBのオブジェクトとしては、ビューが相当する。
2. 概念スキーマ
  - 開発者から見たデータベースの姿を定義するスキーマ。
  - 必然的に、DB設計において重要な位置を占めることになる。
  - 概念スキーマの設計を「論理設計」とも呼ぶ。
3. 内部スキーマ
  - DBMSから見たデータベースを定義するスキーマ。
  - 論理設計との対比で「物理設計」と呼ぶ。

- 概念スキーマがいらないように見えるが、これは外部スキーマと内部スキーマの間にあることで、両者の変更が互いに影響しあわないようにするための緩衝材の役割を果たす。このようなスキーマの独立性のことを、**データ独立性**と呼ぶ。外部スキーマからの独立性を**論理的データ独立性**、内部スキーマからの独立性を**物理的データ独立性**と呼ぶ。概念スキーマはデータ独立性を保証するためにある。
- 概念の有用性がわからなかったら、「それがなかったらどうなるか」を考えてみるのが良い。

演習1-1

演習1-2
問題1：
- 問題となるSQLの特定、当該SQLのチューニング
問題2：
- 顧客との要件の再調整、必要な情報の出力処理を実装、UIの修正

# 第2章 論理設計と物理設計
## 2-1 概念スキーマと論理設計
- 概念スキーマを定義する設計を、論理設計と呼ぶ。
- システムの世界での論理とは、「物理層の制約（実装レベルの条件）にとらわれない」という意味。
- 原則として、論理設計は物理設計に先立つ。
- 論理設計は、現実世界に存在する数多くのデータから、リレーショナルデータベースにおいて、何を、どのようなフォーマットで保存するかを決めること。具体的には下記のタスクが含まれる。
  1. エンティティの抽出
  2. エンティティの定義
  3. 正規化
  4. ER図の作成

### エンティティの抽出
- エンティティは「実体」と訳すが、物理的実体が伴う必要はない。（税、注文履歴などでも良い）
- システムにどのようなエンティティ（=データ）が必要かを抽出することは一部が要件定義と重なるため、この工程はある程度顧客やシステム利用者と要件を詰めていく中で実施することになる。

### エンティティの定義
- エンティティは、データを「属性」（二次元表の列と同義）という形で保持する。エンティティの定義は属性を決めること。
- ここで特に重要なのは「キー」という列を定義すること。キーとは、ある特定の列の値を決定するための列(複数列でも良い)のこと。

### 正規化
- 正規化は、エンティティ（テーブル）について、システムでの利用がスムーズに行えるよう整理する作業
- RDBの論理設計においては、この正規化が最も重要な土台をなす。

### ER図の作成
- 正規化を行うとエンティティの数が増えてエンティティ同士の関係が把握しづらくなるので、関係を表現する図を作成することで理解しやすくする必要がある。

## 内部スキーマと物理設計
- 物理設計の流れは大きく分類すると以下の5つがある。
  1. テーブル定義
  2. インデックス定義
  3. ハードウェアのサイジング
  4. ストレージの冗長構成決定
  5. ファイルの物理配置決定

### インデックス定義
- インデックスは機能ではなくパフォーマンスに重要な役割を果たす。

### ハードウェアのサイジング
- サイジングはキャパシティ（データサイズに対する記憶装置の選定）とパフォーマンス（サーバーのCPUやメモリ）の2つの観点から行う。
- データベースの性能問題の８割はディスクI／Oによって起きる。
- DBにおいては、データの整合性とパフォーマンスの間に強いトレードオフがある。

#### パフォーマンスのサイジング
- システム開発での性能要件は二つの指標を使って定義する。
  - 処理時間　どれだけ早く処理できるか
  - スループット　どれだけたくさん処理できるか。1秒当たり仕事量TPSを指標に使う。

- 精度の高いサイジングは難しい。そのため、必ず実施時には安全率をかけ、スケーラビリティの高い構成を組む。

### ストレージの冗長構成
- ストレージが高い耐障害性を持つようにするための技術としてRAIDがある。
- RAIDの基本的な考えは、複数のディスクに同じデータを書き込んで冗長化し、一本が壊れても残りのディスクでデータを保全できるというもの。（信頼性向上）
- それだけでなく、RAIDは複数のディスクにデータを分散して保持することで、性能的にボトルネックとなるディスクI/Oを分散し、パフォーマンス向上を図ることができる。（性能向上）
- DBの物理設計では、RAIDについて以下を考える必要がある。
  - 当該データには、信頼性が求められるのか、それとも性能が求められるのか（最も重要な問い）
  - どのようなレベルのRAIDを採用するか
  - 何本のディスクでRAIDを構成するか
- RAIDの主な種類
  - RAID0
  - RAID1
  - RAID5
  - RAID10
- DBサーバーのストレージにおけるRAIDとして、少なくともRAID5で構成する。お金に余裕があればRAID10。RAID0は論外。

### ファイルの物理配置
- DBのファイルをどのディスク（またはRAIDグループ）に配置するかを検討する工程。
- DBに格納されるファイルは用途別に5種類に大別できる。開発者がその存在を意識するのはデータファイルとインデックスファイルのみ。
  - データファイル、インデックスファイル、システムファイル、一時ファイル、ログファイル
- 5種類のファイルの物理配置を考える際、最も重要なことはサイズと性能である。性能について考慮すると、5種類をそれぞれ別のディスクに分けるということになるが、それだけ潤沢にディスクを用意できることは滅多にないため、I/O量が比較的低いログファイルとシステムファイルを同じディスクにまとめるなどコストを下げていく。

## 2-3 バックアップ設計
- データベースの物理設計と隣接する領域に、データのバックアップおよびリストアの設計がある。
- この設計には二通りの方針がある。
  - 一つは、極力データを失わないような設計にすること。（例：RAID設計）
  - 二つ目は、障害によってデータが失われたときに、復旧できるようにしておくこと。これが本章で解説するバックアップとリカバリである。

### バックアップの基本分類
- バックアップは基本的にファイルのコピーで行う。
- 主要な三つのバックアップ方式は以下の通り。
  - フルバックアップ（完全バックアップ）
  - 差分バックアップ
  - 増分バックアップ

#### フルバックアップ
- ある時点でそのシステムで保持されているすべてのデータをバックアップする方式
- 下記の欠点がある。
  - 1. バックアップの時間が（他の方式に比べて）長い
  - 2. ハードウェアリソースへの負荷が（他の方式に比べて）高い
  - 3. サービス停止が必要　バックアップ中にデータが変更されるとデータ整合性が取れないため

#### 差分バックアップ
- ある時点で取得したフルバックアップに対する変更分だけのバックアップを適宜取得する方法。
- 差分管理はログファイル（トランザクションログ）をバックアップすることで実現する。トランザクションログにはDB内のデータに対する変更操作の履歴が残っているため、これをバックアップしておけばDBに対する変更操作を再現することが可能。
- 運用イメージとしては、例えば、月曜だけフルバックアップをとり、火曜〜土曜は月曜からの変更分のみをバックアップする。日曜に障害が起きたときは、月曜に取得したフルバックアップ＋土曜に取得した差分バックアップが必要。
- 利点：バックアップデータ量が減ること
- 欠点：リカバリの手順が増えて時間も長くなること

#### 増分バックアップ
- 差分バックアップにあった無駄（最新のログファイルが古いログファイルの内容も内包すること）を省いた方式
- 例えば、月曜だけフルバックアップを取得し、火曜〜土曜はその日の変更分のみバックアップする。
- 利点：バックアップデータ量が最小になること。バックアップに要する時間も最短となり、コスト的に最良の方式。
- 欠点：リカバリ手順が最も複雑になること。リカバリ時間も長い上、復旧に必要なファイルが増えるため完全にデータを復旧できる可能性が最も低くなる。

- バックアップコスト（バックアップにかかる時間）が低いほどリカバリコスト（リカバリにかかる時間）は高いというトレードオフがある。

### どのバックアップ方式を採用するか
- バックアップ設計において考慮すべきポイントは以下の4点。
  - 1. いつ時点の状態に復旧させる必要があるか。そもそも復旧の必要があるか
  - 2. バックアップに使用できる時間(バックアップウィンドウ)
  - 3. リカバリに使用できる時間(リカバリウィンドウ)
  - 4. 何世代までのデータを残す必要があるか(保管用の媒体サイズに影響)
- 上記鑑みて、現実的に選択されることが多いバックアップ方式は、「フルバックアップ＋差分バックアップ」または「フルバックアップ＋増分バックアップ」

## 2-4 リカバリ設計
- バックアップ設計とリカバリ設計はセットで実施することが一般的である。

### リカバリとリストア
- バックアップファイルをDBに戻しただけでは、バックアップ後から障害発生までの変更分が反映されず、リカバリは完結しない。
- ここで障害復旧の手順を厳密に二つに分ける必要がある。「バックアップファイルを戻す」作業を「リストア」、そのファイルに対してトランザクションログを適用して変更分を反映する作業を「リカバリ」と呼ぶ。

### リストアとロールフォワード
- DBMS内部に残っているバックアップされていないトランザクションログまで適用することで、初めてデータは障害直前の状態に復旧する。
- まとめると下記手順となる。
  1. フルバックアップのファイルをデータベースに戻す。　->リストア
  2. 差分（または増分）バックアップしていたトランザクションログを適用する。　-> リカバリ
  3. データベースサーバーに残っているトランザクションログを適用する。　-> ロールフォワード

# 第3章 論理設計と正規化

## 3-1 テーブルとは何か？
- テーブルとは、共通点を持ったレコードの集合である。
- 言い方を変えると、「テーブルは同じ種類の物の集合である」とも言えるため、テーブル名は英語ならば複数形／複数名詞で書ける。そうでなければそのテーブルにはどこか間違いがある。

## 3-2 テーブルの構成要素
### 行と列
- 横と縦のデータの組を「行」と「列」（あるいは「レコード」と「カラム」）と呼ぶ。

### キー
- キーは「あるレコード（1行とは限らない）を特定するための列の組み合わせ」
- キーの中で重要なものは以下の二つ。
  - 主キー
  - 外部キー

#### 主キー
- 主キーは、テーブルにおいて必ず一つ存在しなければならず、かつ一つしか存在しない。
- 主キーとは、その値を指定すれば、必ず1行のレコードを特定できるような列の組み合わせのこと。
  - 1行に特定することを「一意に識別する」という。
- 主キーがテーブルに必ず存在しなければならないというルールは、「テーブルには重複行は存在できない」ということを導く。
- 場合によっては複数列を組み合わせなければ主キーが作れないこともある。こうしたキーを**複合キー**と呼ぶ。
- 後補キー、スーパーキーというものもある。

#### 外部キー
- 外部キーは、二つのテーブルの間の列同士で設定するもの。
- 外部キーの役割は、その列を含むテーブルに対して一種の制約を課すことことである。この制約を「**参照整合性制約**」と呼ぶ。
- 外部キーは人間の親子関係と同じ。
  - 「社員」テーブルの外部キーとして部署列があり、部署列を持つ「部署」テーブルがあったとする。この場合、親が「部署」テーブルで、子が「社員」テーブルである。
  - 部署テーブルの部署列にない部署を持つ社員レコードを登録することはできない。（親が存在しないと子は存在できない。）
  - 部署テーブルには自由に新たな部署を登録できる。（子のいない親は存在しうる。）
- 外部キーが設定されている場合、データの削除は子から順に操作するのが良い。
  - 親テーブルのレコードを削除するときに、対応する子レコードも合わせて削除するか、それとも削除SQL文をエラーにするか選択できる。合わせて削除する動作を「カスケード」と呼ぶ。

- キー（主キー、外部キー）となる列には、コードやIDなど表記体系の定まった固定長文字列を用いるのが鉄則。
  - 可変長文字列をキーに使うのは、表記揺れがあるため危険

### 制約
- テーブルにつけられる制約の代表的なものは以下の三つ。
  - NOT NULL制約
  - 一意制約
  - CHECK制約

#### NOT NULL制約
- **テーブル定義において、列には可能な限りNOT NULL制約を付加する。**
  - NULLはSQLで扱う上でいろいろな問題を引き起こすため。
  - 主キーとなる列にはDBMS側で暗黙的にNOT NULL制約が付加される。

#### 一意制約
- 一意制約は、ある列の組について一意性を求める制約である。

#### CHECK制約
- ある列の取りうる値の範囲を制限するための制約。

### テーブルと列の名前
#### 名前に使える文字集合
  (a) 半角のアルファベット
  (b) 半角の数字
  (c) アンダーバー
- **テーブルや列の名前に日本語は使ってはいけない。**

#### 最初はアルファベット

#### 名前は重複してはならない
- テーブルの場合、DBMSが設定する範囲内においては、同じ名前を使うことができない。この範囲をドメインと呼ぶ。DBMSによってはスキーマと呼ぶ。

## 3-3 正規化とは何か？

### 正規形の定義
- 正規形とは、一言で言うと、データベースで保持するデータの冗長性を排除し、一貫性と効率性を保持するためのデータ形式
- 冗長性や非一貫性の問題を解決するために考案された方法論が、正規化である。
- 第１〜第５正規形まである。通常の業務では第３正規形まで達成したら、その時点で以降の正規形の条件も満たしていることがほとんど。そのため、普通は第３正規形まで理解すれば十分。

## 3-4 第1正規形
- 便宜的にテーブルの行と列が交差する特定の一マスのことを「セル」と呼んだとしたときに、第1正規形の定義は「**一つのセルの中には一つの値しか含まない**」というもの。一つのセルに一つだけの値が含まれている時、この値のことを「**スカラ値**」と呼ぶ。
- 一つのセルに二つ以上の要素を入れたい場合がある。このような時は、行持ち（要素の数だけ行を増やす方法）を採用すると良い。ただ、この時、複数の列を主キーに指定せざるをえないケースが出てくるが、主キーは一部であってもNULLを含んではならないというルールのために、矛盾が生じる場合がある。そのような時は、テーブルを分割する。
- 一つのセルに複数の値を入れることができない理由は、セルに複数の値を許せば、主キーが各列の値を一意に決定できず、主キーの定義に反することになるためである。
- このことは、**関数従属性**（入力Xに対して出力Yが一つに決まることを「YはXに従属する」と表現する）という概念と結びついている。実は、正規化とはテーブルのすべての列が関数従属性を満たすように整理していくことなのである。

## 3-5 第2正規形〜部分関数従属
- 主キーの一部の列に対して従属する列がある場合、この関係を**部分関数従属**と呼ぶ。これに対し、主キーを構成するすべての列に従属性がある場合を、**完全関数従属**と呼ぶ。
- 第2正規形とは、テーブル内で部分関数従属を解消し、完全関数従属のみのテーブルを作ることである。
- 部分関数従属を解消する手段は、部分関数従属の関係にあるキー列と従属列を、独立した別テーブルに分割することである。
- 第2正規形にしない場合、部分関数従属の従属列だけ登録することが実質的にできないことや、部分関数従属の従属列に間違ったデータを登録できてしまうなどの問題がある。
- 第2正規化は、異なるレベルの実体（エンティティ）を、きちんとテーブルとしても分離してやる作業とも言える。
- 第2正規化は**可逆的**な操作であり、元に戻せる。これができるのは、正規化が情報を完全に保存したままテーブルを分割する操作（**無損失分解**）だからである。
- 正規化の逆操作は常に結合である。（結合SQLで行うことができる。）

## 3-6 第3正規形〜推移的関数従属
- テーブル内部に存在する段階的な従属関係のことを、**推移的関数従属**と呼ぶ。
  - 例：{会社コード、社員ID} -> {部署コード} -> {部署名}
- 第3正規形は、推移的関数従属を解消した状態。
- 第3正規化も、テーブルを分割することで行う。
- 第3正規化も、第2正規化と同様に、レベルの異なる実体を異なるテーブルとして切り分ける作業である。また、第3正規化も無損失分解である。

## 3-10 正規化についてのまとめ
### 正規化の三つのポイント
1. 正規化とは更新時の不都合／不整合を排除するために行う
2. 正規化は従属性を見抜くことで可能になる
  - 従属性を判断するには、各列が業務上どのような意味と関係を持っているかを調べなければならない。
3. 正規形はいつでも非正規形に戻せる
  - このことが示すのは、高次の正規形は低次の正規形を含んでいるということである。

### 正規化は常にするべきか？
- 第3正規形までは、原則として行う。
- 関連エンティティが存在する場合は関連とエンティティが1対1に対応するよう注意する。

- 正規化の利点
  1. データの冗長性が排除され、更新時の不整合を防止できる。
  2. テーブルの持つ意味が明確になり、開発者が理解しやすい。
- 正規化の欠点
  - テーブルの数が増えるため、SQL文で結合を多用することになり、パフォーマンスが悪化する。

## 演習
### 演習3-1
第1正規形：{支社コード、支店コード、商品コード}が主キーだが、{支社コード} -> {支社名}、{支店コード} -> {支社名}、{商品コード} -> {商品名}という部分関数従属があるため。

### 演習3-2
部分関数従属：{支社コード} -> {支社名}、{支店コード} -> {支社名}、{商品コード} -> {商品名}
推移的関数従属：{商品分類コード} -> {分類名}

### 演習3-3
省略

# 第4章 ER図〜複数のテーブルの関係を表現する

## 4-1 テーブルが多すぎる！
- 多数のテーブルを管理するために、それぞれのテーブルがどういう意味を持っていて、テーブル同士が互いにどういう関係にあるのか、ということを明示するために作る図を**ER図**と呼ぶ。
- ER図の代表的なフォーマットとして、IE表記法とIDEFIX（アイデフワンエックスと読む）の2種類がある。

## 4-2 テーブル同士の関連を見抜く
- ER図を描くとき、最初に着目するポイントは、あるテーブルの主キーが、他のテーブルに列として含まれているかどうかという点である。なぜなら、もしその場合、二つのテーブルの間には意味的な関連があることになるからである。
- 同じ意味の列を持っているテーブル同士の間では、一般に次の３パターンがあり得る。
  1. １対１
  2. １対多
  3. 多対多
- 少なくとも正規化の過程で１対１のテーブルが作られることはない。１対多が最もよくある関連のタイプであり、基本的に正規化によって生まれる関連はこのカテゴリに属する。多対多は、RDBの約束として作ってはならないことになっている。

## 4-3 ER図の描き方
- エンティティは、四角の中を横線で二つのスペースに区切り、上のスペースは主キー属性、下のスペースは非キー属性を記述する。また、他のテーブルの主キーを参照する外部キーについては、属性名のとなりに略称の「FK」を記述する。

### IE表記法の場合
- ER図は関連するエンティティ間に直線を引き、相手のエンティティと対応するレコード数（**カーディナリティ**という）が1である場合、自身のエンティティ付近の直線に対して直交する短い線を引く。カーディナリティが0の場合は○印を、カーディナリティが複数の場合は/|\（鳥の足）をつける。（この二つを合わせると「0以上の複数」という意味になる）

### IDEF1Xの場合
- 角の尖った四角で表記したエンティティは**独立エンティティ**であり、他のテーブルのデータに依存することなく、データを保持することができる。一方、角の丸い四角で表記したエンティティは**従属エンティティ**であることを意味する。これは、他のテーブルにデータが存在しなければデータを保持できないエンティティであり、特徴として主キーに他テーブルを参照する外部キーを含む。
- エンティティ間の関連は、カーディナリティの「多」は黒丸（●）で表現する。
  - 0以上：●
  - 1以上：●P
  - 0または1：●Z
  - n(特定の定数)：●n
- 1対多の「1」側のエンティティには黒丸を使わない。
- 多のエンティティ側において、外部キーがNULLでありうる場合、相手のエンティティ側に◇をつける。
- 会社と社員のように、社員が会社に必ず属さなければならない場合、これを**依存リレーションシップ**と呼んで、実線で表す。一方、社員と部署のように、必ずしも社員が部署に所属していなくても良い場合、（社員テーブルの部署列がNULLになりうる場合）これを**非依存リレーションシップ**と呼んで点線で表す。

## 4-4 「多対多」と関連実体
- 多対多の関連を持ったエンティティができることは珍しいことではない。
- 多対多がRDBの世界において問題となる理由は、両者のエンティティが共通のキーとなる列を保持しないため、両エンティティを結合した情報を得ることができないこと。
- この問題を解決するための方法が、**関連実体**である。これは、多対多の関係となっていた二つのエンティティ間に作られる第3のエンティティである。
  - 例として、「学生」と「講義」のエンティティがあった場合、「受講」というエンティティを作り、受講エンティティは学生と講義の主キーを組み合わせたキーを主キーにもつ。
  - こうすると、学生と受講の間の関連は「1対多」、講義と受講の間の関連も「1対多」となり、ER図から「多対多」の関係が消去される。

# 第5章 論理設計とパフォーマンス〜正規化の欠点と非正規化

## 5-1 正規化の功罪
- 検索において、非正規化テーブルならば、SQLで結合を使わずに済むため、パフォーマンスが良い。
- 更新時は、正規化したテーブルの方が処理コストが低い。
- 正規化（によるデータ整合性）と検索SQLのパフォーマンスはトレードオフの関係にある。
- 著者の立場は、**原則として非正規化は許さない**というもので、非正規化は他の手段によってパフォーマンス向上が図れないかを検討した上での最後の手段である、というもの。

## 5-2 非正規化とパフォーマンス
- サマリデータを冗長に保持すると正規形に違反するが、正規化した場合より検索を高速化できる。
  - 正規化した場合、テーブルを結合する必要があり、そのコストが高い桃になる。
  - 例えば受注テーブルに商品数という列を追加すると、商品数が簡単に取れるようになる。
- 選択条件を冗長に保持すると（第2）正規形に違反するが、検索を高速化できる。
  - 例えば受注明細テーブルに受注日という列を追加する。

## 5-3 冗長性とパフォーマンスのトレードオフ
- 非正規化が更新不整合のリスクを増やすことが解説したが、それ以外のリスクを整理する。大きく三つに分類できる。
  1. 非正規化は、検索のパフォーマンスは向上させるが更新のパフォーマンスを低下させる。
    - サマリデータを計算する処理が必要であったり、またサマリデータはしばらくの期間は変更が可能な場合があるため、そうすると定期的に更新処理が必要になる。
  2. データのリアルタイム性（鮮度）を低下させる。
    - 1.の問題から、データのリアルタイム性に問題が発生することが分かる。
  3. 後続の工程で設計変更すると、手戻りが大きい。
- 論理設計をして、後でテーブル構成を変更しようとしても、大規模な改修が必要という理由で受け入れられなかったりする。論理設計をする際は、それがシステムの品質を左右するという気概を持って臨む必要がある。
- また、**論理設計を行う上では、パフォーマンスの問題を考える必要が出てくるので、物理設計についての知識が必要になってくる。**

# 第6章 データベースとパフォーマンス

## 6-1 データベースのパフォーマンスを決める要因
- DBのパフォーマンス設計という観点において重要なポイントをもう二つ紹介する。それが、インデックスと統計情報である。

### インデックス
- インデックスは`(x, α)`という形式の配列と言える。ここで、xはキー値、αはそれに結びつく情報（実データか、あるいはそれへのポインタ）である。

### 統計情報
- 統計情報が重要な理由は、これがSQLのアクセスパスを決める最大の要因だからである。
  - 最近のDBMSはコストベースといって、データアクセスの経路選択を一任するアーキテクチャが主流になっている。その際の経路選択において統計情報が重要となってくる。

## 6-2 インデックス設計
- インデックスがSQLのパフォーマンス改善のためのポピュラーな手段である理由を整理すると下記のようになる。
  1. アプリケーションのコードに影響を与えない（アプリケーション透過的）。
    - 「存在を意識しなくて良い」という性質を「透過性」と呼ぶ。インデックスはDB側に作成すれば良いだけなので、アプリケーションから見て存在を意識しなくて良いものである。
  2. テーブルのデータに影響を与えない（データ透過的）。
  3. それでいて性能改善の効果が大きい。
    - これはインデックスの性能が、データ量に対して線形よりも緩くしか劣化しないためだが、詳細は後述。

### B-treeインデックス
- インデックスには色々な種類があるが、頻繁に利用するのはB-treeインデックスなので、まずはこれを覚えておけば良い。
- **B-treeの長所は、平均点の高さ。**レーダーチャートで言えばオール4である。他のインデックスは一長一短のものが多く、汎用性に欠ける。

### B-treeインデックスの構造
- B-treeは木構造でデータを保持する。構築時にキー値をソートして保持する。

1. 均一性
  - B-treeは平衡木であるため、常にリーフまでの距離が一定になり、探索を同じ計算量で行える。ただ、更新が繰り返されると非平衡木に近づき、性能が劣化する。
2. 持続性
  - B-treeの性能劣化は、非常に緩やかである。ランダウの記号で表すとO(log n)。
  - これは、B-treeが、データ量が増えたとしてもかなり「平べったい」（=木の高さが低い）木だからである。
3. 処理汎用性
  - B-treeインデックスは、挿入、更新、削除のコストも、検索と同じくO(log n)である。
4. 非等値性
  - B-treeは、等号による検索のみならず、不等号やBETWEENといった範囲検索の条件に対しても、高速化を可能とする。
5. 親ソート性
  - SQLは一部の処理（ORDER BYなど）を行う際、暗黙的にDBMS内部でソートが行われる。ソートはかなりコストの高い演算である。
  - B-treeは、構築時にキー値をソートして保持するため、ソート処理をスキップできる。

## 6-3 B-treeインデックスの設計方針
- B-treeインデックスを作る指針は下記。
  1. 大規模なテーブルに対して作成する。
  2. カーディナリティの高い列に作成する。
  3. SQL文でWHERE句の選択条件、または結合条件に使用されている列に作成する。

### 1. 大規模なテーブルに対して作成する
- **データ量が少ない場合は、インデックスの効果はほぼない。**
  - nが小さいと、フルスキャン: O(n)とB-tree: O(log n)ではO(log n)の方が大きい。
  - 目安としてはレコード数が1万件以下の場合。

### 2. カーディナリティの高い列に作成する
- B-treeを作成する列としての適不適を判断するための最も重要な情報が**カーディナリティ**である。これは、特定の列の値が、どのぐらいの種類の多さを持つか、ということを表す概念である。
- **B-treeインデックスを作るときは、カーディナリティの高い列を選ぶ。**
  - 目安は、特定のキー値を指定した時に、全体のレコード数の5%以下程度に絞り込めるだけのカーディナリティがあること。
- カーディナリティについて二点注意点がある。
  1. 複合列に対してインデックスを作成する場合、カーディナリティは対象の複合列の組み合わせで考える。
  2. **たとえカーディナリティが高くても、特定の値にデータが集中しているような列は向いていない。**（B-treeは値が平均的に分散している列に作るのがベスト。）

### 3. B-treeインデックスとSQL
- 下記のSQLの記述法を用いた場合、インデックスが使用されない。
  1. インデックス列に演算を行なっている
  2. 索引列に対してSQL関数を適用している　例：　WHERE SUBSTR(col_1, 1, 1) = 'a'
  3. IS NULL述語を使っている
  4. 否定形を用いている
  5. ORを用いている
    - INで書き換えると回避できる。
  6. 後方一致、または中間一致のLIKE述語を用いている
  7. 暗黙の型変換を行っている

### B-treeインデックスに関するその他の注意事項
- 主キーおよび一意制約の列には作成不要
  - これらは、作成時に、重複値チェックのためにB-treeインデックスが作成される。
- B-treeインデックスは更新性能を劣化させる
  - インデックスが作成されている対象の列値が変更されると、インデックス内に保持している値も変更しなければならないため。
- 定期的なメンテナンスを行うことが望ましい
  - 具体的にはインデックスの再構築を行うことが、性能を維持するために望ましい。

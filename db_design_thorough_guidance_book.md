達人に学ぶDB設計徹底指南書

# 第1章 データベースを制する者はシステムを制す
## 1-1 システムとデータベース
- データベースを使わないシステムは、この世に存在しない。
- 本書でのデータの定義は、「ある形式（フォーマット）に揃えられた事実」である。形式は二次元表など。データベースは、こうした一定の形式に従ったデータの蓄積である。
- 一方、情報という概念は、データと文脈を合成して生まれるものである。
- システムは、ユーザーが登録したデータを引き出して情報を作り出すという一連のサイクルの中に位置付けることもできる。

## 1-2 データベースあれこれ
- 現在商用利用されているデータベースには何種類かあるが、その分類はデータを保持するフォーマットを基準にして行われている。
  - リレーショナルデータベース：　最も広く利用されている。
  - オブジェクト指向データベース
  - XMLデータベース
  - キー・バリュー型ストア（Key-Value Store: KVS）
  - 階層型データベース
- モデルが異なれば設計技法も異なる。ただし、設計技法の達成したい目的（データの整合性の保持や冗長性排除など）はモデルが変わっても同じである。
- RDBでもDBMSは複数あるが、DBMSが異なっても、（基本的には）設計の方法は影響を受けない。

## 1-3 システム開発の工程と設計
- 開発の工程は以下に分解・分類できる。
  1. 要件定義：　要件（システムが満たすべき機能など）を決める工程
  2. 設計：　要件を満たすために必要なシステムを作るための設計を行う工程
  3. 開発（実装）：　設計書に従ってシステムを実際に作る工程
  4. テスト：　実装によって組み上がったシステムが、実用に耐える品質であるかを試験する工程
- 本書では設計工程に焦点を当てていく。
- システム開発の進め方（開発モデル）には大きく分けて二つの方法がある。
  - ウォーターフォールモデル
  - プロトタイピングモデル

## 1-4 設計工程とデータベース
- 本書では、データベースに保持するデータの設計（データベース設計と呼ぶ）について述べる。これが重要な理由は二つ。
  1. システムにおいて大半のデータ（少なくとも永続的に使用されるデータ）はデータベース内に保持される。そのため、普通、データ設計とはデータベース設計とほぼ同義である。
  2. データ設計がシステムの品質を最も大きく左右する。ソフトウェアというのは、言ってみれば「データの流通機構」であって、どのようなプログラムが必要になるかは、どのようなデータをどういうフォーマットで設計するかに左右される。

### DOAとPOA
- このうち特に重要なのが理由1である。近年のソフトウェア開発では、データ中心アプローチ（Data Oriented Approach:DOA）という考え方が主流となっているためである。かつて主流の考えであったプロセス中心アプローチ（POA）は現在では普通採用されることはない。
- POAはプロセス単位でデータ設計を行うことになるため、複数のプロセスで同じデータを別個に持つという冗長性が生じるなどの不都合が多い。
- DOAはPOAの欠点を克服するために登場した。その着眼のポイントは、データがあまり変化しない（永続的）という点である。データの意味や形式が先に決まっていれば、複数のプログラムで共用することも容易で、業務要件の仕様変更にも柔軟に対応できる。
- こうした理由から、システム開発においては、プログラム設計に先立ってまずデータ設計が優先されるのである。
- よって、データ設計（≒データベース設計）はシステムの品質を決める最も重要な要因と言っても過言ではない。

### 3層スキーマ
- DB設計で踏むべき具体的な段階について整理する上で重要となる概念が「スキーマ」である。DB設計においては、データベースのデータ構造やフォーマットという意味で使う。DB設計のステップは、このスキーマのレベルと密接に結びついている。スキーマは、一般的に三つのレベルに分けられる。
  1. 外部スキーマ
  2. 概念スキーマ
  3. 内部スキーマ
- この三つのスキーマに基づいてシステムを記述したモデルを、「3層スキーマモデル」と呼ぶ。

1. 外部スキーマ
  - ユーザーから見たデータベースの姿を定義するスキーマ。DBのオブジェクトとしては、ビューが相当する。
2. 概念スキーマ
  - 開発者から見たデータベースの姿を定義するスキーマ。
  - 必然的に、DB設計において重要な位置を占めることになる。
  - 概念スキーマの設計を「論理設計」とも呼ぶ。
3. 内部スキーマ
  - DBMSから見たデータベースを定義するスキーマ。
  - 論理設計との対比で「物理設計」と呼ぶ。

- 概念スキーマがいらないように見えるが、これは外部スキーマと内部スキーマの間にあることで、両者の変更が互いに影響しあわないようにするための緩衝材の役割を果たす。このようなスキーマの独立性のことを、**データ独立性**と呼ぶ。外部スキーマからの独立性を**論理的データ独立性**、内部スキーマからの独立性を**物理的データ独立性**と呼ぶ。概念スキーマはデータ独立性を保証するためにある。
- 概念の有用性がわからなかったら、「それがなかったらどうなるか」を考えてみるのが良い。

演習1-1

演習1-2
問題1：
- 問題となるSQLの特定、当該SQLのチューニング
問題2：
- 顧客との要件の再調整、必要な情報の出力処理を実装、UIの修正

# 第2章 論理設計と物理設計
## 2-1 概念スキーマと論理設計
- 概念スキーマを定義する設計を、論理設計と呼ぶ。
- システムの世界での論理とは、「物理層の制約（実装レベルの条件）にとらわれない」という意味。
- 原則として、論理設計は物理設計に先立つ。
- 論理設計は、現実世界に存在する数多くのデータから、リレーショナルデータベースにおいて、何を、どのようなフォーマットで保存するかを決めること。具体的には下記のタスクが含まれる。
  1. エンティティの抽出
  2. エンティティの定義
  3. 正規化
  4. ER図の作成

### エンティティの抽出
- エンティティは「実体」と訳すが、物理的実体が伴う必要はない。（税、注文履歴などでも良い）
- システムにどのようなエンティティ（=データ）が必要かを抽出することは一部が要件定義と重なるため、この工程はある程度顧客やシステム利用者と要件を詰めていく中で実施することになる。

### エンティティの定義
- エンティティは、データを「属性」（二次元表の列と同義）という形で保持する。エンティティの定義は属性を決めること。
- ここで特に重要なのは「キー」という列を定義すること。キーとは、ある特定の列の値を決定するための列(複数列でも良い)のこと。

### 正規化
- 正規化は、エンティティ（テーブル）について、システムでの利用がスムーズに行えるよう整理する作業
- RDBの論理設計においては、この正規化が最も重要な土台をなす。

### ER図の作成
- 正規化を行うとエンティティの数が増えてエンティティ同士の関係が把握しづらくなるので、関係を表現する図を作成することで理解しやすくする必要がある。

## 内部スキーマと物理設計
- 物理設計の流れは大きく分類すると以下の5つがある。
  1. テーブル定義
  2. インデックス定義
  3. ハードウェアのサイジング
  4. ストレージの冗長構成決定
  5. ファイルの物理配置決定

### インデックス定義
- インデックスは機能ではなくパフォーマンスに重要な役割を果たす。

### ハードウェアのサイジング
- サイジングはキャパシティ（データサイズに対する記憶装置の選定）とパフォーマンス（サーバーのCPUやメモリ）の2つの観点から行う。
- データベースの性能問題の８割はディスクI／Oによって起きる。
- DBにおいては、データの整合性とパフォーマンスの間に強いトレードオフがある。

#### パフォーマンスのサイジング
- システム開発での性能要件は二つの指標を使って定義する。
  - 処理時間　どれだけ早く処理できるか
  - スループット　どれだけたくさん処理できるか。1秒当たり仕事量TPSを指標に使う。

- 精度の高いサイジングは難しい。そのため、必ず実施時には安全率をかけ、スケーラビリティの高い構成を組む。

### ストレージの冗長構成
- ストレージが高い耐障害性を持つようにするための技術としてRAIDがある。
- RAIDの基本的な考えは、複数のディスクに同じデータを書き込んで冗長化し、一本が壊れても残りのディスクでデータを保全できるというもの。（信頼性向上）
- それだけでなく、RAIDは複数のディスクにデータを分散して保持することで、性能的にボトルネックとなるディスクI/Oを分散し、パフォーマンス向上を図ることができる。（性能向上）
- DBの物理設計では、RAIDについて以下を考える必要がある。
  - 当該データには、信頼性が求められるのか、それとも性能が求められるのか（最も重要な問い）
  - どのようなレベルのRAIDを採用するか
  - 何本のディスクでRAIDを構成するか
- RAIDの主な種類
  - RAID0
  - RAID1
  - RAID5
  - RAID10
- DBサーバーのストレージにおけるRAIDとして、少なくともRAID5で構成する。お金に余裕があればRAID10。RAID0は論外。

### ファイルの物理配置
- DBのファイルをどのディスク（またはRAIDグループ）に配置するかを検討する工程。
- DBに格納されるファイルは用途別に5種類に大別できる。開発者がその存在を意識するのはデータファイルとインデックスファイルのみ。
  - データファイル、インデックスファイル、システムファイル、一時ファイル、ログファイル
- 5種類のファイルの物理配置を考える際、最も重要なことはサイズと性能である。性能について考慮すると、5種類をそれぞれ別のディスクに分けるということになるが、それだけ潤沢にディスクを用意できることは滅多にないため、I/O量が比較的低いログファイルとシステムファイルを同じディスクにまとめるなどコストを下げていく。

## 2-3 バックアップ設計
- データベースの物理設計と隣接する領域に、データのバックアップおよびリストアの設計がある。
- この設計には二通りの方針がある。
  - 一つは、極力データを失わないような設計にすること。（例：RAID設計）
  - 二つ目は、障害によってデータが失われたときに、復旧できるようにしておくこと。これが本章で解説するバックアップとリカバリである。

### バックアップの基本分類
- バックアップは基本的にファイルのコピーで行う。
- 主要な三つのバックアップ方式は以下の通り。
  - フルバックアップ（完全バックアップ）
  - 差分バックアップ
  - 増分バックアップ

#### フルバックアップ
- ある時点でそのシステムで保持されているすべてのデータをバックアップする方式
- 下記の欠点がある。
  - 1. バックアップの時間が（他の方式に比べて）長い
  - 2. ハードウェアリソースへの負荷が（他の方式に比べて）高い
  - 3. サービス停止が必要　バックアップ中にデータが変更されるとデータ整合性が取れないため

#### 差分バックアップ
- ある時点で取得したフルバックアップに対する変更分だけのバックアップを適宜取得する方法。
- 差分管理はログファイル（トランザクションログ）をバックアップすることで実現する。トランザクションログにはDB内のデータに対する変更操作の履歴が残っているため、これをバックアップしておけばDBに対する変更操作を再現することが可能。
- 運用イメージとしては、例えば、月曜だけフルバックアップをとり、火曜〜土曜は月曜からの変更分のみをバックアップする。日曜に障害が起きたときは、月曜に取得したフルバックアップ＋土曜に取得した差分バックアップが必要。
- 利点：バックアップデータ量が減ること
- 欠点：リカバリの手順が増えて時間も長くなること

#### 増分バックアップ
- 差分バックアップにあった無駄（最新のログファイルが古いログファイルの内容も内包すること）を省いた方式
- 例えば、月曜だけフルバックアップを取得し、火曜〜土曜はその日の変更分のみバックアップする。
- 利点：バックアップデータ量が最小になること。バックアップに要する時間も最短となり、コスト的に最良の方式。
- 欠点：リカバリ手順が最も複雑になること。リカバリ時間も長い上、復旧に必要なファイルが増えるため完全にデータを復旧できる可能性が最も低くなる。

- バックアップコスト（バックアップにかかる時間）が低いほどリカバリコスト（リカバリにかかる時間）は高いというトレードオフがある。

### どのバックアップ方式を採用するか
- バックアップ設計において考慮すべきポイントは以下の4点。
  - 1. いつ時点の状態に復旧させる必要があるか。そもそも復旧の必要があるか
  - 2. バックアップに使用できる時間(バックアップウィンドウ)
  - 3. リカバリに使用できる時間(リカバリウィンドウ)
  - 4. 何世代までのデータを残す必要があるか(保管用の媒体サイズに影響)
- 上記鑑みて、現実的に選択されることが多いバックアップ方式は、「フルバックアップ＋差分バックアップ」または「フルバックアップ＋増分バックアップ」

## 2-4 リカバリ設計
- バックアップ設計とリカバリ設計はセットで実施することが一般的である。

### リカバリとリストア
- バックアップファイルをDBに戻しただけでは、バックアップ後から障害発生までの変更分が反映されず、リカバリは完結しない。
- ここで障害復旧の手順を厳密に二つに分ける必要がある。「バックアップファイルを戻す」作業を「リストア」、そのファイルに対してトランザクションログを適用して変更分を反映する作業を「リカバリ」と呼ぶ。

### リストアとロールフォワード
- DBMS内部に残っているバックアップされていないトランザクションログまで適用することで、初めてデータは障害直前の状態に復旧する。
- まとめると下記手順となる。
  1. フルバックアップのファイルをデータベースに戻す。　->リストア
  2. 差分（または増分）バックアップしていたトランザクションログを適用する。　-> リカバリ
  3. データベースサーバーに残っているトランザクションログを適用する。　-> ロールフォワード

# 第3章 論理設計と正規化

## 3-1 テーブルとは何か？
- テーブルとは、共通点を持ったレコードの集合である。
- 言い方を変えると、「テーブルは同じ種類の物の集合である」とも言えるため、テーブル名は英語ならば複数形／複数名詞で書ける。そうでなければそのテーブルにはどこか間違いがある。

## 3-2 テーブルの構成要素
### 行と列
- 横と縦のデータの組を「行」と「列」（あるいは「レコード」と「カラム」）と呼ぶ。

### キー
- キーは「あるレコード（1行とは限らない）を特定するための列の組み合わせ」
- キーの中で重要なものは以下の二つ。
  - 主キー
  - 外部キー

#### 主キー
- 主キーは、テーブルにおいて必ず一つ存在しなければならず、かつ一つしか存在しない。
- 主キーとは、その値を指定すれば、必ず1行のレコードを特定できるような列の組み合わせのこと。
  - 1行に特定することを「一意に識別する」という。
- 主キーがテーブルに必ず存在しなければならないというルールは、「テーブルには重複行は存在できない」ということを導く。
- 場合によっては複数列を組み合わせなければ主キーが作れないこともある。こうしたキーを**複合キー**と呼ぶ。
- 後補キー、スーパーキーというものもある。

#### 外部キー
- 外部キーは、二つのテーブルの間の列同士で設定するもの。
- 外部キーの役割は、その列を含むテーブルに対して一種の制約を課すことことである。この制約を「**参照整合性制約**」と呼ぶ。
- 外部キーは人間の親子関係と同じ。
  - 「社員」テーブルの外部キーとして部署列があり、部署列を持つ「部署」テーブルがあったとする。この場合、親が「部署」テーブルで、子が「社員」テーブルである。
  - 部署テーブルの部署列にない部署を持つ社員レコードを登録することはできない。（親が存在しないと子は存在できない。）
  - 部署テーブルには自由に新たな部署を登録できる。（子のいない親は存在しうる。）
- 外部キーが設定されている場合、データの削除は子から順に操作するのが良い。
  - 親テーブルのレコードを削除するときに、対応する子レコードも合わせて削除するか、それとも削除SQL文をエラーにするか選択できる。合わせて削除する動作を「カスケード」と呼ぶ。

- キー（主キー、外部キー）となる列には、コードやIDなど表記体系の定まった固定長文字列を用いるのが鉄則。
  - 可変長文字列をキーに使うのは、表記揺れがあるため危険

### 制約
- テーブルにつけられる制約の代表的なものは以下の三つ。
  - NOT NULL制約
  - 一意制約
  - CHECK制約

#### NOT NULL制約
- **テーブル定義において、列には可能な限りNOT NULL制約を付加する。**
  - NULLはSQLで扱う上でいろいろな問題を引き起こすため。
  - 主キーとなる列にはDBMS側で暗黙的にNOT NULL制約が付加される。

#### 一意制約
- 一意制約は、ある列の組について一意性を求める制約である。

#### CHECK制約
- ある列の取りうる値の範囲を制限するための制約。

### テーブルと列の名前
#### 名前に使える文字集合
  (a) 半角のアルファベット
  (b) 半角の数字
  (c) アンダーバー
- **テーブルや列の名前に日本語は使ってはいけない。**

#### 最初はアルファベット

#### 名前は重複してはならない
- テーブルの場合、DBMSが設定する範囲内においては、同じ名前を使うことができない。この範囲をドメインと呼ぶ。DBMSによってはスキーマと呼ぶ。

## 3-3 正規化とは何か？

### 正規形の定義
- 正規形とは、一言で言うと、データベースで保持するデータの冗長性を排除し、一貫性と効率性を保持するためのデータ形式
- 冗長性や非一貫性の問題を解決するために考案された方法論が、正規化である。
- 第１〜第５正規形まである。通常の業務では第３正規形まで達成したら、その時点で以降の正規形の条件も満たしていることがほとんど。そのため、普通は第３正規形まで理解すれば十分。

## 3-4 第1正規形
- 便宜的にテーブルの行と列が交差する特定の一マスのことを「セル」と呼んだとしたときに、第1正規形の定義は「**一つのセルの中には一つの値しか含まない**」というもの。一つのセルに一つだけの値が含まれている時、この値のことを「**スカラ値**」と呼ぶ。
- 一つのセルに二つ以上の要素を入れたい場合がある。このような時は、行持ち（要素の数だけ行を増やす方法）を採用すると良い。ただ、この時、複数の列を主キーに指定せざるをえないケースが出てくるが、主キーは一部であってもNULLを含んではならないというルールのために、矛盾が生じる場合がある。そのような時は、テーブルを分割する。
- 一つのセルに複数の値を入れることができない理由は、セルに複数の値を許せば、主キーが各列の値を一意に決定できず、主キーの定義に反することになるためである。
- このことは、**関数従属性**（入力Xに対して出力Yが一つに決まることを「YはXに従属する」と表現する）という概念と結びついている。実は、正規化とはテーブルのすべての列が関数従属性を満たすように整理していくことなのである。

## 3-5 第2正規形〜部分関数従属
- 主キーの一部の列に対して従属する列がある場合、この関係を**部分関数従属**と呼ぶ。これに対し、主キーを構成するすべての列に従属性がある場合を、**完全関数従属**と呼ぶ。
- 第2正規形とは、テーブル内で部分関数従属を解消し、完全関数従属のみのテーブルを作ることである。
- 部分関数従属を解消する手段は、部分関数従属の関係にあるキー列と従属列を、独立した別テーブルに分割することである。
- 第2正規形にしない場合、部分関数従属の従属列だけ登録することが実質的にできないことや、部分関数従属の従属列に間違ったデータを登録できてしまうなどの問題がある。
- 第2正規化は、異なるレベルの実体（エンティティ）を、きちんとテーブルとしても分離してやる作業とも言える。
- 第2正規化は**可逆的**な操作であり、元に戻せる。これができるのは、正規化が情報を完全に保存したままテーブルを分割する操作（**無損失分解**）だからである。
- 正規化の逆操作は常に結合である。（結合SQLで行うことができる。）

TCP/IPネットワーク入門

- vagrantの立ち上げ
$ cd ~/ubuntu1804
$ vagrant up
$ vagrant ssh

- vagrantの終了
$ exit  //仮想マシンからのログアウト
$ vagrant halt  //仮想マシンのシャットダウン


## 2.6
traceroute
- パケットが目的地までに通る道順　通過するルータ　経路と呼ばれる
- 通過するルータの台数のことをホップ数という
- インターネットは、たくさんのルータによるパケットのバケツリレー
- 注：IPアドレスを持ってネットワークにつながっている、ルータではないコンピュータをホストという。

## 2.7
- TCP/IPでは、次にパケットを渡すべき相手をルーティングテーブルというもので管理する。ルーティングテーブルは、インターネットにつながるノードがそれぞれ持っている。
ip route show
- ルーティングテーブルは、複数のルーティングエントリから構成される。
- ルーティングエントリを構成する二大要素は、「宛先」と「次にパケットを渡す相手（ネクストホップ）」である。
- 他のどの宛先にも該当しない時に使われる宛先のことをデフォルトルートという。
- ルーティングテーブルを使って、ネクストホップにパケットを転送する作業のことをルーティングという。

# 3 Network Namespace

## 3.1
sudo ip netns add <namespace名>
ip netns list
sudo ip netns exec <namespace名> <コマンド>
sudo ip netns delete <namespace名>

## 3.2
- Network namespaceの作成
- vethという仮想的なネットワークインターフェイスの追加
- vethをnetwork namespaceに所属させる
- vethインターフェイスにIPアドレスを付与する
- vethインターフェイスのstateをdown -> upに変更
- これでpingで疎通確認できる

## 3.3
- 同じネットワークのセグメントに所属するIPアドレス同士は、基本的にルータがいなくても通信できる。
- ルータは、異なるセグメント同士を繋ぐために存在する。

セグメントについて理解するためにIPアドレスを深掘りする
- IPアドレスは、ネットワーク部とホスト部という2つの部分からなる。IPアドレスを、特定のビット数を境目にして前後に分け、前半部分をネットワーク部、後半部分をホスト部と呼ぶ。ネットワーク部に対応する部分をネットワークアドレス、ホスト部に対応する部分をホストアドレスという。
- ネットワークアドレスが同じIPアドレスは、同じセグメントに属する。
- 192.0.2.1/24 のアドレスの後ろの24は、24ビット目までがネットワーク部であることを示している。この書き方はCIDR表記と呼ばれることがある。

## 3.4 ルータの設定
- 一般的にセグメントの先頭または末尾のIPアドレスを使うことが多い。.1 か .254
- セグメントが複数あると、その間を仲介するためにルータが必要になる。この際、ホストは自身が直接つながっていない相手とルータを介して通信するために、ルーティングエントリを必要とする。
- LinuxにおいてIPv4のルータとして動作するかを決めるカーネルのパラメータとして、net.ipv4.ip_forwardがある。これを１に指定するとルータとしての動作が有効になる。

## 3.5 ルータ増やす
- 直接つながっていないセグメントの情報は、ノードに何らかの方法で教えてあげる必要がある。
- 人間が手でルーティングエントリを追加するような方式をスタティックルーティング（静的経路制御）という。ルータ同士が自律的に自身の知っているルーティング情報を教えあう方式は、ダイナミックルーティング（動的経路制御）と呼ぶ。ルーティング情報を交換するのに使うプロトコルはルーティングプロトコルという。

# 4 イーサネット
- OSI参照モデルなどの階層構造を、下から番号を振った呼び方をすることがある。IPならレイヤー3のプロトコル。イーサネットは一般的にレイヤー2のプロトコルとみなされる。
- 現在の家庭やオフィスで用いられるデータリンク層や物理層に対応するプロトコルを含んだ規格はほとんどイーサネットと考えて良い。

## 4.1 イーサネットの役割
- イーサネットでデータを送る単位はフレームという。
- イーサネットでフレームの送信元と送信先を管理するために使われるのが、MACアドレスという識別子である。

## 4.2 フレームを観察する

## 4.3 MACアドレスを知るには
- ARPプロトコルを使うことで、IPアドレスに対応するMACアドレスを解決できる。
- ARPもIPと同じようにイーサネットのフレームで運ばれる。
- ARPリクエストのフレームは、送信先のMACアドレスがブロードキャストアドレス（ff:ff:ff:ff:ff:ff）と呼ばれる特殊なMACアドレスになっている。このフレームは、「このフレームが届く限りの範囲で、すべての機器に聞いてほしい」という意味になる。送信先がブロードキャストアドレスになっているフレームのことをブロードキャストフレームという。また、ブロードキャストフレームが届く範囲のことをブロードキャストドメインという。
- 同じセグメントにARPリクエストを送ったときの挙動は、送信元がブロードキャストドメインに対してブロードキャストフレームを送り、次に、送信先に該当するIPアドレスを持っている機器がARPリプライでMACアドレスを送り返すという形で行われる。
- ARPを使うのはIPv4だけで、IPv6ではICMPv6プロトコルのNeighbor Discoveryという仕組みが用いられる。 

## 4.4 パケットの積み替え
- 一般的に、ブロードキャストドメインの範囲は、ネットワークのセグメントと同じになる。
- ルータを介した別セグメントにpingで通信する場合（ホストns1 -> ホストns2）
  - ns1は、ルーティングテーブルを調べ、ネクストホップとなるIPアドレスを持つノード（この場合ルータ）のMACアドレスを知るために、ARPで解決する。
  - ns1は、解決したMACアドレスに向け、後続のフレームでIPのパケット（ICMPのリクエストを含む）を送る。
  - ルータは、パケットの送信先IPアドレスに一致する宛先をルーティングテーブルから調べる。この場合、送信先IPアドレスのネクストホップがインターフェースになっているので、このインターフェースのブロードキャストドメインの範囲に送信先IPアドレスがいるはずである。なので、ARPでMACアドレスを解決する。
  - 解決できたMACアドレス（ns2）に向け、IPのパケットを送る。
  - ns2からns1へ戻りのパケットを送る。この戻りでは、ARPを使う必要はない。（IPアドレスとMACアドレスの対応関係はARPリクエストを通してわかっているため。）
- パケットがイーサネットのフレームに積み替えられる時、2つのインターフェイスでキャプチャしたイーサネットのフレームは、それぞれ送信元と送信先のMACアドレスは異なる。一方、フレームで運ばれているパケットのIPアドレスは、送信元も送信先も変わっていない。これは、IPパケットという（荷物の入った）ダンボール箱が、イーサネットのフレームというトラックに積み替えられて目的地に運ばれる様子を示している。

## 4.5 ブリッジ
- スイッチングハブ
  - これは、複数のネットワーク機器を同じブロードキャストドメインに参加して通信できるようにする機器。
  - ルータとPCの間に、LANケーブルがたくさんついた箱のような形で設置されている場合がある。
  - USBハブのイーサネット版みたいなもの。
- ブリッジ
  - スイッチングハブという言葉をより一般化した用語が、ブリッジである。
  - データリンク層でフレームを転送する機器のことはブリッジと呼ばれる。（構成としては、ネットワーク層でパケットを転送する機器であるルータに似ている）
  - ブリッジの役割は、自身のどのポートにどのMACアドレスの機器がつながっているのか管理すること。管理するための台帳はMACアドレステーブルという。
- linuxにはネットワークブリッジというものがある。ネットワークブリッジもネットワークインターフェースの一種。
- スイッチングハブの重要な特徴として、自身につながっているポートのMACアドレスを学習する機能がある。
  - ARPパケットなどからポートの先にいるMACアドレスを学習する。
  - この機能により、通信相手のいないポートにムダなフレームを流さないようにできる。
  - ムダなフレームを流さないというのは、当たり前のようだが、一昔前まで使われていたリピータハブでは送信元以外のすべてのポートに単にフレームを流すという動作をしていた。

# 5. トランスポート層のプロトコル
- ここまでのIPを使った通信の問題点
  - コンピュータでは様々なアプリケーションの通信が行われるが、送受信するたくさんのパケットがそれぞれどのアプリケーションで使われているのかをどうやって判断するか
  - パケットが経路上で破棄される恐れがある
- 上記問題は、IPよりさらに上のプロトコルであるトランスポート層のプロトコルで解決する。

## 5.1 UDP
- UDP
  - TCPより単純なプロトコル。UDPを使うと、通信しているアプリケーションを区別できるようになる。
- ポート
  - 通信するアプリケーションは、UDPヘッダに含まれるポートというフィールドで区別する。フィールドに入る値のことは、一般的にポート番号と呼ぶ。
  - 宅配便のメタファーでいえば、IPアドレスが住所の番地で、ポート番号は集合住宅における部屋番号と考えられる。
- UDPのヘッダのフォーマット
  - Source Port, Destination Port
  - UDPでデータをやり取りする単位のことはデータグラムという。
- UDPヘッダを組み立てる時のポート番号の決め方
  - 相手からの通信を待ち受けるアプリケーションでは、トランスポート層よりさらに上位層のプロトコルによってポート番号があらかじめ決まっている。
  - 通信を自分から始める立場のアプリケーションでは、アプリケーションから指定しない限りOSが自動的にポート番号を選んで割り当てる。このように、OSが選んで割り当てるポート番号のことをエフェメラルポートという。
- ポート番号の領域分け
  - 0 - 1023（システムポート、またはウェルノウンポート）、1024 - 49151（ユーザポート、またはレジスターポート）、49152 - 65535（ダイナミックポート、またはプライベートポート）
  - システムポートとユーザポートの範囲はIANAという組織が管理しているので、自分で新たな用途に使う場合の指針としては、ダイナミックポートの範囲から選ぶのが望ましい。
- UDPは、コネクションレス型という、送ったら送りっぱなしで、パケットの破棄を関知しないプロトコルである。そのため、UDPでは、章冒頭で述べた、経路上でのパケット破棄の問題を解決できない。

## 5.2 TCP
- TCPでは、UDPと同じように、通信しているアプリケーションをポートで区別できる。また、それに加えて、信頼性のある通信が実現できる。
- TCP概要
  - TCPはコネクション型のプロトコル。
  - パケットが経路上で破棄されるなどして相手に届かなかった時は、同じデータを再び送る。（再送制御）
  - 上記以外にも、パケットが送った順番と到着する順番が入れ替わることがある。（アウトオブオーダー）
  - TCPを使えば、そのペイロードとなる（より上位の）プロトコルは、パケットの喪失やアウトオブオーダーについて意識する必要がなくなり、透過的に信頼性のある通信が実現できる。
- TCPヘッダのフォーマット
  - UDPと同じように送信元と送信先のポートの入るフィールドがある。
  - UDPよりもヘッダのフィールドが多い。
- TCPの通信開始時のやり取り
  - TCPでデータをやり取りする単位のことをセグメントと呼ぶ。
  - 最初にセグメントを3つやり取りする。目的は、通信相手と、これからデータを送り合うことについて確認すること。この通信は、スリーウェイハンドシェイクという。
- コントロールビット：　６ビット分のフラグ（TCPヘッダのFlags）からなる。スリーウェイハンドシェイクでは、コントロールビットの中でもSYNとACKというフラグの立ったセグメントを送る。
- SYN： このビットが立ったパケットを送り合うことで、お互いにシーケンス番号を同期する。シーケンス番号は、TCPがデータの順番を管理するのに使うフィールド。（アウトオブオーダーへの対応）
- ACK：　データがちゃんと届いていることを確認するためのフラグ。TCPのセグメントを受信した側は、自分がそのセグメントをちゃんと受け取ったことをACKの立ったセグメントを送ることで示す。送信する側は、送信したセグメントに対応するACKが返ってこない時に、同じセグメントを何度か送り直す。（再送制御）
- このように、TCPは、どこまでデータが届いているかをお互いに確認しながらやり取りすることで、信頼性のある通信を実現している。

# 6. アプリケーション層のプロトコル
- 代表的なアプリケーション層のプロトコルとして、下記3つを取り上げる。
  - HTTP
  - DNS
  - DHCP

## 6.1 HTTP
- HTTPは、TCPの80番ポートを使ってやり取りされるテキストベースのプロトコルである。

## 6.2 DNS
- DNSは、UDPの53番ポートを使ってやり取りされるバイナリベースのプロトコル。
- ドメイン名は、DNSを使うことでIPアドレスに解決できる。これを一般に名前解決という。
- 名前解決の仕組み
  - ドメイン名の解決は、OSの中でリゾルバと呼ばれるプログラムが担当する。
  - リゾルバは、まずhostsファイルでドメイン名に対応するIPを探しに行く。そこで見つからない場合、外部のサーバーに問い合わせる。リゾルバが問い合わせるDNSのサーバーのことをネームサーバーという。
  - UDPの53番がDNSの通信にデフォルトで使われるポート番号になる。
  - ブロードバンドルータが、コンピュータとネームサーバーの間を中継する場合がある。この中継機能は、DNSのフォワーダやプロキシ、あるいはリレーなどと呼ばれる。
  - リゾルバが名前解決に使うネームサーバーやフォワーダのIPアドレスは、一般的なUnix系のOSでは、/etc/resolv.confという設定ファイルにある。

## 6.3 DHCP
- DHCPは、UDPの67番ポートを使ってやり取りされるバイナリベースのプロトコル。
- DHCPプロトコルの役割は、コンピュータがTCP/IPのネットワークを使うのに必要な設定作業を自動化すること。
- DHCPはサーバー・クライアントの方式のプロトコルである。ネットワークの設定を配布するコンピュータがDHCPサーバーで、設定を受け取るコンピュータをDHCPクライアントという。家庭やオフィスなどの一般的なネットワークでは、デフォルトルートになるルータがDHCPサーバーを兼任することが多い。
- DHCPサーバー側：　dnsmasq、　DHCPクライアント側：　dhclient

# 7. NAT
- NATは、「IPアドレスを変換する」という概念を指す。変換とは、パケットのヘッダにおいてIPアドレスの入ったフィールドの値を書き換える操作を指す。
- NATの一種であるNAPTを使うと、少数のグローバルアドレスを、多数のプライベートアドレスで共有できる。
- プライベートアドレス
  - プライベートアドレスとして、次のプレフィックスが予約されている。10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16
  - 上記のプレフィックスからサブネット（より大きなネットワークの部分集合）を切り出して、そこからLANにつながるノードのIPアドレスを採番して使う。
  - 組織内のネットワークのことはLANという。プライベートアドレスはLANの中でしか通用しない。（ヘッダにプライベートアドレスが含まれるパケットは、インターネットではルーティングできない。）プライベートアドレスを使ってインターネットを利用するためにNATを使う。

## 7.1 Source NAT
- Source NAT 文字通りパケットの送信元IPアドレスを、プライベートアドレスからグローバルアドレスに変換（書き換え）する。
- 一般的に、NATはルータが実施する。書き換えるのは、送信先がグローバルアドレスで、送信元がプライベートアドレスになっているパケットのヘッダ。
- グローバルアドレスとプライベートアドレスを1:Nの関係で扱うには、IPアドレス以外にも、トランスポート層のポート番号を書き換える必要がある。ポートまで含めて書き換えるため、厳密にはNAPTになる。
- NAPTでは、インターネットに転送するパケットのIPアドレスとポート番号を必要に応じて書き換えるとともに、記憶しておく。そうすれば、インターネットからパケットが戻ってきたときに、LANのどのノードにパケットを転送すれば良いか判断できる。NAPTでは、この書き換える前と書き換えた後の対応関係をセッションと呼んで管理する。
- 実験
  - LinuxでNATを設定するにはiptablesというコマンドを使う。
  - iptablesでは処理を適用するタイミングのことをチェインと呼ぶ。

## 7.2 Destination NAT
- Destination NATを使うと、インターネットから到来したパケットをLANに繋がっているノードに転送できる。
  - 一般的には、送信先のポートが特定の値になっているTCPやUDPのパケット（の宛先IPアドレス）だけを選択的に書き換えてLANに転送する。
  - 挙動としては、指定したトランスポート層のプロトコルで、特定のポートに関してだけはインターネットを起点とした通信を許可する形になり、この振る舞いを持って「ポートを空ける」ともいう。
- 近年はIPv4アドレスの需給がさらに逼迫しているためCGN(Carrier Grade NAT)という仕組みも普及している。

# 8. ソケットプログラミング
- ネットワークプログラミングのためのAPIとしてUnix系OSでデファクトスタンダードになっているソケットがある。
  - ソケットを使ったネットワークプログラミングを、特にソケットプログラミングという。
  - ソケットは、ネットワークを抽象化したインターフェースである。

## 8.1 HTTPクライアント
- socket() : ソケットでどんな種類の通信をするか指定する
- connect() : 通信したいサーバとポートを指定して接続を開く
- send() / recv() : バイト列を送受信する
- close() : 接続を閉じる

## 8.2 エコーサーバ
- socket()
- bind() : 接続を待ち受けるIPアドレスとポート番号を指定する
- listen() : 接続の待ち受けを開始する
- accept() : 接続してきたクライアントを処理する
- send() / recv()
- close()

## 8.3 バイナリベースのプロトコル
- バイナリベースのプロトコルには、特有の気をつけるべきポイントがある。それは、バイトオーダーまたはエンディアンと呼ばれる概念である。
- TCP/IPの世界ではバイトオーダーをビッグエンディアンに統一している。ネットワークにおけるビッグエンディアンをネットワークバイトオーダーと呼ぶことがある。対して、CPUのアーキテクチャに依存したコンピュータ内部での表現方法はホストバイトオーダーと呼ぶ。
- つまり、バイナリのデータをTCP/IPで送信するときは、ホストバイトオーダーをネットワークバイトオーダーに変換する必要がある。

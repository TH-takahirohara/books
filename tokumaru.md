徳丸本

## 3.1 HTTPとセッション管理
### 入力 - 確認 - 登録パターン

####  Referer
リクエストメッセージにRefererと言うヘッダがつくことがある。これは、リンク元のURLを示すヘッダで、form要素によるフォーム送信時などにつく。
Refererがセキュリティ上の問題になるのは、URLが秘密情報を含んでいる場合。外部に漏洩したら、成りすましに悪用される可能性がある。4.6.3項で詳しく説明する。

#### GETと POSTの使い分け
- 以下が1つでも当てはまる場合はPOSTを使う
  - データ更新など副作用を伴うリクエストの場合
  - 秘密情報を送信する場合
  - 送信するデータの総量が多い場合

#### hidden
hiddenパラメータは利用者自身によって書き換えできる。
hiddenパラメータのメリットは、hiddenは利用者自身からは書き換えできるが、情報漏洩や第三者からの書き換えに対しては堅牢であるということ。
利用者自身によっても書き換えられては困る認証認可に関する情報はセッション変数に保存すべきだが、それ以外の情報は、まずはhiddenパラメータに保存することを検討すると良い。

#### ステートレスなHTTP認証

- 認証と認可（5.1, 5.3で詳しく説明）
  - 認証：利用者が確かに本人であることを何らかの手段で確認すること
  - 認可：認証済みの利用者に（データの参照などの）権限を与えること
  - IDとパスワードを入力して認証されると、即座に権限が与えられる場合がほとんどである。ただ、開発やセキュリティを考える上では区別して理解すべきである。

### クッキーとセッション管理

#### クッキーによるセッション管理
- アプリケーションデータを保持する目的でクッキーそのものに値を入れることは、主に2つの理由であまりない。
- クッキーには「整理番号」としてのセッションIDを格納しておき、実際の値はサーバー側で管理する方法が広く用いられている。これをクッキーによるセッション管理と呼ぶ。
- セッションIDに求められる要件は以下の通り。
  1. 第三者がセッションIDを推測できないこと
  2. 第三者からセッションIDを強制されないこと
  3. 第三者にセッションIDが漏洩しないこと

- 1.について　セッションIDを推測できると、推測した値で成りすましができる。そのため、セッションIDは十分な桁数の乱数を使う。ただし、**セッション管理機構は自作しない**。世に出ている開発ツールで提供されるセッション管理機構は、脆弱性があった場合はすぐに改善されているはずなので、基本的にこちらを使うこと。「4.6 セッション管理の不備」で詳しく扱う。
- 2.は、セッションIDの固定化攻撃への対策。これは、**認証後にセッションIDを変更することで対策できる**。

#### セッションID漏洩について
- 漏洩について、ネットワーク盗聴から保護するにはTLSによる暗号化が有効。
- クッキーを発行する際の属性として、**Domain属性は原則として設定しない**。（脆弱性の原因になりうるため。）
- クッキーモンスターバグ
- クッキーのSecure属性
- クッキーのHttpOnly属性
  - JSを悪用したXSS攻撃によるクッキーを盗み出す攻撃を防ぐことができる。

## 3.2 受動的攻撃と同一オリジンポリシー
### 能動的攻撃と受動的攻撃
#### 受動的攻撃
- 受動的攻撃は、Webサイトの利用者に罠を仕掛けることにより、罠を閲覧したユーザーを通してアプリケーションを攻撃する手法のこと。単純なものから3パターン説明。
- 単純な受動的攻撃
  - 罠サイトに誘導し、マルウェアに感染させる
- 正規サイトを悪用する受動的攻撃
  - 正規サイトを攻撃し、コンテンツに仕掛けを仕込む。正規サイトの利用者が仕掛けを含むコンテンツを閲覧すると、マルウェア感染などが起こる
- サイトをまたがった受動的攻撃

### ブラウザはどのように受動的攻撃を防ぐか
#### サンドボックスという考え方
- 利用者のブラウザで悪意のあるプログラムが動かないように、JavaScriptなどは安全性を高めるための機能を提供している。基本的な考え方は2種類ある。
  - 利用者に配布元を確認させた上で、利用者が許可した場合のみ実行する
  - プログラムの「できること」を制限するサンドボックスという環境を用意する
- サンドボックスでは、以下のように機能が制限される。
  - ローカルファイルへのアクセスの禁止
  - プリンタなどの資源の利用禁止（画面表示は可能）
  - ネットワークアクセスの制限（同一オリジンポリシー）

#### 同一オリジンポリシー
- 同一オリジンポリシーとは、JavaScriptなどのクライアントスクリプトからサイトをまたがったアクセスを禁止するセキュリティ上の制限であり、ブラウザのサンドボックスに用意された制限の1つである。
- ブラウザには同一オリジンポリシーがあるが、アプリケーションに脆弱性があるとXSSなどの受動的攻撃を受ける場合がある。

### JavaScript以外のクロスドメインアクセス

## 3.3 CORS(Cross-Origin Resource Sharing)
### シンプルなリクエスト
- 異なるオリジンと「シンプルなリクエスト」でデータのやりとりをしようとすると、Access-Control-Allow-Originヘッダがレスポンスにない場合はエラーになる。
- Access-Control-Allow-Origin
  - クロスオリジンからの読み出しを許可するための仕掛けで、情報の提供元（サーバー側）がHTTPレスポンスヘッダとして出力する。
- 「シンプルなリクエスト」はHTMLフォームから送られるリクエストを基準として条件が設定される。

### プリフライトリクエスト
- クロスオリジンアクセスにおいて「シンプルなリクエスト」の条件を満たさない場合、ブラウザは、プリフライトリクエストというHTTPリクエストを送信する。
- プリフライトリクエストでAccess-Control-Request-Methodヘッダーなどのヘッダを含むリクエストをOPTIONSメソッドで送信する。サーバー側は、レスポンスにAccess-Control-Allow-Methodsヘッダなどをつけて返さないと、ブラウザ側でエラーが出る。

### 認証情報を含むリクエスト
- クッキーなどの認証用のヘッダを伴うクロスオリジンリクエストは、下記の両方を満たす必要がある。
  - XMLHttpRequestオブジェクトのwithCredentialsプロパティをtrueにする
  - レスポンスヘッダとしてAccess-Control-Allow-Credentials: trueを返す

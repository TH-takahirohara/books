徳丸本

## 3.1 HTTPとセッション管理
### 入力 - 確認 - 登録パターン

####  Referer
リクエストメッセージにRefererと言うヘッダがつくことがある。これは、リンク元のURLを示すヘッダで、form要素によるフォーム送信時などにつく。
Refererがセキュリティ上の問題になるのは、URLが秘密情報を含んでいる場合。外部に漏洩したら、成りすましに悪用される可能性がある。4.6.3項で詳しく説明する。

#### GETと POSTの使い分け
- 以下が1つでも当てはまる場合はPOSTを使う
  - データ更新など副作用を伴うリクエストの場合
  - 秘密情報を送信する場合
  - 送信するデータの総量が多い場合

#### hidden
hiddenパラメータは利用者自身によって書き換えできる。
hiddenパラメータのメリットは、hiddenは利用者自身からは書き換えできるが、情報漏洩や第三者からの書き換えに対しては堅牢であるということ。
利用者自身によっても書き換えられては困る認証認可に関する情報はセッション変数に保存すべきだが、それ以外の情報は、まずはhiddenパラメータに保存することを検討すると良い。

#### ステートレスなHTTP認証

- 認証と認可（5.1, 5.3で詳しく説明）
  - 認証：利用者が確かに本人であることを何らかの手段で確認すること
  - 認可：認証済みの利用者に（データの参照などの）権限を与えること
  - IDとパスワードを入力して認証されると、即座に権限が与えられる場合がほとんどである。ただ、開発やセキュリティを考える上では区別して理解すべきである。

### クッキーとセッション管理

#### クッキーによるセッション管理
- アプリケーションデータを保持する目的でクッキーそのものに値を入れることは、主に2つの理由であまりない。
- クッキーには「整理番号」としてのセッションIDを格納しておき、実際の値はサーバー側で管理する方法が広く用いられている。これをクッキーによるセッション管理と呼ぶ。
- セッションIDに求められる要件は以下の通り。
  1. 第三者がセッションIDを推測できないこと
  2. 第三者からセッションIDを強制されないこと
  3. 第三者にセッションIDが漏洩しないこと

- 1.について　セッションIDを推測できると、推測した値で成りすましができる。そのため、セッションIDは十分な桁数の乱数を使う。ただし、**セッション管理機構は自作しない**。世に出ている開発ツールで提供されるセッション管理機構は、脆弱性があった場合はすぐに改善されているはずなので、基本的にこちらを使うこと。「4.6 セッション管理の不備」で詳しく扱う。
- 2.は、セッションIDの固定化攻撃への対策。これは、**認証後にセッションIDを変更することで対策できる**。

#### セッションID漏洩について
- 漏洩について、ネットワーク盗聴から保護するにはTLSによる暗号化が有効。
- クッキーを発行する際の属性として、**Domain属性は原則として設定しない**。（脆弱性の原因になりうるため。）
- クッキーモンスターバグ
- クッキーのSecure属性
- クッキーのHttpOnly属性
  - JSを悪用したXSS攻撃によるクッキーを盗み出す攻撃を防ぐことができる。

## 3.2 受動的攻撃と同一オリジンポリシー
### 能動的攻撃と受動的攻撃
#### 受動的攻撃
- 受動的攻撃は、Webサイトの利用者に罠を仕掛けることにより、罠を閲覧したユーザーを通してアプリケーションを攻撃する手法のこと。単純なものから3パターン説明。
- 単純な受動的攻撃
  - 罠サイトに誘導し、マルウェアに感染させる
- 正規サイトを悪用する受動的攻撃
  - 正規サイトを攻撃し、コンテンツに仕掛けを仕込む。正規サイトの利用者が仕掛けを含むコンテンツを閲覧すると、マルウェア感染などが起こる
- サイトをまたがった受動的攻撃

### ブラウザはどのように受動的攻撃を防ぐか
#### サンドボックスという考え方
- 利用者のブラウザで悪意のあるプログラムが動かないように、JavaScriptなどは安全性を高めるための機能を提供している。基本的な考え方は2種類ある。
  - 利用者に配布元を確認させた上で、利用者が許可した場合のみ実行する
  - プログラムの「できること」を制限するサンドボックスという環境を用意する
- サンドボックスでは、以下のように機能が制限される。
  - ローカルファイルへのアクセスの禁止
  - プリンタなどの資源の利用禁止（画面表示は可能）
  - ネットワークアクセスの制限（同一オリジンポリシー）

#### 同一オリジンポリシー
- 同一オリジンポリシーとは、JavaScriptなどのクライアントスクリプトからサイトをまたがったアクセスを禁止するセキュリティ上の制限であり、ブラウザのサンドボックスに用意された制限の1つである。
- ブラウザには同一オリジンポリシーがあるが、アプリケーションに脆弱性があるとXSSなどの受動的攻撃を受ける場合がある。

### JavaScript以外のクロスドメインアクセス

## 3.3 CORS(Cross-Origin Resource Sharing)
### シンプルなリクエスト
- 異なるオリジンと「シンプルなリクエスト」でデータのやりとりをしようとすると、Access-Control-Allow-Originヘッダがレスポンスにない場合はエラーになる。
- Access-Control-Allow-Origin
  - クロスオリジンからの読み出しを許可するための仕掛けで、情報の提供元（サーバー側）がHTTPレスポンスヘッダとして出力する。
- 「シンプルなリクエスト」はHTMLフォームから送られるリクエストを基準として条件が設定される。

### プリフライトリクエスト
- クロスオリジンアクセスにおいて「シンプルなリクエスト」の条件を満たさない場合、ブラウザは、プリフライトリクエストというHTTPリクエストを送信する。
- プリフライトリクエストで、本来のリクエストを送る前に、Access-Control-Request-Methodヘッダーなどのヘッダを含むリクエストをOPTIONSメソッドで送信する。サーバー側は、レスポンスにAccess-Control-Allow-Methodsヘッダなどをつけて返さないと、ブラウザ側でエラーが出る。

### 認証情報を含むリクエスト
- クッキーなどの認証用のヘッダを伴うクロスオリジンリクエストは、下記の両方を満たす必要がある。
  - XMLHttpRequestオブジェクトのwithCredentialsプロパティをtrueにする
  - レスポンスヘッダとしてAccess-Control-Allow-Credentials: trueを返す

# Chapter 4 Webアプリケーションの機能別に見るセキュリティバグ
## 4.1 Webアプリケーションの機能と脆弱性の対応
### 脆弱性はどこで発生するのか
- 脆弱性には処理に起因するものと出力に起因するものがある
- 入力に起因する脆弱性はない
- 出力に起因する脆弱性には「インジェクション」という単語がつくものが多い

### インジェクション系脆弱性とは
- インジェクション系脆弱性が発生する原因は、Webアプリケーション側が「データ」を想定しているところに、引用符やデリミタなど「データの終端」を示すマークを混入させて、その後の文字列（SQL文など）の構造を変化させるところにある。

## 4.2 入力処理とセキュリティ
- 入力値のチェックで、根本的な対策に穴があった場合の実害を防ぐ、あるいは軽減できる場合がある。

### Webアプリケーションの「入力」では何をするか
- 入力処理では、入力値に対して以下の処理を行う。
  1. 文字エンコーディングの妥当性検証
  2. 文字エンコーディングの変換（必要な場合のみ）
  3. 入力値（パラメータ文字列）の妥当性検証
- 文字エンコーディングについては6章で詳しく説明

### 入力値の検証
- 入力値検証の目的
  - 入力値の間違いを早期に発見して再入力を促すことにより、ユーザビリティを向上する
  - 間違った処理を継続することによるデータの不整合などを防ぎ、システムの信頼性を向上させる

#### 入力値検証とセキュリティ
- 入力値検証の主目的はセキュリティのためではないが、セキュリティのために役立つ場合もある。

#### バイナリセーフという考え方とヌルバイト攻撃
- ヌルバイトを使った攻撃手法が知られており、ヌルバイト攻撃と呼ばれる。他の脆弱性の対策をかいくぐるために悪用される。
  - バイナリセーフでない関数は、検査対象文字列にヌルバイトがあると、そこで文字列が終わっていると判断することをつかれる。
- 対策としては、アプリケーションの入り口でバイナリセーフの関数を用いて入力値のヌルバイトをチェックし、ヌルバイトがあればエラーにすることにより確実な対応が可能になる。

#### 入力値検証だけでは対策にならない
- あくまでも入力値検証は保険的対策としてとらえるべき。後述のように入力値検証はアプリケーションの仕様が基準となるため。

#### 入力値検証の基準はアプリケーション要件
- 制御文字のチェック
  - 1行テキストボックスには、通常の入力方法では制御文字は入力できないので、制御文字はすべて拒絶できる場合が多い。
- 文字数のチェック
- 数値の最小値・最大値のチェック
  - 以下を行うと良い
    - 数値文字列としての文字種・文字数のチェック
    - 文字列型から数値型への型変換
    - 最小値・最大値の範囲にあることの確認
- その他の注意点 その他の問題として以下がある。
  - 入力項目が指定されていない（項目自体がない）ケース
  - 配列形式で入力されているケース
    - スカラー値を期待したプログラムに入力値として配列が指定されると思わぬエラーになる場合がある。
    - PHPではfilter_input関数で入力値検証を簡潔に記述できる。

#### 正規表現による入力値検証の例　英数字１〜５文字
- u修飾子
- i修飾子
- データの先頭は\A、データの末尾は\zで示す。

#### 正規表現による入力値検証の例　住所欄
- 住所欄のような文字種の制限がない場合でも、制御文字が混入していないというチェックをすべき。
- POSIX文字クラスによる制御文字以外の指定

### まとめ
- 入力値検証の実施手順
  - 設計段階で各パラメータの文字種および最大文字数、最小値・最大値を仕様として決める
  - 設計段階で入力値検証の実装方針を決める
  - 開発段階では仕様に従い入力値検証を実装する。

## 4.3 表示処理に伴う問題
- この節では、サーバー側処理で起こるXSSを扱う。

### 4.3.1 クロスサイト・スクリプティング（基本編）
#### 概要
- 通常、Webアプリケーションには外部からの入力などに応じて表示が変化する箇所があり、この部分のHTML生成の実装に問題があると、XSSという脆弱性が生じる。
- XSS脆弱性がある場合には、以下の影響がある。
  - サイト利用者のブラウザ上で、攻撃者の用意したスクリプトの実行によりクッキー値を盗まれ、利用者が成りすましの被害にあう
  - 同じくブラウザ上でスクリプトを実行させられ、サイト利用者の権限でWebアプリケーションの機能を悪用される
  - Webサイト上に偽の入力フォームが表示され、フィッシングにより利用者が個人情報を盗まれる

#### XSS脆弱性のまとめ
- 発生箇所
  Webアプリケーション上でHTML、JavaScriptを生成している箇所
- 影響を受けるページ
  Webアプリケーション全体が影響を受ける
- 影響の種類
  Webサイト利用者のブラウザ上でのJavaScriptの実行、偽情報の表示
- 影響の度合い
  中〜大
- 利用者関与の度合い
  必要 -> 罠サイトの閲覧、メール記載のURLの起動、攻撃を受けたサイトの閲覧など
- 対策の概要
  - 属性値はダブルクォートで囲む
  - HTMLで特別な意味を持つ記号文字をエスケープする

#### 攻撃手法と影響
- XSSの悪用の方法3種類
  - クッキー値の盗み出し
  - その他のJavaScriptによる攻撃
  - 画面の書き換え

- 反射型XSSと持続型XSS
  - 攻撃用JSが、攻撃対象サイトと別のサイトにある場合を反射型XSSと言う。反射型のXSSは、多くの場合入力値をそのまま表示するページで発生する。
  - 攻撃用のJSが、攻撃対象のデータベースなどに保存される場合がある。その場合のXSSを持続型XSSと呼ぶ。WebメールやSNSなどが典型的な攻撃ターゲットである。

#### 脆弱性が生まれる原因
- XSS脆弱性が生じる原因は、HTML生成の際に、HTMLの文法上特別な意味を持つ特殊記号を正しく扱っていないことであり、それにより、開発者の意図しない形でHTMLやJavaScriptを注入・変形される現象がXSSである。
- HTMLのエスケープは、XSS解消のためには非常に重要である。

#### 必須対策
- 要素内容については「<」と「&」をエスケープする
  -> htmlspecialchars関数によりエスケープ
- 属性値については、ダブルクォートで囲って、「<」と「"」と「&」をエスケープする
  -> htmlspecialchars関数によりエスケープしてダブルクォートで囲む

#### 必須対策（共通対策）
- HTTPレスポンスに文字エンコーディングを明示する

#### XSSに対する保険的対策
- X-XSS-Protectionレスポンスヘッダの使用
  - これは、XSSフィルタというセキュリティ機能を上書きして有効化するヘッダ
  - すべてのHTTPレスポンスで以下を出力することを（筆者は）推奨する。
  `X-XSS-Protection: 1; mode=block`
- 入力値の検証　入力値の条件が英数字のみに限定できる場合などに限られる。
- クッキーにHttpOnly属性を付与する
- （TRACEメソッドの無効化）

### 4.3.2 クロスサイト・スクリプティング（発展編）
#### href属性やsrc属性のXSS
- href属性は、javascriptスキームによるXSSの対象になりうる。
- URLを生成する場合は、httpスキームとhttpsスキームで始まる絶対URLかスラッシュで始まる相対URLであるかをチェックする。
- リンク先ドメイン名のチェック

#### JavaScriptの動的生成
- イベントハンドラのXSS
  1. データをJavaScript文字列リテラルとしてエスケープする
  2. この結果をHTMLエスケープする
- script要素のXSS
- JavaScriptの文字列リテラルの動的生成の対策
  - 対策しづらいので、JSに動的パラメータを渡すときに利用できる方法2種類を紹介する。
  - script要素の外部でパラメータを定義して、JavaScriptから参照する方法
  - インラインJSONPによる方法

#### HTMLタグやCSSの入力を許す場合の対策
- HTMLテキストを構文解析して必要な要素のみを抽出するライブラリを使用することが望ましい。

### 4.3.3 エラーメッセージからの情報漏洩
- 以下の2種類がある。
  - エラーメッセージに攻撃者にとって有益なアプリケーションの内部情報が含まれる
  - 意図的な攻撃として、エラーメッセージに秘密情報を表示させられる
- 対策：エラー発生時に画面に表示するのは利用者向けのメッセージにとどめ、エラーの詳細はログに出力するようにする。

## 4.4 SQL呼び出しに伴う脆弱性
### 4.4.1 SQLインジェクション
#### 概要
- SQLインジェクションは、SQLの呼び出しかたに不備がある場合に発生する脆弱性。攻撃者が能動的に（利用者の関与なしで）サーバーを攻撃できる。
- 以下のような影響を受ける可能性がある。
  - データベース内のすべての情報が外部から盗まれる
  - データベースの内容が書き換えられる
  - 認証を回避される（IDとパスワードを用いずにログインされる）
  - その他、データベースサーバー上のファイルの読み出し、書き込み、プログラムの実行などを行われる
- 確実な対策は、静的プレースホルダを利用してSQLを呼び出すこと。

#### 攻撃手法と影響
- エラーメッセージ経由の情報漏洩
- UNION SELECTを用いた情報漏洩
- SQLインジェクションによる認証回避
- SQLインジェクション攻撃によるデータ改ざん
- その他の攻撃

#### 脆弱性が生まれる原因
- 典型的な原因はリテラルの扱いにある。
- 文字列リテラルの問題
  - シングルクォートなどを用いてリテラルからはみ出した文字列をSQL文として認識させ、アプリケーションが呼び出すSQL文を変更する手法がSQLインジェクション攻撃である。
- 数値項目に対するSQLインジェクション

#### 対策
- SQLインジェクション脆弱性を解消するためには、SQL文を組み立てる際にSQL文の変更を防ぐこと。方法としては
  1. プレースホルダによりSQL文を組み立てる
  2. アプリケーション側でSQL文を組み立てる際に、リテラルを正しく構成するなど、SQL文が変更されないようにする
- 1.の方法を著者は強く勧める。
- 静的プレースホルダと動的プレースホルダの違い
  - 原理的にSQLインジェクションの可能性がないという点で静的プレースホルダの方が優れている。
- SQLインジェクションの保険的対策
  - 詳細なエラーメッセージの抑止
  - 入力値の妥当性検証
  - データベースの権限設定

#### さらに進んだ学習のために
- エスケープすべき文字の詳細、文字エンコーディングの影響については、「安全なSQLの呼び出し方」を参照

## 4.5 「重要な処理」の際に混入する脆弱性
### 4.5.1 クロスサイト・リクエストフォージェリ（CSRF）
#### 概要
- 「重要な処理」の受付に際して必要となる、利用者の意図したリクエストであることの確認処理が抜けていると、罠のサイトなどを閲覧しただけで、利用者のブラウザから勝手に「重要な処理」を実行させられる場合がある。このような問題を引き起こす脆弱性をCSRFと呼ぶ。
- 影響の例
  - 利用者のアカウントによる物品の購入
  - 利用者の退会処理
  - 利用者のアカウントによるSNSや問い合わせフォームなどへの書き込み
  - 利用者のパスワードやメールアドレスの変更
- CSRF脆弱性の影響は、アプリケーションの「重要な処理」の悪用に限られ、被害者である利用者の個人情報などを盗むことはできない。
- 対策は、「重要な処理」を実行する前に、利用者の意図したリクエストであることを確認すること。

#### 攻撃手法と影響
- 入力-実行パターンのCSRF攻撃
- 確認画面がある場合のCSRF攻撃
- ファイルアップロードフォームでのCSRF攻撃

#### 脆弱性が生まれる原因

#### 対策
- 以下の二点を実施する
  - CSRF対策の必要なページを区別する
  - 正規利用者の意図したリクエストを確認できるように実装する
- CSRF対策の必要なページを区別する
  - ECサイトにおける物品購入など、他のサイトから勝手に実行されると困るページには、CSRF対策を施す。
  - 開発プロセスでは下記のようにする
    - 要件定義工程で機能一覧を作成し、CSRF対策の必要な機能にマークする
    - 基本設計工程で画面遷移図を作成し、CSRF対策の必要なページにマークする
    - 開発工程でCSRF対策を作りこむ
- 正規利用者の意図したリクエストであることを確認する
  - 具体的な方法は3種類が知られている
    - 秘密情報（トークン）の植え込み
    - パスワード再入力
    - Refererのチェック
- 保険的対策
  - 「重要な処理」の実行後に、登録済みメールアドレスに通知メールを送信する

### 4.5.2 クリックジャッキング
#### 概要
- iframe要素とCSSを巧妙に利用することで、透明にした攻撃対象ページと罠のサイトを重ね合わせ、利用者が気づかないうちに攻撃対象サイトでのクリックを誘導する攻撃手法である。

#### 攻撃手法と影響

#### 脆弱性が生まれる原因
- アプリケーションのバグが原因ではなく、HTMLの仕様を巧妙に悪用した攻撃である。

#### 対策
- frame及びiframeでの参照を制限するX-Frame-Optionsという仕様が、主要ブラウザの最新版で採用されている。この仕様に対応することによりクリックジャッキング対策が容易にできるようになっている。
- X-Frame-Optionsを必ず指定すべきページは「重要な処理」の1つ手前の入力フォームだが、すべてのページでX-Frame-Optionsヘッダを出力しても問題ないので、Apacheやnginxなどの設定で出力することもできる。

## 4.6 セッション管理の不備
### 4.6.1 セッションハイジャックの原因と影響
- 第三者がセッションIDを悪用して成りすますことをセッションハイジャックと呼ぶ。
- 第三者がセッションIDを知るための手段は、以下の3種類に分類される。
  - セッションIDの推測
  - セッションIDの盗み出し　盗み出しに悪用可能な脆弱性の典型例は以下
    - XSS
    - HTTPヘッダ・インジェクション
    - URLに埋め込まれたセッションID
  - セッションIDの強制

### 4.6.2 推測可能なセッションID
#### 概要
- 発生箇所： セッションIDを生成している箇所
- 影響を受けるページ： セッション管理を利用しているページすべて。とくに、秘密情報の表示や重要な処理をするページは影響が大きい。
- 影響の種類： 成りすまし
- 影響の度合い： 大
- 利用者関与の度合い：　不要
- 対策の概要：　自作のセッション管理機構ではなく、実績のあるWebアプリケーション開発ツールの提供するセッション管理機構を利用する

#### 攻撃手法と影響

#### 脆弱性が生まれる原因
- セッション管理機構を自作していることが脆弱性の原因を作ったと言える。

#### 対策
- Webアプリケーション開発ツールが備えるセッション管理機構を利用すること。

### 4.6.3 URL埋め込みのセッションID
#### 対策
- クッキーにセッションIDを保存するよう設定する。

### 4.6.4 セッションIDの固定化
- セッションアダプション
  - PHPやASP.NETには未知のセッションIDを受け入れるという特性がある。この特性はセッションアダプションと呼ばれる。
  - セッションアダプションがない場合、攻撃者はまずターゲットアプリケーションを閲覧して、有効なセッションIDを取得し、このセッションIDを被害者に強制するように罠サイトを設定する。
  - つまり、セッションアダプション問題がなくても、セッションIDの固定化攻撃自体は可能である。
- クッキーのセッションIDを外部から設定することは容易ではないが、ブラウザやWebアプリケーションに脆弱性があれば、可能になる。

#### 脆弱性が生まれる原因
- 第一の原因は、セッションIDを外部から強制できることであるが、これに対する本質的な対策を取ることは難しい。
- このため、セッションIDが外部から強制されることは許容し、セッションIDの固定化攻撃が行われても、セッションハイジャックは防ぐように対策することが一般的である。

#### 対策
- セッションID固定化攻撃に対する対策方法は、認証後にセッションIDを変更すること。
- セッションIDの変更ができない場合は、トークンにより対策する。
- ログイン前にセッション変数を使っていると、セッションIDの固定化攻撃に完全に対策することは困難である。ログイン前にはセッション管理機構を使わず、hiddenパラメータで値を引き回すことが、現実的な対策になる。

## 4.7 リダイレクト処理にまつわる脆弱性

### 4.7.1 オープンリダイレクト
- Webアプリケーションの中には、パラメータにより指定したURLにリダイレクトできる機能を備えるものがある。その中で、任意のドメインにリダイレクトできる脆弱性をオープンリダイレクト脆弱性と呼ぶ。

#### 攻撃手法と影響
- 攻撃者は、利用者に罠のリダイレクト先が入ったURLを閲覧するように仕向ける。罠のリダイレクト先に再度ログインさせるような画面を用意しておき、利用者が送信することで利用者の重要情報が盗まれる。

#### 脆弱性が生まれる原因
- 下記両方が当てはまる場合、オープンリダイレクト脆弱性になる
  - リダイレクト先のURLを外部から指定できる
  - リダイレクト先のドメイン名のチェックがない
- 以下二点が揃っている場合は、脆弱性ではない（例：バナー広告）
  - もともと外部のドメインに遷移する仕様であること
  - 利用者にとって外部ドメインに遷移することが自明であること

#### 対策
- 根本対策は以下のいずれかを実施すること
  - リダイレクト先のURLを（外部から指定するのではなく）固定にする
  - リダイレクト先のURLを直接指定せず番号指定にする
    - ページ番号の形で指定させ、ページ番号とURLの対応表は外部から見えないスクリプトソースなどで管理する。
  - リダイレクト先のドメイン名をチェックする
    - このチェックは落とし穴が多いので、できるだけ上の2つの方法による実装がお勧め

### 4.7.2 HTTPヘッダ・インジェクション
#### 概要
- リダイレクトやクッキー発行など、外部からのパラメータを元にHTTPレスポンスヘッダを出力する際に発生する脆弱性である。レスポンスヘッダを出力する際のパラメータ中に改行を挿入する攻撃によって、被害者のブラウザ上で以下のどちらか、あるいは両方が引き起こされる。
  - 任意のレスポンスヘッダの追加
  - レスポンスボディの偽造
- HTTPヘッダ・インジェクション脆弱性があると、以下の影響があり得る
  - 任意のクッキーの生成
  - 任意のURLのリダイレクト
  - 表示内容の改変
  - 任意のJavaScript実行によるXSSと同様の被害

#### 脆弱性が生まれる原因
- リダイレクト先URLやクッキー値として設定されるパラメータ中に改行を挿入した場合に、改行がそのままレスポンスとして出力されることが原因。

#### 対策
1. 外部からのパラメータをHTTPレスポンスヘッダとして出力しない
  - レスポンスヘッダを利用する主な機能はリダイレクトとクッキー生成だが、以下の方針で外部パラメータを使う機会は大幅に減る
    - リダイレクト先をURLとして直接指定するのではなく、固定にするか番号などで指定する
    - Webアプリケーション開発ツールの提供するセッション変数を使ってURLを受け渡す
2. どうしても外部からのパラメータをHTTPレスポンスヘッダとして出力しなければならない場合は、以下の両方を実施する
  - リダイレクトやクッキー生成を専用APIに任せる
  - ヘッダ生成するパラメータの改行文字をチェックする

### 4.7.3 リダイレクト処理にまつわる脆弱性のまとめ
- リダイレクト処理にはできるだけ専用のAPIを使用する
- 以下のいずれかを実施する
  - リダイレクト先は固定にする（推奨）
  - 外部から指定するリダイレクト先のURLは、必ず文字種とドメイン名をチェックする

## 4.8 クッキー出力にまつわる脆弱性
- クッキーにまつわる脆弱性は大別すると以下の2種類
  - クッキーを利用すべきでない目的でクッキーを使っている
  - クッキーの出力方法に問題がある
- クッキー出力時に発生しやすい脆弱性には以下がある
  - HTTPヘッダ・インジェクション脆弱性
  - クッキーのセキュア属性不備

### 4.8.1 クッキーの不適切な利用
- Webアプリケーションで、ページをまたがる情報を保存する場合は、PHPなどが提供するセッション管理機構が用いられる。一般的に、セッション管理機構ではセッションIDのみをクッキーに保存し、データ自体はWebサーバーのメモリなどに保存する。一方、クッキーに保存すべきでないデータをクッキーに保存することにより脆弱性が発生する場合がある。
- セッション変数とは異なり、クッキー値はアプリケーションの利用者によって書き換えができるので、書き換えられると困る情報をクッキーに保存すると脆弱性の原因になる。

- クッキーにデータを保存するより、（一部実現できないことはあるが）セッション変数の方が便利で安全に使用できるため、通常はセッション変数を使用すべき

### 4.8.2 クッキーのセキュア属性不備
#### 概要
- アプリケーションがHTTPS通信を利用していても、セキュア属性のついていないクッキーは平文で送信される場合があり、盗聴される可能性がある。
- セキュア属性不備への対策は、クッキーのセキュア属性を設定すること。しかし、HTTPとHTTPSの混在するサイトの場合うまく動かなくなるケースもある。この場合は、セッションIDとは別に、トークンをセキュア属性つきクッキーとして発行して、ページごとに確認する方法がある。

#### 攻撃手法と影響
- HTTPS通信でセットされたクッキー値が、被害者が罠サイト閲覧時に443ポートに対するHTTPリクエストが送信されることで、暗号化されていない状態でネットワーク上を流れることになる。攻撃者がこの通信中のクッキー値を盗聴できる場合、セッションハイジャックに悪用できる。

#### 脆弱性が生まれる原因
- 原因は以下の2種類。後者について説明する。
  - 開発者がセキュア属性について知らない
  - セキュア属性をつけるとアプリケーションが動かなくなる
- 後者に対するシンプルな解決策は、サイト全体をHTTPSにする「常時TLS」にした上でクッキーにセキュア属性をつけることである。それが難しい場合は、トークンを用いた対策がある。
- トークンを用いた対策
  - トークンを保持するクッキーにセキュア属性をつけることで、HTTPのページとHTTPSのページでセッションを共有しつつ、仮にセッションIDを盗聴された場合でもHTTPSのページはセッションハイジャックを防止できる。
- トークンにより安全性が確保できる理由
  - トークンは認証成功時に一度だけサーバーから出力される
  - トークンはHTTPSのページで生成される（サーバー -> ブラウザ）
  - トークンは確実に暗号化されてブラウザから送信される（ブラウザ -> サーバー）
  - HTTPSのページを閲覧するにはトークンが必須

#### セキュア属性以外の属性値に関する注意
- Domain属性：　特殊な理由がない限り指定する必要なし
- Expire属性：　セッションIDのクッキーには通常Expires属性をつけず、ブラウザ終了と同時にクッキーが削除される状態にする
- HttpOnly属性：　セッションIDをJSから参照する意味はないので、通常つけるようにするとよい

## 4.9 メール送信の問題
### 4.9.1 メール送信の問題の概要

### 4.9.2 メールヘッダ・インジェクション
- メールヘッダ・インジェクションは、宛先や件名などのメールヘッダを外部から指定する際に、改行文字を使ってメールヘッダや本文を追加・変更する手法である。影響は以下の通り
  - 件名や送信元、本文を改変される
  - 迷惑メールの送信に悪用される
  - ウイルスメールの送信に悪用される

#### 攻撃手法と影響
- 宛先の追加
- 本文の改竄
- 添付ファイルをつける

#### 脆弱性が生まれる原因
- メールのメッセージヘッダでは、改行に特別な意味があるが、アプリケーションが改行をチェックしていない場合には、ヘッダや本文を追加・変更できてしまう。これが脆弱性の発生原因である。

#### 対策
- メール送信には専用のライブラリを使用する（sendmailコマンドを使うのは危険）
- その上で、以下のいずれかを実施する
  - 外部からのパラメータをメールヘッダに含ませないようにする
  - 外部からのパラメータには改行を含まないようにメール送信時にチェックする

## 4.10 ファイルアクセスにまつわる問題
### 4.10.1 ディレクトリ・トラバーサル
- 外部からパラメータの形でサーバー上のファイル名を指定できるWebアプリケーションでは、ファイル名に対するチェックが不十分であると、アプリケーションの意図しないファイルに対して閲覧や改竄、削除ができる場合がある。この脆弱性をディレクトリ・トラバーサルと呼ぶ。

#### 脆弱性が生まれる原因
- 下記の全てを満たすとディレクトリ・トラバーサル脆弱性になる。
  - ファイル名を外部から指定することができる
  - ファイル名として、絶対パスや相対ぱすの形で異なるディレクトリを指定できる
  - 組み立てたファイル名に対するアクセスの可否をチェックしていない

#### 対策
- 以下のいずれかを実施すること
  - 外部からファイル名を指定できる仕様を避ける
    - ファイル名を固定にする
    - ファイル名をセッション変数に保持する
    - ファイル名を直接指定するのではなく番号などで間接的に指定する
  - ファイル名にディレクトリ名が含まれないようにする
    - PHPの場合、basenameという関数が使用できる。これは、ディレクトリ付きファイル名を受け取り、最後の名前の部分を返すものである。（../../hostsを受け取ったらhostsを返す）
  - ファイル名を英数字に限定する

### 4.10.2 意図しないファイル公開
#### 概要
- 外部から閲覧されると困るファイルをWebサーバーの公開ディレクトリに配置している場合がある。この場合、ファイルに対するURLが分かると、秘密ファイルの閲覧が可能になる。意図しないファイル公開により、重要情報の漏洩などにつながる。

#### 攻撃手法と影響
- URLでディレクトリ名を指定した場合にファイル一覧を表示する機能のことをディレクトリ・リスティングと呼ぶ。対策していない場合、この機能も活用して、秘密ファイルのリンクから情報が漏れてしまう。

#### 脆弱性が生まれる原因
- 非公開のファイルを公開ディレクトリに置いたことが原因。公開ディレクトリに置かれたファイルが外部から閲覧できる条件は以下の通り。
  - ファイルが公開ディレクトリに置かれている
  - ファイルに対するURLを知る手段がある
  - ファイルに対するアクセス制限が掛かっていない
- ファイルに対するURLを知る手段には以下がある。
  - ディレクトリ・リスティングが有効　など。多いので書籍参照

#### 対策
- 非公開ファイルを公開ディレクトリに置かないことが根本対策。そのために、以下を推奨する。
  - アプリケーションの設計時に、ファイルの安全な格納場所を決める
  - レンタルサーバーを契約する場合は非公開ディレクトリが利用できることを確認する

## 4.11 OSコマンド呼び出しの際に発生する脆弱性
### 4.11.1 OSコマンド・インジェクション
- Webアプリケーションの開発に用いる言語の多くはシェル経由でOSコマンドを呼び出す機能を提供しており、シェルを呼び出せる機能の使い方に問題があると、意図しないOSコマンドが実行可能になる場合がある。これをOSコマンドインジェクション脆弱性と呼ぶ。

#### 攻撃手法と影響

#### 脆弱性が生まれる原因
- OSコマンド呼び出しに利用される関数やシステムコールの多くは、シェル経由でコマンドを起動している。シェルには、1行の指定で複数のプログラムを起動する方法が用意されている。この機能の悪用がOSコマンド・インジェクション攻撃である。
- OSコマンドのパラメータとして指定する文字列に、シェルのメタ文字を混入させることにより、開発者の意図とは異なるOSコマンドが実行可能となることがOSコマンド・インジェクション脆弱性の原因である。
- OSコマンド・インジェクション脆弱性が生まれる条件は、以下の3つのすべてを満たすことである。
  - シェルを呼び出す機能のある関数（system,openなど）を利用している
  - シェル呼び出しの機能のある関数にパラメータを渡している
  - パラメータ内に含まれるシェルのメタ文字をエスケープしていない

#### 対策
- 以下のいずれかによって対策することを推奨する。優先して採用すべき順
  - OSコマンド呼び出しを使わない実装方法を選択する
  - シェル呼び出し機能のある関数の利用を避ける
  - 外部から入力された文字列をコマンドラインのパラメータに渡さない
  - OSコマンドに渡すパラメータを安全な関数によりエスケープする
- 保険的対策
  - パラメータの検証
  - アプリケーションの稼働する権限を最小限にする
  - WebサーバーのOSやミドルウェアのパッチ適用

## 4.12 ファイルアップロードにまつわる問題
### 4.12.1 ファイルアップロードの問題の概要
- アップローダに対する攻撃には以下がある
  - アップロード機能に対するDoS攻撃
    - 対策：アップロードファイルの容量制限
  - アップロードされたファイルをサーバー上のスクリプトとして実行する攻撃
  - 仕掛けを含むファイルを利用者にダウンロードさせる攻撃
  - 閲覧権限のないファイルのダウンロード

### 4.12.2 アップロードファイルによるサーバー側スクリプト実行
#### 概要
- アップローダの中には、利用者がアップロードしたファイルをWebサーバーの公開ディレクトリに保存するものがある。加えて、ファイル名の拡張子として、phpなどサーバー側で実行可能なスクリプト言語の拡張子が指定できると、アップロードしたファイルをスクリプトとしてWebサーバー上で実行できる。

#### 脆弱性が生まれる原因
- 以下の両方に該当すること
  - アップロードしたファイルが公開ディレクトリに保存される
  - アップロード後のファイル名として、「.php」、「.asp」などサーバースクリプトを示す拡張子が指定できる

#### 対策
- 拡張子の制限だけでは対策抜けが生じる可能性があるので、ファイルを公開ディレクトリに保存しない方法をとる。
  - ダウンロードスクリプトを用いる。

### 4.12.3 ファイルダウンロードによるクロスサイト・スクリプティング
#### 概要
- アップロードしたファイルを利用者がDLする際に、ブラウザがファイルタイプを誤認する場合がある。例えば、アプリケーションがPDFファイルを想定しているにもかかわらず、PDFデータ中にHTMLタグが含まれていると、条件によってはブラウザがHTMLファイルとして認識してしまい、PDFファイルに埋め込まれたJSを実行する場合がある。これが、ファイルダウンロードによるXSSである。

#### 脆弱性が生まれる原因
- ファイルダウンロードによるXSSが生まれるのは、Content-Typeの間違った指定が原因である。この指定が間違っていると、ブラウザがコンテンツをHTMLと解釈し、コンテンツ中のJSが実行されてしまう可能性がある。
- 仮にContent-Typeが間違っていない場合でも、ブラウザが扱うことのできないContent-Typeの場合にはXSSになる場合がある。

#### 対策
- ファイルアップロード時の対策
  - 拡張子が許可されたものかをチェックする
- ファイルダウンロード時の対策
  - Content-Typeを正しく設定する（必須）
  - レスポンスヘッダX-Content-Type-Options: nosniffを指定する（必須）
  - 必要に応じてContent-Dispositionヘッダを設定する
  - PDFを扱う場合は、4.12.4項の対策を合わせて実施する

### 4.12.4 PDFのFormCalcによるコンテンツハイジャック
#### 概要
- FormCalcのURL関数を用いた仕掛けを組み込んだPDFファイルをアップロードすることにより、正規ユーザーに成りすましを行う攻撃手法が考案されている。Adobe Acrobat Readerプラグインを備えたブラウザが影響を受けるため、主にIEが対象ブラウザになる。

#### 脆弱性が生まれる原因
- Adobe Acrobat Readerのセキュリティ上好ましくない仕様を悪用したものなので、本来はAdobe Acrobat Readerの仕様が見直されるべきだが、Webアプリケーション側で対応せざるを得ないのが現状。

#### 対策
- PDFファイルはブラウザ内で開かずダウンロードを強制する
- PDFをobject要素やembed要素では開けない仕組みを実装する

## 4.13 インクルードにまつわる問題
### 4.13.1 ファイルインクルード攻撃
- PHPなどのスクリプト言語には、スクリプトのソースの一部を別ファイルから読み込む機能がある。PHPの場合はincludeなどがそれに当たる。includeなどに指定するファイル名を外部から指定できる場合、アプリケーションが意図しないファイルを指定することにより脆弱となる場合がある。これをフィルインクルード脆弱性と呼ぶ。

##### 脆弱性が生まれる原因
- インクルードファイル名を外部から指定することができる
- インクルードすべきファイル名かどうかのチェックをしていない

#### 対策
- ファイルインクルード脆弱性の解消の考え方は、ディレクトリ・トラバーサル脆弱性の場合と同様
  - 外部からファイル名を指定する仕様を避ける
  - ファイル名を英数字に限定する

## 4.14 構造化データの読み込みにまつわる問題
### 4.14.1 evalインジェクション
- ソースコードを解釈実行するevalと呼ばれる機能や関数があり、各言語のソースコードをデータとして扱うことができる。evalの利用法に問題がある場合、外部から送り込んだスクリプトを実行される場合がある。このような攻撃をevalインジェクション攻撃と言い、そのような攻撃を受ける脆弱性をevalインジェクション脆弱性と呼ぶ。
- evalインジェクションの影響は、OSコマンド・インジェクションと同じ

#### 脆弱性が生まれる原因
- evalを用いることがそもそも危険である
- evalに与えるパラメータのチェックがされていない

#### 対策
- eval（同等機能）を使わない
- evalの引数に外部からのパラメータを指定しない
- evalの与える外部からのパラメータを英数字に制限する

### 4.14.2 安全でないデシリアライゼーション
- アプリケーション内部の構造を持ったデータを保存・伝送する目的でバイト列に変換することをシリアライズと言い、シリアライズされたデータから元のデータに戻すことをデシリアライズと言う。
- シリアライズされたデータが信頼できない場合、デシリアライズ処理の際に意図しないオブジェクトがアプリケーション内に生成され、場合によっては任意のコードを実行してしまう場合がある。安全でないデシリアライゼーションの影響は、OSコマンド・インジェクション攻撃と同じ。

#### 対策
- シリアライズ形式ではなくJSON形式によりデータを受け渡す
- クッキーやhiddenパラメータではなくセッション変数など書き換えできない形でシリアライズ形式のデータを受け渡す
- HMACなどの改竄検知の仕組みを導入してデータが改竄されていないことを確認する

### 4.14.3 XML外部実体参照（XXE）
#### 概要
- XMLには外部実体参照という機能があり外部ファイルの内容を取り込むことができる。XMLデータを外部から受け取るプログラムは、外部実体参照の形でWebサーバー内部のファイルなどを不正に読み取られる可能性がある。この攻撃をXML外部実体参照攻撃と呼び、XML外部実体参照攻撃ができてしまう脆弱性をXML外部実体参照脆弱性と呼ぶ。

#### 脆弱性が生まれる原因
- XXEはXMLの機能を悪用するものであり、プログラムにコーディング上のバグがあるというものではない。

#### 対策
- XXE対策は外部実体参照を禁止する指定を行うことが基本となる。
- PHPにおけるXXE対策
  - XMLの代わりにJSONを用いる
  - libxml2のバージョン2.9以降を用いる
  - libxml_disable_entity_loader(true)を呼び出す

## 4.15 共有資源やキャッシュに関する問題
### 4.15.1 競合状態の脆弱性
#### 概要
- 共有資源とは、複数のプロセスやスレッドから同時に利用している変数、共有メモリ、ファイル、データベースなどのことである。共有資源に対する排他制御が不十分な場合、競合状態の脆弱性の原因になる場合がある。
- 競合状態の問題で起こる影響の代表例として以下がある
  - 別人の個人情報などが画面に表示される（別人問題）
  - データベースの不整合
  - ファイルの内容の破壊

#### 脆弱性が生まれる原因
- 共有変数（サーブレットクラスのインスタンス変数など）の排他制御をしていない

#### 対策
- 以下のいずれかを実施する
  - 可能であれば共有資源を使用しない
  - 共有資源に対して排他制御を行う

### 4.15.2 キャッシュからの情報漏洩
#### 概要
- 過剰にキャッシュが働いてしまうと、個人情報漏洩などの原因になる場合がある。

#### 脆弱性が生まれる原因
- 以下のいずれかがサイト側にあることが原因
  - アプリケーション側のキャッシュ制御不備
  - キャッシュサーバーの設定不備

#### 対策
- 以下の両方を実施すること
  - アプリケーション側でキャッシュ制御用の適切なレスポンスヘッダを設定する
  - キャッシュサーバー側でキャッシュ制御の適切な設定を行う

## 4.16 Web API実装における脆弱性

### 4.16.1 JSONとJSONPの概要
- JSON
  - JavaScriptのオブジェクトリテラル形式をデータ交換形式に発展させたもの
- JSONP
  - CORSができる前に同一オリジンポリシーの枠内で異なるオリジンのサーバーからデータを取得するいくつかの方法のうち、代表的なものの1つがJSONP
  - JSONPは、script要素を用いて外部のJavaScriptを直接実行することによりデータを取得する。そのためには、JSON文字列そのままではscript要素で受け取ることができないので、関数呼び出しの形でデータを生成する。

### 4.16.2 JSONエスケープの不備
#### 概要
- APIにおいてJSON文字列生成時のエスケープ処理に不備があると、意図しないJavaScriptがJSONデータに混入する場合がある。デコードの仕方などによっては、不正なJSの実行に至る。

#### 脆弱性が生まれる原因
- 以下の2つの条件が揃うこと
  - JSON文字列の生成時に適切なエスケープ処理などが行われていない
  - JSONの評価にeval関数などを用いているか、JSONPを用いている

#### 対策
- 文字列連結によるJSONデータ生成をやめ、信頼できるライブラリを用いてJSONを生成する
- eval関数ではなくJSON.parseなどの安全なAPIでJSONを解釈する
- 保険的対策として以下を強く推奨する
  - JSONPを避け、CORSを用いたWeb APIに移行する

### 4.16.3 JSON直接閲覧によるXSS
#### 概要
- JSONを返すWeb APIは、通常XMLHttpRequestによるアクセスを想定したものだが、APIが返すレスポンスデータをブラウザで直接閲覧させることにより攻撃が可能になる場合がある。

#### 脆弱性が生まれる原因
- MIMEタイプの間違いが直接の原因

#### 対策
- MIMEタイプを正しく設定する（必須）
- レスポンスヘッダX-Content-Type-Options: nosniffを出力する（強く推奨）
- 小なり記号などをUnicodeエスケープする（推奨）
- XMLHttpRequestなどCORS対応の昨日だけから呼び出せるようにする（推奨）

### 4.16.4 JSONPのコールバック関数名によるXSS
#### 概要
- JSONPはJSONデータを引数とするコールバック関数呼び出しの形式を取るが、このコールバック関数の名前は固定ではなく外部から指定できるようにするケースが多い。外部から指定したパラメータにより表示内容（関数名）が制御できることから、コールバック関数名によるXSSが可能になる場合がある。

#### 脆弱性が生まれる原因
- 外部から指定されたコールバック関数名を検証しないでそのまま表示している
- MIMEタイプをtext/javascriptとするべきところをtext/htmlとしている

#### 対策
- 以下の両方を実施すべき
  - コールバック関数名の文字種と文字数を制限する
  - MIMEタイプを正しく設定する

### 4.16.5 Web APIのクロスサイト・スクリプトフォージェリ
#### Web APIに対するCSRF攻撃経路
- GETリクエストによる攻撃
- HTMLフォームによる攻撃
- クロスオリジン対応のXMLHttpRequestによる攻撃（シンプルなリクエスト）
  - API側がクロスオリジンの呼び出しを許可していなくても、罠サイトのJSでHTTPリクエストを送ることはできるので、CSRF攻撃は成立する。
- XMLHttpRequestによる攻撃（プリフライトリクエストが必要なケース）

#### 対策
- 代表的な方法は以下
  - CSRFトークン（セッション変数にトークンを保持）
  - 二重送信クッキー
  - カスタムリクエストヘッダによる対策
    - JSライブラリの中には、Ajaxリクエストに自動的にカスタムリクエストヘッダを付与するものがある。これが付与されていることをサーバー側で確認するだけでもCSRF対策になる。
- 共通の対策として下記を実施する
  - 入力データのMIMEタイプ（application/jsonなど）を検証する
  - CORSを適切に実装する（4.16.8項参照）
- CSRFトークン、二重送信クッキーにおけるトークンパラメータの送信にはHTTPリクエストヘッダを用いることがお勧め。クロスオリジン通信でカスタムリクエストヘッダを付与するためには、プリフライトリクエストで許可される必要があるため、API側のプリフライトリクエストの処理にバグがなければ、CSRF攻撃は成立しない。

### 4.16.6 JSONハイジャック
#### 概要
- 何らかの方法でJSONデータをscript要素で受け取ることができないかが研究されており、その手法はJSONハイジャックと呼ばれている。

#### 対策
- X-Content-Type-Options: nosniffヘッダの付与（強く推奨）
- リクエストヘッダX-Requested-With: XMLHttpRequestの確認（推奨）

### 4.16.7 JSONPの不適切な利用
- JSONPは、その考案された事情から、極力使用をやめ、CORS対応のAPIに移行することが望ましい。

#### JSONPによる秘密情報提供
- JSONPにはCORSのようなアクセス制御の仕組みがないため、JSONPによる情報公開は公開情報の提供にとどめ、秘密情報の提供は避けるべき。

#### まとめ
- JSONPはできるだけ使用せずCORS+JSONに移行する
- JSONPは公開情報の提供のみに用いる
- JSONPは信頼できる提供元のみを使用する

### 4.16.8 CORSの検証不備
- CORSは非常によく考えられた仕様だが、利用者側の無知や手抜きにより問題が起こる場合はある。これはどのようなセキュリティ機構についても起こり得ること。
- 不備の例
  - オリジンとして"*"を指定する
  - オリジンのチェックをわざと緩和してしまう

### 4.16.9 セキュリティを強化するレスポンスヘッダ
- Web APIに限らず、常に出力しておくだけでブラウザのセキュリティ機能を強化するHTTPレスポンスヘッダの代表例
  - X-Frame-Options
    - 4.5.2 クリックジャッキングで紹介
  - X-Content-Type-Options
    - X-Content-Type-Options: nosniffという形で仕様。MIMEタイプの解釈を厳密にする
  - X-XSS-Protection
    - 利用者がXSSフィルタの有効化・無効化設定をしていても、当該ページについてXSSフィルタの設定を上書きする
    - XSSフィルタの動作モードを指定する
  - Content-Security-Policy
  - Strict-Transport-Security（HTTP Strict Transport Security; HSTS）

## 4.17 JavaScriptの問題
### 4.17.1 DOM Based XSS
#### 概要
- JSによる処理の不備が原因でXSSとなる場合もあり、DOM Based XSSと呼ばれる。

#### 攻撃手法と影響
- innerHTMLによるDOM Based XSS
- document.writeによるDOM Based XSS
- XMLHttpRequestのURL未検証の問題
- jQueryのセレクタの動的生成によるXSS
- javascriptスキームによるXSS location.hrefに任意の文字列を指定できるなど

#### 脆弱性が生まれる原因
- DOM操作の際に外部から指定されたHTMLタグなどが有効になってしまう機能を用いている
  - document.write() innerHTML、jQueryの$()など
- 外部から指定されたJavaScriptが動くevalなどの機能を用いている
- XMLHttpRequestのURLが未検証である
- location.hrefやsrc属性、href属性のURLが未検証である

#### 対策
- 以下のいずれか
  - 適切なDOM操作あるいは記号のエスケープ
  - eval, setTimeout, Functionコンストラクタなどの引数に文字列形式で外部からの値を渡さない
  - URLのスキームをhttpかhttpsに限定する
  - jQueryのセレクタは動的生成しない
  - 最新のライブラリを用いる
  - XMLHttpRequestのURLを検証する

### 4.17.2 Webストレージの不適切な使用
#### Webストレージとは
- 近年のブラウザでは、クッキーよりも高機能なストレージ（保管庫）として、Webストレージを用意している。

#### Webストレージには何を保存して良いか
- WebストレージはJSからのアクセスを禁止できない。そのため、WebアプリにXSS脆弱性があると、Webストレージの内容は漏洩することになる。
- 上記特性のため、重要な情報（パスワード、個人情報など）はWebストレージには保存しないようにする。

#### Webストレージの不適切な利用例
- Webストレージに秘密情報を保存していた
- Webストレージに保存した情報が、XSSやpostMessageにより漏洩する
- WebストレージがXSSやpostMessage経由で改竄される
- Webストレージを経由したDOM Based XSS

### 4.17.3 postMessage呼び出しの不備
#### postMessageとは
- iframeやwindow.openで開いたウィンドウなど、複数のウィンドウが異なるオリジンで協調して動作する環境で、メッセージやデータのやりとりを行う汎用的な仕組みがpostMessageである。

#### 問題となるケース
- メッセージ送信先の未確認
- メッセージ送信元の未確認

#### 対策のまとめ
- 送信先の（オリジンの）確認
- 送信元の（オリジンの）確認

### 4.17.4 オープンリダイレクト
#### 脆弱性が生まれる原因
- ボタンを押すとJSで何か処理を実行し、その後フラグメント識別子で指定されたURLにリダイレクトするようなケースでは、オープンリダイレクト脆弱性がある。

#### 対策
- 以下のいずれかの対策を取るのが良い
  - リダイレクト先のURLを固定にする
  - リダイレクト先URLを直接指定せず番号などで指定する

# Chapter 5 代表的なセキュリティ機能
## 5.1 認証
### ログイン機能
#### ログイン機能に対する攻撃
- SQLインジェクション攻撃によるログイン機能のバイパス
- SQLインジェクション攻撃によるパスワードの入手
- ログイン画面に対するパスワード試行
- ソーシャルエンジニアリングによるパスワード入手
- フィッシングによるパスワード入手

#### ログイン機能が破られた場合の影響
- セッションハイジャック手法の多くが受動的攻撃であり、攻撃に関して利用者の関与が必要であるのに対し、不正ログインは能動的攻撃であり、利用者の関与は不要である。そのため、不正ログインの方がより多くの利用者に影響が出る傾向がある。不正ログインは重大な脅威であり、十分な対策が必要である。

#### 不正ログインを防ぐためには
- フォーム認証において不正ログインを防ぐために必要不可欠な条件は以下の2つ
  - SQLインジェクションなどセキュリティバグ（狭義の脆弱性）をなくす
  - パスワードを予測困難なものにする
- パスワードについては、パスワードを決める責任が最終的には利用者にあるので、アプリケーション側の最低限の要件は「利用者が安全なパスワードをつけることを邪魔しない」ことである。
- 破られやすいパスワードが広く使われているという現状を踏まえ、積極的なパスワードポリシーのチェックを行うWebサイトも増えてきた。ただ、文字種を増やさなくても、文の形をした長いパスワードをつけるだけでも安全になるため、米国標準技術協会が発行するガイドラインでは、2017年の改定で「異なる文字種を組み合わせる規則や定期変更の強制は推奨しない」という内容に変更されている。

### 5.1.2 パスワード認証を狙った攻撃への対策
- ブルートフォース攻撃への対策としては、アカウントロックが有効

#### 基本的なアカウントロック
- アカウントロックは以下のように実装する
  - ユーザーID毎にパスワード間違いの回数を数える
  - パスワード間違いの回数が上限値を超えると、アカウントをロックする。ロックされたアカウントはログインできなくなる
  - アカウントロックが発生した場合はメールなどで対象利用者と管理者に通知する
  - 正常にログインした場合は、パスワード間違いのカウンタをクリアする
- ロックされたアカウントの再有効化は以下のルールで行うと良い
  - アカウントロックから30分経過した場合、自動的に再有効化される
  - 管理者が、なんらかの方法で本人確認した後に再有効化する

#### パスワード認証に対する攻撃のバリエーションと対策
- 攻撃の種類
  - 辞書攻撃
  - ジョーアカウント探索
  - リバースブルートフォース攻撃
  - パスワードスプレー攻撃
  - パスワードリスト攻撃
- パスワードを狙った攻撃への対策
  - 二段階認証の実装
  - 積極的なパスワードチェック
  - ログイン失敗率の監視

### 5.1.3 パスワードの保存方法
#### パスワードの保護の必要性
- パスワードが悪用されると、情報漏洩以外の被害が発生する可能性がある。そのため、SQLインジェクションなどによりDBの情報が漏洩しても、パスワードだけは悪用されない形で保護すべきである。

#### 暗号化によるパスワード保護と課題
- パスワードの暗号化においては、鍵の保管方法が課題になる。パスワードを暗号化することはあまり行われず、後述するメッセージダイジェストによる保護が広く行われている。

#### メッセージダイジェストによるパスワード保護と課題
- 任意長のデータを固定長のデータ（メッセージダイジェスト、あるいはハッシュ値）に圧縮する関数をハッシュ関数という。
- メッセージダイジェストによりパスワードが安全に保存できる。理由は、（暗号学的）ハッシュ関数の以下の特性によるものである。
  - ハッシュ値から元データを得ることが困難（一方向性）
  - 異なる入力から得られるハッシュ値が一致する確率が極めて低い（衝突耐性）
- しかし、ハッシュ値から元のパスワードを解析するための手法が知られている。
  - 脅威1: オフラインブルートフォース攻撃
  - 脅威2: レインボーテーブル
  - 脅威3: ユーザDB内にパスワード辞書を作られる
  - 脅威1はMD5やSHA-1より強力なハッシュ関数を使うことで対策にはなる？脅威2,3にはソルトを使った対策が有効。
- ハッシュ値からの解析をできるだけ困難にする方法として、基本的なものは以下の2つ
  - 対策1: ソルト
  - 対策2: ストレッチング

### 5.1.4 自動ログイン
- Webアプリによっては、「自動ログイン」あるいは「ログイン状態を保持する」というチェックボックスがついている。自動ログインを有効にしていると、ブラウザを再起動しても、自動的に再ログインされる。
- 従来、自動ログインはセキュリティ上の観点から好ましくないとされてきたが、筆者は、現状においては、サイトの性格によっては自動ログインを許容しても良いと考えている。理由は以下
  - Webの利用が浸透した結果、ログイン状態を継続することを前提としたサービスが増加した
  - 頻繁にログイン、ログアウトが要求されると、利用者が単純な（安全性の低い）パスワードをつけがちで、かえって危険度が増す

#### 危険な実装例
- クッキーにユーザ名と自動ログインのフラグを平文で設定しているパターン
- 上記の改良版として、クッキーにパスワードを設定しているパターン（XSS脆弱性があった場合、パスワードまで盗られる）

#### 自動ログインの安全な実装方法
- ログイン状態の保持機能を安全に実装する方法としては、以下の3種類が考えられる。
  - セッションの寿命を延ばす
  - トークンを使う
  - チケットを使う
    - 認証チケットは、認証情報をサーバーの外に持ち出せるようにしたもの。
- 上記3方式の中では、トークン方式が最も好ましいと考えられる。下記のメリットがある
  - 自動ログインを選択しない利用者に影響を与えない
  - 複数端末からログインしている場合に一斉にログアウトできる
  - 管理者が、特定利用者のログイン状態をキャンセルできる
  - クライアント側に秘密情報が渡らないので解析されるリスクがない

#### 自動ログインのリスクを低減するには
- 自動ログインのデメリットとして、認証状態が長く続くために、XSSやCSRFなどの受動的攻撃のリスクが高まることがある。これに対しては、重要情報の閲覧や重要処理に先立ちパスワード入力を要求する（再認証）方法がある。

### 5.1.5 ログインフォーム
- ログインフォームについての一般的なガイドラインは以下の通り。
  - パスワード入力欄はマスク表示する
  - HTTPSを利用する
- 入力欄表示ページもHTTPSにしないと以下の危険性がある
  - フォームが改竄されていて、入力値の送信先が別のサイトになっている危険性
  - 公衆無線LANの偽アクセスポイント経由で偽物のサイトを表示している可能性

### 5.1.6 エラーメッセージの要件
#### IDとパスワードのどちらが間違いか分かるとまずい理由
- エラーメッセージ次第で、ブルートフォース攻撃や辞書攻撃の効率が全く違ってくる。
  - 例えば、攻撃者がIDとパスワードを入力して、仮に存在するIDがわかったら、そのIDに対するパスワードの探索ができてしまう。
- ログイン失敗のエラーメッセージは以下のようにする
  `「IDまたはパスワードが違うか、アカウントがロックされています」`

#### IDとパスワードを二段階で入力するサイトの増加
- IDとパスワードを二段階で入力させるサイトが増えたが、これはユーザへの負担を減らし、複雑なパスワードをつけるように誘導していると言える。ユーザへの負担が増えれば増えるほど安易なパスワードをつける傾向になることへの反省とも考えられる。このようにする場合は、リスク増加にならないよう慎重な設計が求められる。

### 5.1.7 ログアウト機能
- ログアウト処理の要件は以下の通り。
  - ログアウト処理は副作用があるのでPOSTメソッドでリクエストする
  - ログアウト処理ではセッションを破棄する
  - 必要な場合、CSRF対策の対象とする

### 5.1.8 認証機能のまとめ
- 現在主流の認証方式であるパスワード認証のセキュリティ強度を高める施策には以下がある
- パスワードの文字種と桁数の要件
  - パスワードの文字種と桁数の要件参照
  - 積極的なパスワードポリシーのチェック参照
- ブルートフォース攻撃への対策
  - 5.1.2 パスワード認証を狙った攻撃への対策参照
- パスワードの保存方法
  - 5.1.3 パスワードの保存方法参照
- 入力画面とエラーメッセージの要件
  - 5.1.5 ログインフォームの要件参照
  - 5.1.6 エラーメッセージの要件参照

## 5.2 アカウント管理
### 5.2.1 ユーザ登録
- ユーザ登録におけるセキュリティ上の注意点
  - メールアドレスの受信確認
  - ユーザIDの重複防止
  - ユーザの自動登録への対処（任意）
  - パスワードに関する注意
- ユーザ登録処理に混入しやすい脆弱性は以下
  - SQLインジェクション脆弱性
  - メールヘッダ・インジェクション脆弱性

#### メールアドレスの受信確認
- メールアドレス登録・変更の際には、登録されたメールアドレスに送信されるメールを利用者自身が受信できることを確認する。以下の方法がある。
  - メールにトークンつきURLを添付して、そのURLから処理を継続する（方法A）
  - メールアドレスを入力した後、トークン（確認番号）入力画面に遷移する。トークンは、指定したメールアドレスにメール送信される（方法B）

#### ユーザIDの重複防止

#### ユーザの自動登録への対処
- CAPTCHAによる自動登録対策
  - Googleが開発したreCAPTCHAも広く使われている。

### 5.2.2 パスワード変更
- パスワード変更の機能的な注意点としては以下がある。
  - 現在のパスワードを確認する　-> セッションハイジャックされた状態におけるパスワード変更対策
  - パスワード変更時にはメールでその旨を通知する
  - 管理者が設定したパスワードやIoT製品などの初期パスワードは利用者の初回ログイン時にパスワード変更に誘導する
- パスワード変更機能に生じやすい脆弱性としては以下がある
  - SQLインジェクション脆弱性
  - CSRF脆弱性

### 5.2.3 メールアドレスの変更
#### メールアドレス変更に必要な機能的対策
- 新規メールアドレスに対する受信確認（【メールアドレスの受信確認】参照）
- 再認証（5.2.2参照）
- メール通知（新旧両方のアドレスに対して行う）

### 5.2.4 パスワードリセット
- パスワードリセットには、管理者向けのものと、利用者が自ら利用するものの2種類がある。後者についてはセキュリティ強度を下げる原因になり得るので、サイトの性質により実装の是非を検討する。

#### 管理者向けパスワードリセット機能
- 利用者からの問い合わせでパスワードをリセットする場合、以下の順序で運用を行う
  1. 問い合わせを受け付け、利用者の本人確認を行う
  2. 管理者がパスワードをリセットし、利用者に仮パスワードを伝える
  3. 利用者は仮パスワードでログインし、直ちにパスワードを変更する
- 管理者向けパスワードリセット機能の要件は以下の通り
  - 本人確認お際に照会する情報表示機能（本人確認は電話か書面などで）
  - 仮パスワード発行機能。仮パスワードは画面表示せずメールで利用者に送信される
  - 仮パスワードではパスワードの変更のみができる

#### 利用者向けパスワードリセット機能
- 本人確認の方法
  - 登録済みメールアドレスに加えて、二段階認証用アプリを使うとよい
  - ただ、上記は成りすましのリスクがあるので、そのリスクが許容できる場合のみ実装すべき。
- パスワードの通知方法
  - パスワード通知処理については、「仮パスワードを発行してメールで通知する」方法か、「パスワード変更画面に直接遷移する」方法を推奨する。

### 5.2.5 アカウントの停止

### 5.2.6 アカウントの削除

### 5.2.7 アカウント管理のまとめ
- 各機能に共通する注意点として以下がある
  - ユーザが入力したメールアドレスは必ず受信確認を行う
  - 重要な処理に際して再認証
  - 重要な処理のメール通知
- アカウント管理に共通して混入しやすい脆弱性として以下がある。
  - SQLインジェクション脆弱性
  - CSRF脆弱性
  - メールヘッダ・インジェクション脆弱性（メールアドレスの登録・変更時）

## 5.3 認可
### 5.3.1 認可とは
- 認可とは、認証された利用者に権限を与えること

### 5.3.2 認可不備の典型例
- 情報リソースのURLを知っていると認証なしで情報が閲覧できる
- 情報リソースのIDを変更すると権限外の情報が参照できる
- メニューの表示・非表示のみで制御している
- hiddenパラメータやクッキーに権限情報を保持している
- 上記4パターンに共通するのは、URLやhiddenパラメータ、クッキーを書き換えると権限を不正利用できるということがある。認可制御を正しく実装するためには、権限情報をセッション変数に保持することで書き換えできなくすることと、処理や表示の直前に権限の確認をすることが必要である。

### 5.3.3 認可制御の要件定義
- 認可制御を正しく実装するためには、まず認可制御のあるべき姿を要件として定義する必要がある。
- 認可制御の用件を定義するためには、権限マトリックスというものを作成する。

### 5.3.4 認可制御の正しい実装
- 認可制御の不備の原因の多くは、画面の制御のみで認可制御を実装しているつもりになっているところにある。正しい認可制御は、情報の操作に先立って以下を確認すること。
  - この機能を実行（画面を表示）してよいユーザであるか
  - リソースに対する操作（参照、変更、削除など）の権限はあるか
- ユーザ情報は、外部から書き換えできないセッション変数に保持する。（認可制御に限らず認証情報保持の原則。）
  - セッション変数に格納したユーザIDを基準に権限をチェックする
  - 権限情報をクッキーやhiddenパラメータなどに保持しない

## 5.4 ログ出力
### 5.4.1 ログ出力の目的
- ログがセキュリティ上も重要である理由は以下の3点である。
  - 攻撃や事故の予兆をログから把握し、早期に対策するため
  - 攻撃や事故の事後調査のため
  - アプリケーションの運用監査のため

### 5.4.2 ログの種類
- Webアプリケーションに関係するログには以下の種類がある
  - Webサーバー（Apacheなど）のログ
  - アプリケーションログ
  - データベースのログ
- アプリケーションログは、以下のように分類できる
  - エラーログ
  - アクセスログ
  - デバッグログ

### 5.4.3 ログ出力の要件
- ログに記録すべきイベント：　一般的には認証・アカウント管理や重要な情報や操作に関するイベントを記録する
- ログの出力項目：　4W1Hに従った項目を取得する
- ログの保護：　ログファイル自体に個人情報など機密情報を含めないようにするか、マスク処理する
- ログの出力先：　ログ専用のサーバーを用意するのが望ましい
- ログの保管期間
- サーバーの時刻合わせ：　複数ログを突き合わせられるように、各サーバーの時刻を同期する

### 5.4.4 ログ出力の実装
- ログ出力用のライブラリが開発されている

# chapter 6 文字コードとセキュリティ
## 6.1 文字コードとセキュリティの概要
- 文字コードとは、以下の2つの概念を合わせたものと考えられる。
  - 文字集合
  - 文字エンコーディング（文字符号化方式）

## 6.2 文字集合
- 文字集合とは、文字を集めたもの。（アルファベット大文字、数字は文字集合の例である。）
- 代表的な文字集合には、US-ASCII, ISO-8859-1, JIS X 0213, Unicodeなどがある。
- 異なる文字が同じコードに割り当てられる問題があり、このことが脆弱性の原因になる場合がある。

## 6.3 文字エンコーディング
- Shift_JIS
  - 先行バイトと後続バイトの分布が重なっていることに起因した文字列マッチングの誤動作が起こりうる。典型例は、0x5C「¥」による誤動作、いわゆる「5C」問題。
  - 不正なShift_JISエンコーディングが原因でXSS脆弱性となる場合がある。
- EUC-JP
- UTF-8: 現在ある文字エンコーディングの中で最も扱いやすく安全な方式と言えるが、特有の話題として非最短形式の問題には注意が必要。脆弱性が生まれる場合がある。
  - ファイル名チェックの例：　非最短形式のスラッシュ（0xC0 0xAF）を含むファイル名が、最短形式のスラッシュ（0x2F）をファイル名に含むか否かのセキュリティチェックをすり抜ける。その後に非最短形式のスラッシュをShift_JISに変換すると、通常のスラッシュに変換されるため、「/」を含むファイル名でオープンされてしまう。
- UTF-8の最新規格では非最短形式は不正であり処理してはならないとされている。しかし、処理系によっては非最短形式を許容している場合もあるので注意が必要。

## 6.4 文字コードによる脆弱性の発生要因まとめ
- 文字コードに起因する脆弱性については以下の3つのタイプに分類される
  - 文字エンコーディングとして不正なバイト列による脆弱性
  - 文字エンコーディングの扱いの不備による脆弱性
  - 文字集合の変更に起因する脆弱性
    - Unicodeの円記号「¥」を他の文字集合に変更した際に、処理系によってはバックスラッシュに変換されるために起こる脆弱性など

## 6.5 文字コードを正しく扱うために
- 文字コードを正しく扱うためには、以下の4つのポイントがある。
  - アプリケーション全体を通して文字集合を統一する
  - 入力時に不正な文字エンコーディングをエラーにする
  - 処理の中で文字エンコーディングを正しく扱う
    - マルチバイト文字に対応した処理系・関数のみを使う
    - 関数の引数として文字エンコーディングを明示する
  - 出力時に文字エンコーディングを正しく指定する
    - HTTPレスポンスヘッダのContent-Typeで文字エンコーディングを正しく指定する
    - データベースの文字エンコーディングを正しく指定する
      - BMP外の文字の文字化けを避けるために、列の文字エンコーディングとしてutf8mb4を指定するとよい
      - DBの文字コード設定は、「尾骶骨テスト」や「𠮷テスト」で確認する。（骶はJIS第三水準、𠮷はUTF-8の4バイト文字）
    - その他、文字エンコーディングの指定が必要な箇所は漏れなく指定する
  - その他の対策：文字エンコーディングの自動判定を避ける

## 6.6 まとめ
- 文字化けがあるかどうかの検証として、下記を確認すべき
  - 不正な文字エンコーディングではエラーになるか代替文字（U+FFFD）に変換されること
  - 「表」や「ソ」、「能」などが正しく登録・表示されること
  - 「尾骶骨テスト」と「つちよしテスト」をクリアすること
- 対策のまとめ
  - アプリケーション全体を通して文字集合をUnicodeで統一する
  - 入力時に不正な文字エンコーディングをエラーにする
  - 処理の中で文字エンコーディングを正しく扱う
  - 出力時に文字エンコーディングを正しく指定する

# chapter 7 脆弱性診断入門
## 7.1 脆弱性診断の概要
- Webサイトに対する脆弱性診断には大別してプラットフォーム診断とアプリケーション診断がある。
- プラットフォーム診断は、Webサイトを構築するサーバーやネットワーク機器などに既知の脆弱性がないか調べるもの。通常は診断用のツール（脆弱性スキャナ）を用いて診断する。本書ではNmap, OpenVASを使う。
- アプリケーション診断とは、Webアプリケーションに対して未知の脆弱性がないかを確認するもの。アプリケーション診断には、大別して動的診断とソースコード診断がある。動的診断はWebアプリを実際に動かすことによる診断、ソースコード診断はアプリケーションを動かさずにソースコードを確認することによる診断。

## 7.2 脆弱なサンプルアプリケーションBad Todo

## 7.3 診断ツールのダウンロードとインストール
- OWASP ZAP
- Nmap
- OpenVAS
- RIPS

## 7.4 Nmapによるポートスキャン

## 7.5 OpenVASによるプラットフォーム脆弱性診断

## 7.6 OWASP ZAPによる自動脆弱性スキャン

## 7.7 OWASP ZAPによる手動脆弱性診断

## 7.8 RIPSによるソースコード診断

## 7.9 脆弱性診断実施上の注意

## 7.10 まとめ

## 7.11 脆弱性診断報告書のサンプル

# chapter 8 Webサイトの安全性を高めるために
## 8.1 Webサーバーへの攻撃経路と対策
### 8.1.1 基盤ソフトウェアの脆弱性をついた攻撃
- OSやWebサーバーなどの基盤ソフトウェアの脆弱性をついた攻撃により、不正侵入を受ける場合がある。

### 8.1.2 不正ログイン
- Webサーバーの管理に用いるソフトウェア（SSHサーバーなど）に対するパスワード攻撃は頻繁に行われている。

### 8.1.3 対策
- 適切なサーバー基盤を選定する
- 機能提供に不要なソフトウェアは稼働させない
- 脆弱性の対処をタイムリーに行う
- 一般公開する必要のないポートやサービスはアクセス制限する
- 認証の強度を高める

#### 適切なサーバー基盤を選定する
- クラウドサービスを利用する場合は、セキュリティに対する責任を事業者と利用者が分かち合っていて、自分の責任範囲がどこまでかをよく確認した上で、サービスを剪定することが重要。

#### 機能提供に不要なソフトウェアは稼働させない

#### 脆弱性の対処をタイムリーに行う
- 上流設計時に以下を確認・決定する
  - サポートの期限を確認する
  - パッチ適用の方法を決定する
- 運営開始後は以下を行う
  - 脆弱性情報を監視する
    - 脆弱性情報に関する信頼性の高いサイトとして以下がある
      - [JVN](http://jvn.jp/)
      - [JVN iPedia](http://jvndb.jvn.jp/)
  - 脆弱性を確認したらパッチの提供状況や回避策を調べ、対処計画を立てる
  - 脆弱性対処を実行する

#### 一般公開する必要のないポートやサービスはアクセス制限する
- SSHやFTPなど様々なポートに対する無差別攻撃への対応として以下の方法がある
  - 外部からは専用線かVPN経由でのみ接続する
  - 特定のIPアドレスからのみ接続を許すように制限する
- ポートスキャンでアクセス制限の状態を確認する

#### 認証の強度を高める
- 管理用のソフトウェアの認証の強度を高めるために、以下を推奨する
  - TelnetサーバーとFTPサーバーを削除あるいは停止し、SSH系サービスのみ稼働させる
  - SSHサーバーの設定によりパスワード認証を停止し、公開鍵認証のみとする
  - クラウドサービスの管理者アカウントは担当者毎に割り当て、可能ならば二段階認証を設定する

## 8.2 成りすまし対策
- 成りすましは、正規サイトに成りすました偽のWebサイトに利用者が誘導され、サイト改竄や情報漏洩に使われるもの。

### 8.2.1 ネットワーク的な成りすましの手口
- DNSに対する攻撃
- ARPスプーフィング

#### DNSに対する攻撃
- 具体的な攻撃手段として以下がある。
  - ドメイン名を管理販売するレジストリやレジストラを狙った攻撃
  - DNSサーバーに対する攻撃によりDNSの設定内容を書き換える
  - DNSキャッシュポイズニング攻撃
  - 失効したドメイン名を第三者が購入して悪用する

#### ARPスプーフィング
- ARPスプーフィングとは、ARPの偽応答を返すことで、IPアドレスを偽装する手法のこと。

### 8.2.2 フィッシング
- フィッシング（Phishing）とは、正規サイトにそっくりな入力画面を用意してメールなどで利用者を誘導し、IDとパスワードや個人情報などを入力させて盗み取る手法のこと。
- 原則としては利用者側で注意すべきものだが、Webサイト側でできる対策もある。

### 8.2.3 Webサイトの成りすまし対策
- ネットワーク的な対策
- TLSの導入
- 確認しやすいドメイン名の採用

#### ネットワーク的な対策
- 以下の対策を勧める
  - 同一セグメント内に脆弱なサーバーを置かない
  - DNS運用の強化

#### TLSの導入
- TLSは、一般的に通信回線の暗号化機能と理解されるが、もう1つの重要な機能として、第三者機関（CA）によるドメイン名の正当性の証明がある。適切に使えば、Webサーバーに対する成りすましを防ぐことができる。
- Webサイト運営者の立場でTLSを正しく運営するための第一歩は、正規のサーバー証明書を購入して導入すること。

#### 確認しやすいドメイン名の採用

## 8.3 盗聴・改ざん対策
### 8.3.1 盗聴・改ざんの経路
- 無線LANの盗聴・改ざん
- ミラーポートの悪用
- プロキシサーバーの悪用
- 偽のDHCPサーバー
- ARPスプーフィングとDNSキャッシュポイズニング

### 8.3.2 中間者攻撃

### 8.3.3 対策
- 通信の盗聴・改ざんを防ぐには、正規の証明書を導入してTLSを運用することに尽きる。さらに、以下の注意点がある。

#### TLS利用時の注意点
- 入力画面からHTTPSにする
- クッキーのセキュア属性に注意
- 画像やCSS、JavaScriptなどもHTTPSで指定する
- frame, iframeを使わない
- ブラウザのデフォルト設定でエラー表示されないようにする
- アドレスバーを隠さない
- ステータスバーを隠さない
- コンテキストメニュー（右クリックメニュー）を無効化しない

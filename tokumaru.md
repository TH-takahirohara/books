徳丸本

## 3.1 HTTPとセッション管理
### 入力 - 確認 - 登録パターン

####  Referer
リクエストメッセージにRefererと言うヘッダがつくことがある。これは、リンク元のURLを示すヘッダで、form要素によるフォーム送信時などにつく。
Refererがセキュリティ上の問題になるのは、URLが秘密情報を含んでいる場合。外部に漏洩したら、成りすましに悪用される可能性がある。4.6.3項で詳しく説明する。

#### GETと POSTの使い分け
- 以下が1つでも当てはまる場合はPOSTを使う
  - データ更新など副作用を伴うリクエストの場合
  - 秘密情報を送信する場合
  - 送信するデータの総量が多い場合

#### hidden
hiddenパラメータは利用者自身によって書き換えできる。
hiddenパラメータのメリットは、hiddenは利用者自身からは書き換えできるが、情報漏洩や第三者からの書き換えに対しては堅牢であるということ。
利用者自身によっても書き換えられては困る認証認可に関する情報はセッション変数に保存すべきだが、それ以外の情報は、まずはhiddenパラメータに保存することを検討すると良い。

#### ステートレスなHTTP認証

- 認証と認可（5.1, 5.3で詳しく説明）
  - 認証：利用者が確かに本人であることを何らかの手段で確認すること
  - 認可：認証済みの利用者に（データの参照などの）権限を与えること
  - IDとパスワードを入力して認証されると、即座に権限が与えられる場合がほとんどである。ただ、開発やセキュリティを考える上では区別して理解すべきである。

### クッキーとセッション管理

#### クッキーによるセッション管理
- アプリケーションデータを保持する目的でクッキーそのものに値を入れることは、主に2つの理由であまりない。
- クッキーには「整理番号」としてのセッションIDを格納しておき、実際の値はサーバー側で管理する方法が広く用いられている。これをクッキーによるセッション管理と呼ぶ。
- セッションIDに求められる要件は以下の通り。
  1. 第三者がセッションIDを推測できないこと
  2. 第三者からセッションIDを強制されないこと
  3. 第三者にセッションIDが漏洩しないこと

- 1.について　セッションIDを推測できると、推測した値で成りすましができる。そのため、セッションIDは十分な桁数の乱数を使う。ただし、**セッション管理機構は自作しない**。世に出ている開発ツールで提供されるセッション管理機構は、脆弱性があった場合はすぐに改善されているはずなので、基本的にこちらを使うこと。「4.6 セッション管理の不備」で詳しく扱う。
- 2.は、セッションIDの固定化攻撃への対策。これは、**認証後にセッションIDを変更することで対策できる**。

#### セッションID漏洩について
- 漏洩について、ネットワーク盗聴から保護するにはTLSによる暗号化が有効。
- クッキーを発行する際の属性として、**Domain属性は原則として設定しない**。（脆弱性の原因になりうるため。）
- クッキーモンスターバグ
- クッキーのSecure属性
- クッキーのHttpOnly属性
  - JSを悪用したXSS攻撃によるクッキーを盗み出す攻撃を防ぐことができる。

## 3.2 受動的攻撃と同一オリジンポリシー
### 能動的攻撃と受動的攻撃
#### 受動的攻撃
- 受動的攻撃は、Webサイトの利用者に罠を仕掛けることにより、罠を閲覧したユーザーを通してアプリケーションを攻撃する手法のこと。単純なものから3パターン説明。
- 単純な受動的攻撃
  - 罠サイトに誘導し、マルウェアに感染させる
- 正規サイトを悪用する受動的攻撃
  - 正規サイトを攻撃し、コンテンツに仕掛けを仕込む。正規サイトの利用者が仕掛けを含むコンテンツを閲覧すると、マルウェア感染などが起こる
- サイトをまたがった受動的攻撃

### ブラウザはどのように受動的攻撃を防ぐか
#### サンドボックスという考え方
- 利用者のブラウザで悪意のあるプログラムが動かないように、JavaScriptなどは安全性を高めるための機能を提供している。基本的な考え方は2種類ある。
  - 利用者に配布元を確認させた上で、利用者が許可した場合のみ実行する
  - プログラムの「できること」を制限するサンドボックスという環境を用意する
- サンドボックスでは、以下のように機能が制限される。
  - ローカルファイルへのアクセスの禁止
  - プリンタなどの資源の利用禁止（画面表示は可能）
  - ネットワークアクセスの制限（同一オリジンポリシー）

#### 同一オリジンポリシー
- 同一オリジンポリシーとは、JavaScriptなどのクライアントスクリプトからサイトをまたがったアクセスを禁止するセキュリティ上の制限であり、ブラウザのサンドボックスに用意された制限の1つである。
- ブラウザには同一オリジンポリシーがあるが、アプリケーションに脆弱性があるとXSSなどの受動的攻撃を受ける場合がある。

### JavaScript以外のクロスドメインアクセス

## 3.3 CORS(Cross-Origin Resource Sharing)
### シンプルなリクエスト
- 異なるオリジンと「シンプルなリクエスト」でデータのやりとりをしようとすると、Access-Control-Allow-Originヘッダがレスポンスにない場合はエラーになる。
- Access-Control-Allow-Origin
  - クロスオリジンからの読み出しを許可するための仕掛けで、情報の提供元（サーバー側）がHTTPレスポンスヘッダとして出力する。
- 「シンプルなリクエスト」はHTMLフォームから送られるリクエストを基準として条件が設定される。

### プリフライトリクエスト
- クロスオリジンアクセスにおいて「シンプルなリクエスト」の条件を満たさない場合、ブラウザは、プリフライトリクエストというHTTPリクエストを送信する。
- プリフライトリクエストで、本来のリクエストを送る前に、Access-Control-Request-Methodヘッダーなどのヘッダを含むリクエストをOPTIONSメソッドで送信する。サーバー側は、レスポンスにAccess-Control-Allow-Methodsヘッダなどをつけて返さないと、ブラウザ側でエラーが出る。

### 認証情報を含むリクエスト
- クッキーなどの認証用のヘッダを伴うクロスオリジンリクエストは、下記の両方を満たす必要がある。
  - XMLHttpRequestオブジェクトのwithCredentialsプロパティをtrueにする
  - レスポンスヘッダとしてAccess-Control-Allow-Credentials: trueを返す

# Chapter 4 Webアプリケーションの機能別に見るセキュリティバグ
## 4.1 Webアプリケーションの機能と脆弱性の対応
### 脆弱性はどこで発生するのか
- 脆弱性には処理に起因するものと出力に起因するものがある
- 入力に起因する脆弱性はない
- 出力に起因する脆弱性には「インジェクション」という単語がつくものが多い

### インジェクション系脆弱性とは
- インジェクション系脆弱性が発生する原因は、Webアプリケーション側が「データ」を想定しているところに、引用符やデリミタなど「データの終端」を示すマークを混入させて、その後の文字列（SQL文など）の構造を変化させるところにある。

## 4.2 入力処理とセキュリティ
- 入力値のチェックで、根本的な対策に穴があった場合の実害を防ぐ、あるいは軽減できる場合がある。

### Webアプリケーションの「入力」では何をするか
- 入力処理では、入力値に対して以下の処理を行う。
  1. 文字エンコーディングの妥当性検証
  2. 文字エンコーディングの変換（必要な場合のみ）
  3. 入力値（パラメータ文字列）の妥当性検証
- 文字エンコーディングについては6章で詳しく説明

### 入力値の検証
- 入力値検証の目的
  - 入力値の間違いを早期に発見して再入力を促すことにより、ユーザビリティを向上する
  - 間違った処理を継続することによるデータの不整合などを防ぎ、システムの信頼性を向上させる

#### 入力値検証とセキュリティ
- 入力値検証の主目的はセキュリティのためではないが、セキュリティのために役立つ場合もある。

#### バイナリセーフという考え方とヌルバイト攻撃
- ヌルバイトを使った攻撃手法が知られており、ヌルバイト攻撃と呼ばれる。他の脆弱性の対策をかいくぐるために悪用される。
  - バイナリセーフでない関数は、検査対象文字列にヌルバイトがあると、そこで文字列が終わっていると判断することをつかれる。
- 対策としては、アプリケーションの入り口でバイナリセーフの関数を用いて入力値のヌルバイトをチェックし、ヌルバイトがあればエラーにすることにより確実な対応が可能になる。

#### 入力値検証だけでは対策にならない
- あくまでも入力値検証は保険的対策としてとらえるべき。後述のように入力値検証はアプリケーションの仕様が基準となるため。

#### 入力値検証の基準はアプリケーション要件
- 制御文字のチェック
  - 1行テキストボックスには、通常の入力方法では制御文字は入力できないので、制御文字はすべて拒絶できる場合が多い。
- 文字数のチェック
- 数値の最小値・最大値のチェック
  - 以下を行うと良い
    - 数値文字列としての文字種・文字数のチェック
    - 文字列型から数値型への型変換
    - 最小値・最大値の範囲にあることの確認
- その他の注意点 その他の問題として以下がある。
  - 入力項目が指定されていない（項目自体がない）ケース
  - 配列形式で入力されているケース
    - スカラー値を期待したプログラムに入力値として配列が指定されると思わぬエラーになる場合がある。
    - PHPではfilter_input関数で入力値検証を簡潔に記述できる。

#### 正規表現による入力値検証の例　英数字１〜５文字
- u修飾子
- i修飾子
- データの先頭は\A、データの末尾は\zで示す。

#### 正規表現による入力値検証の例　住所欄
- 住所欄のような文字種の制限がない場合でも、制御文字が混入していないというチェックをすべき。
- POSIX文字クラスによる制御文字以外の指定

### まとめ
- 入力値検証の実施手順
  - 設計段階で各パラメータの文字種および最大文字数、最小値・最大値を仕様として決める
  - 設計段階で入力値検証の実装方針を決める
  - 開発段階では仕様に従い入力値検証を実装する。

## 4.3 表示処理に伴う問題
- この節では、サーバー側処理で起こるXSSを扱う。

### 4.3.1 クロスサイト・スクリプティング（基本編）
#### 概要
- 通常、Webアプリケーションには外部からの入力などに応じて表示が変化する箇所があり、この部分のHTML生成の実装に問題があると、XSSという脆弱性が生じる。
- XSS脆弱性がある場合には、以下の影響がある。
  - サイト利用者のブラウザ上で、攻撃者の用意したスクリプトの実行によりクッキー値を盗まれ、利用者が成りすましの被害にあう
  - 同じくブラウザ上でスクリプトを実行させられ、サイト利用者の権限でWebアプリケーションの機能を悪用される
  - Webサイト上に偽の入力フォームが表示され、フィッシングにより利用者が個人情報を盗まれる

#### XSS脆弱性のまとめ
- 発生箇所
  Webアプリケーション上でHTML、JavaScriptを生成している箇所
- 影響を受けるページ
  Webアプリケーション全体が影響を受ける
- 影響の種類
  Webサイト利用者のブラウザ上でのJavaScriptの実行、偽情報の表示
- 影響の度合い
  中〜大
- 利用者関与の度合い
  必要 -> 罠サイトの閲覧、メール記載のURLの起動、攻撃を受けたサイトの閲覧など
- 対策の概要
  - 属性値はダブルクォートで囲む
  - HTMLで特別な意味を持つ記号文字をエスケープする

#### 攻撃手法と影響
- XSSの悪用の方法3種類
  - クッキー値の盗み出し
  - その他のJavaScriptによる攻撃
  - 画面の書き換え

- 反射型XSSと持続型XSS
  - 攻撃用JSが、攻撃対象サイトと別のサイトにある場合を反射型XSSと言う。反射型のXSSは、多くの場合入力値をそのまま表示するページで発生する。
  - 攻撃用のJSが、攻撃対象のデータベースなどに保存される場合がある。その場合のXSSを持続型XSSと呼ぶ。WebメールやSNSなどが典型的な攻撃ターゲットである。

#### 脆弱性が生まれる原因
- XSS脆弱性が生じる原因は、HTML生成の際に、HTMLの文法上特別な意味を持つ特殊記号を正しく扱っていないことであり、それにより、開発者の意図しない形でHTMLやJavaScriptを注入・変形される現象がXSSである。
- HTMLのエスケープは、XSS解消のためには非常に重要である。

#### 必須対策
- 要素内容については「<」と「&」をエスケープする
  -> htmlspecialchars関数によりエスケープ
- 属性値については、ダブルクォートで囲って、「<」と「"」と「&」をエスケープする
  -> htmlspecialchars関数によりエスケープしてダブルクォートで囲む

#### 必須対策（共通対策）
- HTTPレスポンスに文字エンコーディングを明示する

#### XSSに対する保険的対策
- X-XSS-Protectionレスポンスヘッダの使用
  - これは、XSSフィルタというセキュリティ機能を上書きして有効化するヘッダ
  - すべてのHTTPレスポンスで以下を出力することを（筆者は）推奨する。
  `X-XSS-Protection: 1; mode=block`
- 入力値の検証　入力値の条件が英数字のみに限定できる場合などに限られる。
- クッキーにHttpOnly属性を付与する
- （TRACEメソッドの無効化）

### 4.3.2 クロスサイト・スクリプティング（発展編）
#### href属性やsrc属性のXSS
- href属性は、javascriptスキームによるXSSの対象になりうる。
- URLを生成する場合は、httpスキームとhttpsスキームで始まる絶対URLかスラッシュで始まる相対URLであるかをチェックする。
- リンク先ドメイン名のチェック

#### JavaScriptの動的生成
- イベントハンドラのXSS
  1. データをJavaScript文字列リテラルとしてエスケープする
  2. この結果をHTMLエスケープする
- script要素のXSS
- JavaScriptの文字列リテラルの動的生成の対策
  - 対策しづらいので、JSに動的パラメータを渡すときに利用できる方法2種類を紹介する。
  - script要素の外部でパラメータを定義して、JavaScriptから参照する方法
  - インラインJSONPによる方法

#### HTMLタグやCSSの入力を許す場合の対策
- HTMLテキストを構文解析して必要な要素のみを抽出するライブラリを使用することが望ましい。

### 4.3.3 エラーメッセージからの情報漏洩
- 以下の2種類がある。
  - エラーメッセージに攻撃者にとって有益なアプリケーションの内部情報が含まれる
  - 意図的な攻撃として、エラーメッセージに秘密情報を表示させられる
- 対策：エラー発生時に画面に表示するのは利用者向けのメッセージにとどめ、エラーの詳細はログに出力するようにする。

## 4.4 SQL呼び出しに伴う脆弱性
### 4.4.1 SQLインジェクション
#### 概要
- SQLインジェクションは、SQLの呼び出しかたに不備がある場合に発生する脆弱性。攻撃者が能動的に（利用者の関与なしで）サーバーを攻撃できる。
- 以下のような影響を受ける可能性がある。
  - データベース内のすべての情報が外部から盗まれる
  - データベースの内容が書き換えられる
  - 認証を回避される（IDとパスワードを用いずにログインされる）
  - その他、データベースサーバー上のファイルの読み出し、書き込み、プログラムの実行などを行われる
- 確実な対策は、静的プレースホルダを利用してSQLを呼び出すこと。

#### 攻撃手法と影響
- エラーメッセージ経由の情報漏洩
- UNION SELECTを用いた情報漏洩
- SQLインジェクションによる認証回避
- SQLインジェクション攻撃によるデータ改ざん
- その他の攻撃

#### 脆弱性が生まれる原因
- 典型的な原因はリテラルの扱いにある。
- 文字列リテラルの問題
  - シングルクォートなどを用いてリテラルからはみ出した文字列をSQL文として認識させ、アプリケーションが呼び出すSQL文を変更する手法がSQLインジェクション攻撃である。
- 数値項目に対するSQLインジェクション

#### 対策
- SQLインジェクション脆弱性を解消するためには、SQL文を組み立てる際にSQL文の変更を防ぐこと。方法としては
  1. プレースホルダによりSQL文を組み立てる
  2. アプリケーション側でSQL文を組み立てる際に、リテラルを正しく構成するなど、SQL文が変更されないようにする
- 1.の方法を著者は強く勧める。
- 静的プレースホルダと動的プレースホルダの違い
  - 原理的にSQLインジェクションの可能性がないという点で静的プレースホルダの方が優れている。
- SQLインジェクションの保険的対策
  - 詳細なエラーメッセージの抑止
  - 入力値の妥当性検証
  - データベースの権限設定

#### さらに進んだ学習のために
- エスケープすべき文字の詳細、文字エンコーディングの影響については、「安全なSQLの呼び出し方」を参照

## 4.5 「重要な処理」の際に混入する脆弱性
### 4.5.1 クロスサイト・リクエストフォージェリ（CSRF）
#### 概要
- 「重要な処理」の受付に際して必要となる、利用者の意図したリクエストであることの確認処理が抜けていると、罠のサイトなどを閲覧しただけで、利用者のブラウザから勝手に「重要な処理」を実行させられる場合がある。このような問題を引き起こす脆弱性をCSRFと呼ぶ。
- 影響の例
  - 利用者のアカウントによる物品の購入
  - 利用者の退会処理
  - 利用者のアカウントによるSNSや問い合わせフォームなどへの書き込み
  - 利用者のパスワードやメールアドレスの変更
- CSRF脆弱性の影響は、アプリケーションの「重要な処理」の悪用に限られ、被害者である利用者の個人情報などを盗むことはできない。
- 対策は、「重要な処理」を実行する前に、利用者の意図したリクエストであることを確認すること。

#### 攻撃手法と影響
- 入力-実行パターンのCSRF攻撃
- 確認画面がある場合のCSRF攻撃
- ファイルアップロードフォームでのCSRF攻撃

#### 脆弱性が生まれる原因

#### 対策
- 以下の二点を実施する
  - CSRF対策の必要なページを区別する
  - 正規利用者の意図したリクエストを確認できるように実装する
- CSRF対策の必要なページを区別する
  - ECサイトにおける物品購入など、他のサイトから勝手に実行されると困るページには、CSRF対策を施す。
  - 開発プロセスでは下記のようにする
    - 要件定義工程で機能一覧を作成し、CSRF対策の必要な機能にマークする
    - 基本設計工程で画面遷移図を作成し、CSRF対策の必要なページにマークする
    - 開発工程でCSRF対策を作りこむ
- 正規利用者の意図したリクエストであることを確認する
  - 具体的な方法は3種類が知られている
    - 秘密情報（トークン）の植え込み
    - パスワード再入力
    - Refererのチェック
- 保険的対策
  - 「重要な処理」の実行後に、登録済みメールアドレスに通知メールを送信する

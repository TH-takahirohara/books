徳丸本

## 3.1 HTTPとセッション管理
### 入力 - 確認 - 登録パターン

####  Referer
リクエストメッセージにRefererと言うヘッダがつくことがある。これは、リンク元のURLを示すヘッダで、form要素によるフォーム送信時などにつく。
Refererがセキュリティ上の問題になるのは、URLが秘密情報を含んでいる場合。外部に漏洩したら、成りすましに悪用される可能性がある。4.6.3項で詳しく説明する。

#### GETと POSTの使い分け
- 以下が1つでも当てはまる場合はPOSTを使う
  - データ更新など副作用を伴うリクエストの場合
  - 秘密情報を送信する場合
  - 送信するデータの総量が多い場合

#### hidden
hiddenパラメータは利用者自身によって書き換えできる。
hiddenパラメータのメリットは、hiddenは利用者自身からは書き換えできるが、情報漏洩や第三者からの書き換えに対しては堅牢であるということ。
利用者自身によっても書き換えられては困る認証認可に関する情報はセッション変数に保存すべきだが、それ以外の情報は、まずはhiddenパラメータに保存することを検討すると良い。

#### ステートレスなHTTP認証

- 認証と認可（5.1, 5.3で詳しく説明）
  - 認証：利用者が確かに本人であることを何らかの手段で確認すること
  - 認可：認証済みの利用者に（データの参照などの）権限を与えること
  - IDとパスワードを入力して認証されると、即座に権限が与えられる場合がほとんどである。ただ、開発やセキュリティを考える上では区別して理解すべきである。

### クッキーとセッション管理

#### クッキーによるセッション管理
- アプリケーションデータを保持する目的でクッキーそのものに値を入れることは、主に2つの理由であまりない。
- クッキーには「整理番号」としてのセッションIDを格納しておき、実際の値はサーバー側で管理する方法が広く用いられている。これをクッキーによるセッション管理と呼ぶ。
- セッションIDに求められる要件は以下の通り。
  1. 第三者がセッションIDを推測できないこと
  2. 第三者からセッションIDを強制されないこと
  3. 第三者にセッションIDが漏洩しないこと

- 1.について　セッションIDを推測できると、推測した値で成りすましができる。そのため、セッションIDは十分な桁数の乱数を使う。ただし、**セッション管理機構は自作しない**。世に出ている開発ツールで提供されるセッション管理機構は、脆弱性があった場合はすぐに改善されているはずなので、基本的にこちらを使うこと。「4.6 セッション管理の不備」で詳しく扱う。
- 2.は、セッションIDの固定化攻撃への対策。これは、**認証後にセッションIDを変更することで対策できる**。

#### セッションID漏洩について
- 漏洩について、ネットワーク盗聴から保護するにはTLSによる暗号化が有効。
- クッキーを発行する際の属性として、**Domain属性は原則として設定しない**。（脆弱性の原因になりうるため。）
- クッキーモンスターバグ
- クッキーのSecure属性
- クッキーのHttpOnly属性
  - JSを悪用したXSS攻撃によるクッキーを盗み出す攻撃を防ぐことができる。

## 3.2 受動的攻撃と同一オリジンポリシー
### 能動的攻撃と受動的攻撃
#### 受動的攻撃
- 受動的攻撃は、Webサイトの利用者に罠を仕掛けることにより、罠を閲覧したユーザーを通してアプリケーションを攻撃する手法のこと。単純なものから3パターン説明。
- 単純な受動的攻撃
  - 罠サイトに誘導し、マルウェアに感染させる
- 正規サイトを悪用する受動的攻撃
  - 正規サイトを攻撃し、コンテンツに仕掛けを仕込む。正規サイトの利用者が仕掛けを含むコンテンツを閲覧すると、マルウェア感染などが起こる
- サイトをまたがった受動的攻撃

### ブラウザはどのように受動的攻撃を防ぐか
#### サンドボックスという考え方
- 利用者のブラウザで悪意のあるプログラムが動かないように、JavaScriptなどは安全性を高めるための機能を提供している。基本的な考え方は2種類ある。
  - 利用者に配布元を確認させた上で、利用者が許可した場合のみ実行する
  - プログラムの「できること」を制限するサンドボックスという環境を用意する
- サンドボックスでは、以下のように機能が制限される。
  - ローカルファイルへのアクセスの禁止
  - プリンタなどの資源の利用禁止（画面表示は可能）
  - ネットワークアクセスの制限（同一オリジンポリシー）

#### 同一オリジンポリシー
- 同一オリジンポリシーとは、JavaScriptなどのクライアントスクリプトからサイトをまたがったアクセスを禁止するセキュリティ上の制限であり、ブラウザのサンドボックスに用意された制限の1つである。
- ブラウザには同一オリジンポリシーがあるが、アプリケーションに脆弱性があるとXSSなどの受動的攻撃を受ける場合がある。

### JavaScript以外のクロスドメインアクセス

## 3.3 CORS(Cross-Origin Resource Sharing)
### シンプルなリクエスト
- 異なるオリジンと「シンプルなリクエスト」でデータのやりとりをしようとすると、Access-Control-Allow-Originヘッダがレスポンスにない場合はエラーになる。
- Access-Control-Allow-Origin
  - クロスオリジンからの読み出しを許可するための仕掛けで、情報の提供元（サーバー側）がHTTPレスポンスヘッダとして出力する。
- 「シンプルなリクエスト」はHTMLフォームから送られるリクエストを基準として条件が設定される。

### プリフライトリクエスト
- クロスオリジンアクセスにおいて「シンプルなリクエスト」の条件を満たさない場合、ブラウザは、プリフライトリクエストというHTTPリクエストを送信する。
- プリフライトリクエストで、本来のリクエストを送る前に、Access-Control-Request-Methodヘッダーなどのヘッダを含むリクエストをOPTIONSメソッドで送信する。サーバー側は、レスポンスにAccess-Control-Allow-Methodsヘッダなどをつけて返さないと、ブラウザ側でエラーが出る。

### 認証情報を含むリクエスト
- クッキーなどの認証用のヘッダを伴うクロスオリジンリクエストは、下記の両方を満たす必要がある。
  - XMLHttpRequestオブジェクトのwithCredentialsプロパティをtrueにする
  - レスポンスヘッダとしてAccess-Control-Allow-Credentials: trueを返す

# Chapter 4 Webアプリケーションの機能別に見るセキュリティバグ
## 4.1 Webアプリケーションの機能と脆弱性の対応
### 脆弱性はどこで発生するのか
- 脆弱性には処理に起因するものと出力に起因するものがある
- 入力に起因する脆弱性はない
- 出力に起因する脆弱性には「インジェクション」という単語がつくものが多い

### インジェクション系脆弱性とは
- インジェクション系脆弱性が発生する原因は、Webアプリケーション側が「データ」を想定しているところに、引用符やデリミタなど「データの終端」を示すマークを混入させて、その後の文字列（SQL文など）の構造を変化させるところにある。

## 4.2 入力処理とセキュリティ
- 入力値のチェックで、根本的な対策に穴があった場合の実害を防ぐ、あるいは軽減できる場合がある。

### Webアプリケーションの「入力」では何をするか
- 入力処理では、入力値に対して以下の処理を行う。
  1. 文字エンコーディングの妥当性検証
  2. 文字エンコーディングの変換（必要な場合のみ）
  3. 入力値（パラメータ文字列）の妥当性検証
- 文字エンコーディングについては6章で詳しく説明

### 入力値の検証
- 入力値検証の目的
  - 入力値の間違いを早期に発見して再入力を促すことにより、ユーザビリティを向上する
  - 間違った処理を継続することによるデータの不整合などを防ぎ、システムの信頼性を向上させる

#### 入力値検証とセキュリティ
- 入力値検証の主目的はセキュリティのためではないが、セキュリティのために役立つ場合もある。

#### バイナリセーフという考え方とヌルバイト攻撃
- ヌルバイトを使った攻撃手法が知られており、ヌルバイト攻撃と呼ばれる。他の脆弱性の対策をかいくぐるために悪用される。
  - バイナリセーフでない関数は、検査対象文字列にヌルバイトがあると、そこで文字列が終わっていると判断することをつかれる。
- 対策としては、アプリケーションの入り口でバイナリセーフの関数を用いて入力値のヌルバイトをチェックし、ヌルバイトがあればエラーにすることにより確実な対応が可能になる。

#### 入力値検証だけでは対策にならない
- あくまでも入力値検証は保険的対策としてとらえるべき。後述のように入力値検証はアプリケーションの仕様が基準となるため。

#### 入力値検証の基準はアプリケーション要件
- 制御文字のチェック
  - 1行テキストボックスには、通常の入力方法では制御文字は入力できないので、制御文字はすべて拒絶できる場合が多い。
- 文字数のチェック
- 数値の最小値・最大値のチェック
  - 以下を行うと良い
    - 数値文字列としての文字種・文字数のチェック
    - 文字列型から数値型への型変換
    - 最小値・最大値の範囲にあることの確認
- その他の注意点 その他の問題として以下がある。
  - 入力項目が指定されていない（項目自体がない）ケース
  - 配列形式で入力されているケース
    - スカラー値を期待したプログラムに入力値として配列が指定されると思わぬエラーになる場合がある。
    - PHPではfilter_input関数で入力値検証を簡潔に記述できる。

#### 正規表現による入力値検証の例　英数字１〜５文字
- u修飾子
- i修飾子
- データの先頭は\A、データの末尾は\zで示す。

#### 正規表現による入力値検証の例　住所欄
- 住所欄のような文字種の制限がない場合でも、制御文字が混入していないというチェックをすべき。
- POSIX文字クラスによる制御文字以外の指定

### まとめ
- 入力値検証の実施手順
  - 設計段階で各パラメータの文字種および最大文字数、最小値・最大値を仕様として決める
  - 設計段階で入力値検証の実装方針を決める
  - 開発段階では仕様に従い入力値検証を実装する。

## 4.3 表示処理に伴う問題
- この節では、サーバー側処理で起こるXSSを扱う。

### 4.3.1 クロスサイト・スクリプティング（基本編）
#### 概要
- 通常、Webアプリケーションには外部からの入力などに応じて表示が変化する箇所があり、この部分のHTML生成の実装に問題があると、XSSという脆弱性が生じる。
- XSS脆弱性がある場合には、以下の影響がある。
  - サイト利用者のブラウザ上で、攻撃者の用意したスクリプトの実行によりクッキー値を盗まれ、利用者が成りすましの被害にあう
  - 同じくブラウザ上でスクリプトを実行させられ、サイト利用者の権限でWebアプリケーションの機能を悪用される
  - Webサイト上に偽の入力フォームが表示され、フィッシングにより利用者が個人情報を盗まれる

#### XSS脆弱性のまとめ
- 発生箇所
  Webアプリケーション上でHTML、JavaScriptを生成している箇所
- 影響を受けるページ
  Webアプリケーション全体が影響を受ける
- 影響の種類
  Webサイト利用者のブラウザ上でのJavaScriptの実行、偽情報の表示
- 影響の度合い
  中〜大
- 利用者関与の度合い
  必要 -> 罠サイトの閲覧、メール記載のURLの起動、攻撃を受けたサイトの閲覧など
- 対策の概要
  - 属性値はダブルクォートで囲む
  - HTMLで特別な意味を持つ記号文字をエスケープする

#### 攻撃手法と影響
- XSSの悪用の方法3種類
  - クッキー値の盗み出し
  - その他のJavaScriptによる攻撃
  - 画面の書き換え

- 反射型XSSと持続型XSS
  - 攻撃用JSが、攻撃対象サイトと別のサイトにある場合を反射型XSSと言う。反射型のXSSは、多くの場合入力値をそのまま表示するページで発生する。
  - 攻撃用のJSが、攻撃対象のデータベースなどに保存される場合がある。その場合のXSSを持続型XSSと呼ぶ。WebメールやSNSなどが典型的な攻撃ターゲットである。

#### 脆弱性が生まれる原因
- XSS脆弱性が生じる原因は、HTML生成の際に、HTMLの文法上特別な意味を持つ特殊記号を正しく扱っていないことであり、それにより、開発者の意図しない形でHTMLやJavaScriptを注入・変形される現象がXSSである。
- HTMLのエスケープは、XSS解消のためには非常に重要である。

#### 必須対策
- 要素内容については「<」と「&」をエスケープする
  -> htmlspecialchars関数によりエスケープ
- 属性値については、ダブルクォートで囲って、「<」と「"」と「&」をエスケープする
  -> htmlspecialchars関数によりエスケープしてダブルクォートで囲む

#### 必須対策（共通対策）
- HTTPレスポンスに文字エンコーディングを明示する

#### XSSに対する保険的対策
- X-XSS-Protectionレスポンスヘッダの使用
  - これは、XSSフィルタというセキュリティ機能を上書きして有効化するヘッダ
  - すべてのHTTPレスポンスで以下を出力することを（筆者は）推奨する。
  `X-XSS-Protection: 1; mode=block`
- 入力値の検証　入力値の条件が英数字のみに限定できる場合などに限られる。
- クッキーにHttpOnly属性を付与する
- （TRACEメソッドの無効化）

### 4.3.2 クロスサイト・スクリプティング（発展編）
#### href属性やsrc属性のXSS
- href属性は、javascriptスキームによるXSSの対象になりうる。
- URLを生成する場合は、httpスキームとhttpsスキームで始まる絶対URLかスラッシュで始まる相対URLであるかをチェックする。
- リンク先ドメイン名のチェック

#### JavaScriptの動的生成
- イベントハンドラのXSS
  1. データをJavaScript文字列リテラルとしてエスケープする
  2. この結果をHTMLエスケープする
- script要素のXSS
- JavaScriptの文字列リテラルの動的生成の対策
  - 対策しづらいので、JSに動的パラメータを渡すときに利用できる方法2種類を紹介する。
  - script要素の外部でパラメータを定義して、JavaScriptから参照する方法
  - インラインJSONPによる方法

#### HTMLタグやCSSの入力を許す場合の対策
- HTMLテキストを構文解析して必要な要素のみを抽出するライブラリを使用することが望ましい。

### 4.3.3 エラーメッセージからの情報漏洩
- 以下の2種類がある。
  - エラーメッセージに攻撃者にとって有益なアプリケーションの内部情報が含まれる
  - 意図的な攻撃として、エラーメッセージに秘密情報を表示させられる
- 対策：エラー発生時に画面に表示するのは利用者向けのメッセージにとどめ、エラーの詳細はログに出力するようにする。

## 4.4 SQL呼び出しに伴う脆弱性
### 4.4.1 SQLインジェクション
#### 概要
- SQLインジェクションは、SQLの呼び出しかたに不備がある場合に発生する脆弱性。攻撃者が能動的に（利用者の関与なしで）サーバーを攻撃できる。
- 以下のような影響を受ける可能性がある。
  - データベース内のすべての情報が外部から盗まれる
  - データベースの内容が書き換えられる
  - 認証を回避される（IDとパスワードを用いずにログインされる）
  - その他、データベースサーバー上のファイルの読み出し、書き込み、プログラムの実行などを行われる
- 確実な対策は、静的プレースホルダを利用してSQLを呼び出すこと。

#### 攻撃手法と影響
- エラーメッセージ経由の情報漏洩
- UNION SELECTを用いた情報漏洩
- SQLインジェクションによる認証回避
- SQLインジェクション攻撃によるデータ改ざん
- その他の攻撃

#### 脆弱性が生まれる原因
- 典型的な原因はリテラルの扱いにある。
- 文字列リテラルの問題
  - シングルクォートなどを用いてリテラルからはみ出した文字列をSQL文として認識させ、アプリケーションが呼び出すSQL文を変更する手法がSQLインジェクション攻撃である。
- 数値項目に対するSQLインジェクション

#### 対策
- SQLインジェクション脆弱性を解消するためには、SQL文を組み立てる際にSQL文の変更を防ぐこと。方法としては
  1. プレースホルダによりSQL文を組み立てる
  2. アプリケーション側でSQL文を組み立てる際に、リテラルを正しく構成するなど、SQL文が変更されないようにする
- 1.の方法を著者は強く勧める。
- 静的プレースホルダと動的プレースホルダの違い
  - 原理的にSQLインジェクションの可能性がないという点で静的プレースホルダの方が優れている。
- SQLインジェクションの保険的対策
  - 詳細なエラーメッセージの抑止
  - 入力値の妥当性検証
  - データベースの権限設定

#### さらに進んだ学習のために
- エスケープすべき文字の詳細、文字エンコーディングの影響については、「安全なSQLの呼び出し方」を参照

## 4.5 「重要な処理」の際に混入する脆弱性
### 4.5.1 クロスサイト・リクエストフォージェリ（CSRF）
#### 概要
- 「重要な処理」の受付に際して必要となる、利用者の意図したリクエストであることの確認処理が抜けていると、罠のサイトなどを閲覧しただけで、利用者のブラウザから勝手に「重要な処理」を実行させられる場合がある。このような問題を引き起こす脆弱性をCSRFと呼ぶ。
- 影響の例
  - 利用者のアカウントによる物品の購入
  - 利用者の退会処理
  - 利用者のアカウントによるSNSや問い合わせフォームなどへの書き込み
  - 利用者のパスワードやメールアドレスの変更
- CSRF脆弱性の影響は、アプリケーションの「重要な処理」の悪用に限られ、被害者である利用者の個人情報などを盗むことはできない。
- 対策は、「重要な処理」を実行する前に、利用者の意図したリクエストであることを確認すること。

#### 攻撃手法と影響
- 入力-実行パターンのCSRF攻撃
- 確認画面がある場合のCSRF攻撃
- ファイルアップロードフォームでのCSRF攻撃

#### 脆弱性が生まれる原因

#### 対策
- 以下の二点を実施する
  - CSRF対策の必要なページを区別する
  - 正規利用者の意図したリクエストを確認できるように実装する
- CSRF対策の必要なページを区別する
  - ECサイトにおける物品購入など、他のサイトから勝手に実行されると困るページには、CSRF対策を施す。
  - 開発プロセスでは下記のようにする
    - 要件定義工程で機能一覧を作成し、CSRF対策の必要な機能にマークする
    - 基本設計工程で画面遷移図を作成し、CSRF対策の必要なページにマークする
    - 開発工程でCSRF対策を作りこむ
- 正規利用者の意図したリクエストであることを確認する
  - 具体的な方法は3種類が知られている
    - 秘密情報（トークン）の植え込み
    - パスワード再入力
    - Refererのチェック
- 保険的対策
  - 「重要な処理」の実行後に、登録済みメールアドレスに通知メールを送信する

### 4.5.2 クリックジャッキング
#### 概要
- iframe要素とCSSを巧妙に利用することで、透明にした攻撃対象ページと罠のサイトを重ね合わせ、利用者が気づかないうちに攻撃対象サイトでのクリックを誘導する攻撃手法である。

#### 攻撃手法と影響

#### 脆弱性が生まれる原因
- アプリケーションのバグが原因ではなく、HTMLの仕様を巧妙に悪用した攻撃である。

#### 対策
- frame及びiframeでの参照を制限するX-Frame-Optionsという仕様が、主要ブラウザの最新版で採用されている。この仕様に対応することによりクリックジャッキング対策が容易にできるようになっている。
- X-Frame-Optionsを必ず指定すべきページは「重要な処理」の1つ手前の入力フォームだが、すべてのページでX-Frame-Optionsヘッダを出力しても問題ないので、Apacheやnginxなどの設定で出力することもできる。

## 4.6 セッション管理の不備
### 4.6.1 セッションハイジャックの原因と影響
- 第三者がセッションIDを悪用して成りすますことをセッションハイジャックと呼ぶ。
- 第三者がセッションIDを知るための手段は、以下の3種類に分類される。
  - セッションIDの推測
  - セッションIDの盗み出し　盗み出しに悪用可能な脆弱性の典型例は以下
    - XSS
    - HTTPヘッダ・インジェクション
    - URLに埋め込まれたセッションID
  - セッションIDの強制

### 4.6.2 推測可能なセッションID
#### 概要
- 発生箇所： セッションIDを生成している箇所
- 影響を受けるページ： セッション管理を利用しているページすべて。とくに、秘密情報の表示や重要な処理をするページは影響が大きい。
- 影響の種類： 成りすまし
- 影響の度合い： 大
- 利用者関与の度合い：　不要
- 対策の概要：　自作のセッション管理機構ではなく、実績のあるWebアプリケーション開発ツールの提供するセッション管理機構を利用する

#### 攻撃手法と影響

#### 脆弱性が生まれる原因
- セッション管理機構を自作していることが脆弱性の原因を作ったと言える。

#### 対策
- Webアプリケーション開発ツールが備えるセッション管理機構を利用すること。

### 4.6.3 URL埋め込みのセッションID
#### 対策
- クッキーにセッションIDを保存するよう設定する。

### 4.6.4 セッションIDの固定化
- セッションアダプション
  - PHPやASP.NETには未知のセッションIDを受け入れるという特性がある。この特性はセッションアダプションと呼ばれる。
  - セッションアダプションがない場合、攻撃者はまずターゲットアプリケーションを閲覧して、有効なセッションIDを取得し、このセッションIDを被害者に強制するように罠サイトを設定する。
  - つまり、セッションアダプション問題がなくても、セッションIDの固定化攻撃自体は可能である。
- クッキーのセッションIDを外部から設定することは容易ではないが、ブラウザやWebアプリケーションに脆弱性があれば、可能になる。

#### 脆弱性が生まれる原因
- 第一の原因は、セッションIDを外部から強制できることであるが、これに対する本質的な対策を取ることは難しい。
- このため、セッションIDが外部から強制されることは許容し、セッションIDの固定化攻撃が行われても、セッションハイジャックは防ぐように対策することが一般的である。

#### 対策
- セッションID固定化攻撃に対する対策方法は、認証後にセッションIDを変更すること。
- セッションIDの変更ができない場合は、トークンにより対策する。
- ログイン前にセッション変数を使っていると、セッションIDの固定化攻撃に完全に対策することは困難である。ログイン前にはセッション管理機構を使わず、hiddenパラメータで値を引き回すことが、現実的な対策になる。

## 4.7 リダイレクト処理にまつわる脆弱性

### 4.7.1 オープンリダイレクト
- Webアプリケーションの中には、パラメータにより指定したURLにリダイレクトできる機能を備えるものがある。その中で、任意のドメインにリダイレクトできる脆弱性をオープンリダイレクト脆弱性と呼ぶ。

#### 攻撃手法と影響
- 攻撃者は、利用者に罠のリダイレクト先が入ったURLを閲覧するように仕向ける。罠のリダイレクト先に再度ログインさせるような画面を用意しておき、利用者が送信することで利用者の重要情報が盗まれる。

#### 脆弱性が生まれる原因
- 下記両方が当てはまる場合、オープンリダイレクト脆弱性になる
  - リダイレクト先のURLを外部から指定できる
  - リダイレクト先のドメイン名のチェックがない
- 以下二点が揃っている場合は、脆弱性ではない（例：バナー広告）
  - もともと外部のドメインに遷移する仕様であること
  - 利用者にとって外部ドメインに遷移することが自明であること

#### 対策
- 根本対策は以下のいずれかを実施すること
  - リダイレクト先のURLを（外部から指定するのではなく）固定にする
  - リダイレクト先のURLを直接指定せず番号指定にする
    - ページ番号の形で指定させ、ページ番号とURLの対応表は外部から見えないスクリプトソースなどで管理する。
  - リダイレクト先のドメイン名をチェックする
    - このチェックは落とし穴が多いので、できるだけ上の2つの方法による実装がお勧め

### 4.7.2 HTTPヘッダ・インジェクション
#### 概要
- リダイレクトやクッキー発行など、外部からのパラメータを元にHTTPレスポンスヘッダを出力する際に発生する脆弱性である。レスポンスヘッダを出力する際のパラメータ中に改行を挿入する攻撃によって、被害者のブラウザ上で以下のどちらか、あるいは両方が引き起こされる。
  - 任意のレスポンスヘッダの追加
  - レスポンスボディの偽造
- HTTPヘッダ・インジェクション脆弱性があると、以下の影響があり得る
  - 任意のクッキーの生成
  - 任意のURLのリダイレクト
  - 表示内容の改変
  - 任意のJavaScript実行によるXSSと同様の被害

#### 脆弱性が生まれる原因
- リダイレクト先URLやクッキー値として設定されるパラメータ中に改行を挿入した場合に、改行がそのままレスポンスとして出力されることが原因。

#### 対策
1. 外部からのパラメータをHTTPレスポンスヘッダとして出力しない
  - レスポンスヘッダを利用する主な機能はリダイレクトとクッキー生成だが、以下の方針で外部パラメータを使う機会は大幅に減る
    - リダイレクト先をURLとして直接指定するのではなく、固定にするか番号などで指定する
    - Webアプリケーション開発ツールの提供するセッション変数を使ってURLを受け渡す
2. どうしても外部からのパラメータをHTTPレスポンスヘッダとして出力しなければならない場合は、以下の両方を実施する
  - リダイレクトやクッキー生成を専用APIに任せる
  - ヘッダ生成するパラメータの改行文字をチェックする

### 4.7.3 リダイレクト処理にまつわる脆弱性のまとめ
- リダイレクト処理にはできるだけ専用のAPIを使用する
- 以下のいずれかを実施する
  - リダイレクト先は固定にする（推奨）
  - 外部から指定するリダイレクト先のURLは、必ず文字種とドメイン名をチェックする

## 4.8 クッキー出力にまつわる脆弱性
- クッキーにまつわる脆弱性は大別すると以下の2種類
  - クッキーを利用すべきでない目的でクッキーを使っている
  - クッキーの出力方法に問題がある
- クッキー出力時に発生しやすい脆弱性には以下がある
  - HTTPヘッダ・インジェクション脆弱性
  - クッキーのセキュア属性不備

### 4.8.1 クッキーの不適切な利用
- Webアプリケーションで、ページをまたがる情報を保存する場合は、PHPなどが提供するセッション管理機構が用いられる。一般的に、セッション管理機構ではセッションIDのみをクッキーに保存し、データ自体はWebサーバーのメモリなどに保存する。一方、クッキーに保存すべきでないデータをクッキーに保存することにより脆弱性が発生する場合がある。
- セッション変数とは異なり、クッキー値はアプリケーションの利用者によって書き換えができるので、書き換えられると困る情報をクッキーに保存すると脆弱性の原因になる。

- クッキーにデータを保存するより、（一部実現できないことはあるが）セッション変数の方が便利で安全に使用できるため、通常はセッション変数を使用すべき

### 4.8.2 クッキーのセキュア属性不備
#### 概要
- アプリケーションがHTTPS通信を利用していても、セキュア属性のついていないクッキーは平文で送信される場合があり、盗聴される可能性がある。
- セキュア属性不備への対策は、クッキーのセキュア属性を設定すること。しかし、HTTPとHTTPSの混在するサイトの場合うまく動かなくなるケースもある。この場合は、セッションIDとは別に、トークンをセキュア属性つきクッキーとして発行して、ページごとに確認する方法がある。

#### 攻撃手法と影響
- HTTPS通信でセットされたクッキー値が、被害者が罠サイト閲覧時に443ポートに対するHTTPリクエストが送信されることで、暗号化されていない状態でネットワーク上を流れることになる。攻撃者がこの通信中のクッキー値を盗聴できる場合、セッションハイジャックに悪用できる。

#### 脆弱性が生まれる原因
- 原因は以下の2種類。後者について説明する。
  - 開発者がセキュア属性について知らない
  - セキュア属性をつけるとアプリケーションが動かなくなる
- 後者に対するシンプルな解決策は、サイト全体をHTTPSにする「常時TLS」にした上でクッキーにセキュア属性をつけることである。それが難しい場合は、トークンを用いた対策がある。
- トークンを用いた対策
  - トークンを保持するクッキーにセキュア属性をつけることで、HTTPのページとHTTPSのページでセッションを共有しつつ、仮にセッションIDを盗聴された場合でもHTTPSのページはセッションハイジャックを防止できる。
- トークンにより安全性が確保できる理由
  - トークンは認証成功時に一度だけサーバーから出力される
  - トークンはHTTPSのページで生成される（サーバー -> ブラウザ）
  - トークンは確実に暗号化されてブラウザから送信される（ブラウザ -> サーバー）
  - HTTPSのページを閲覧するにはトークンが必須

#### セキュア属性以外の属性値に関する注意
- Domain属性：　特殊な理由がない限り指定する必要なし
- Expire属性：　セッションIDのクッキーには通常Expires属性をつけず、ブラウザ終了と同時にクッキーが削除される状態にする
- HttpOnly属性：　セッションIDをJSから参照する意味はないので、通常つけるようにするとよい

## 4.9 メール送信の問題
### 4.9.1 メール送信の問題の概要

### 4.9.2 メールヘッダ・インジェクション
- メールヘッダ・インジェクションは、宛先や件名などのメールヘッダを外部から指定する際に、改行文字を使ってメールヘッダや本文を追加・変更する手法である。影響は以下の通り
  - 件名や送信元、本文を改変される
  - 迷惑メールの送信に悪用される
  - ウイルスメールの送信に悪用される

#### 攻撃手法と影響
- 宛先の追加
- 本文の改竄
- 添付ファイルをつける

#### 脆弱性が生まれる原因
- メールのメッセージヘッダでは、改行に特別な意味があるが、アプリケーションが改行をチェックしていない場合には、ヘッダや本文を追加・変更できてしまう。これが脆弱性の発生原因である。

#### 対策
- メール送信には専用のライブラリを使用する（sendmailコマンドを使うのは危険）
- その上で、以下のいずれかを実施する
  - 外部からのパラメータをメールヘッダに含ませないようにする
  - 外部からのパラメータには改行を含まないようにメール送信時にチェックする

## 4.10 ファイルアクセスにまつわる問題
### 4.10.1 ディレクトリ・トラバーサル
- 外部からパラメータの形でサーバー上のファイル名を指定できるWebアプリケーションでは、ファイル名に対するチェックが不十分であると、アプリケーションの意図しないファイルに対して閲覧や改竄、削除ができる場合がある。この脆弱性をディレクトリ・トラバーサルと呼ぶ。

#### 脆弱性が生まれる原因
- 下記の全てを満たすとディレクトリ・トラバーサル脆弱性になる。
  - ファイル名を外部から指定することができる
  - ファイル名として、絶対パスや相対ぱすの形で異なるディレクトリを指定できる
  - 組み立てたファイル名に対するアクセスの可否をチェックしていない

#### 対策
- 以下のいずれかを実施すること
  - 外部からファイル名を指定できる仕様を避ける
    - ファイル名を固定にする
    - ファイル名をセッション変数に保持する
    - ファイル名を直接指定するのではなく番号などで間接的に指定する
  - ファイル名にディレクトリ名が含まれないようにする
    - PHPの場合、basenameという関数が使用できる。これは、ディレクトリ付きファイル名を受け取り、最後の名前の部分を返すものである。（../../hostsを受け取ったらhostsを返す）
  - ファイル名を英数字に限定する

### 4.10.2 意図しないファイル公開
#### 概要
- 外部から閲覧されると困るファイルをWebサーバーの公開ディレクトリに配置している場合がある。この場合、ファイルに対するURLが分かると、秘密ファイルの閲覧が可能になる。意図しないファイル公開により、重要情報の漏洩などにつながる。

#### 攻撃手法と影響
- URLでディレクトリ名を指定した場合にファイル一覧を表示する機能のことをディレクトリ・リスティングと呼ぶ。対策していない場合、この機能も活用して、秘密ファイルのリンクから情報が漏れてしまう。

#### 脆弱性が生まれる原因
- 非公開のファイルを公開ディレクトリに置いたことが原因。公開ディレクトリに置かれたファイルが外部から閲覧できる条件は以下の通り。
  - ファイルが公開ディレクトリに置かれている
  - ファイルに対するURLを知る手段がある
  - ファイルに対するアクセス制限が掛かっていない
- ファイルに対するURLを知る手段には以下がある。
  - ディレクトリ・リスティングが有効　など。多いので書籍参照

#### 対策
- 非公開ファイルを公開ディレクトリに置かないことが根本対策。そのために、以下を推奨する。
  - アプリケーションの設計時に、ファイルの安全な格納場所を決める
  - レンタルサーバーを契約する場合は非公開ディレクトリが利用できることを確認する

## 4.11 OSコマンド呼び出しの際に発生する脆弱性
### 4.11.1 OSコマンド・インジェクション
- Webアプリケーションの開発に用いる言語の多くはシェル経由でOSコマンドを呼び出す機能を提供しており、シェルを呼び出せる機能の使い方に問題があると、意図しないOSコマンドが実行可能になる場合がある。これをOSコマンドインジェクション脆弱性と呼ぶ。

#### 攻撃手法と影響

#### 脆弱性が生まれる原因
- OSコマンド呼び出しに利用される関数やシステムコールの多くは、シェル経由でコマンドを起動している。シェルには、1行の指定で複数のプログラムを起動する方法が用意されている。この機能の悪用がOSコマンド・インジェクション攻撃である。
- OSコマンドのパラメータとして指定する文字列に、シェルのメタ文字を混入させることにより、開発者の意図とは異なるOSコマンドが実行可能となることがOSコマンド・インジェクション脆弱性の原因である。
- OSコマンド・インジェクション脆弱性が生まれる条件は、以下の3つのすべてを満たすことである。
  - シェルを呼び出す機能のある関数（system,openなど）を利用している
  - シェル呼び出しの機能のある関数にパラメータを渡している
  - パラメータ内に含まれるシェルのメタ文字をエスケープしていない

#### 対策
- 以下のいずれかによって対策することを推奨する。優先して採用すべき順
  - OSコマンド呼び出しを使わない実装方法を選択する
  - シェル呼び出し機能のある関数の利用を避ける
  - 外部から入力された文字列をコマンドラインのパラメータに渡さない
  - OSコマンドに渡すパラメータを安全な関数によりエスケープする
- 保険的対策
  - パラメータの検証
  - アプリケーションの稼働する権限を最小限にする
  - WebサーバーのOSやミドルウェアのパッチ適用

## 4.12 ファイルアップロードにまつわる問題
### 4.12.1 ファイルアップロードの問題の概要
- アップローダに対する攻撃には以下がある
  - アップロード機能に対するDoS攻撃
    - 対策：アップロードファイルの容量制限
  - アップロードされたファイルをサーバー上のスクリプトとして実行する攻撃
  - 仕掛けを含むファイルを利用者にダウンロードさせる攻撃
  - 閲覧権限のないファイルのダウンロード

### 4.12.2 アップロードファイルによるサーバー側スクリプト実行
#### 概要
- アップローダの中には、利用者がアップロードしたファイルをWebサーバーの公開ディレクトリに保存するものがある。加えて、ファイル名の拡張子として、phpなどサーバー側で実行可能なスクリプト言語の拡張子が指定できると、アップロードしたファイルをスクリプトとしてWebサーバー上で実行できる。

#### 脆弱性が生まれる原因
- 以下の両方に該当すること
  - アップロードしたファイルが公開ディレクトリに保存される
  - アップロード後のファイル名として、「.php」、「.asp」などサーバースクリプトを示す拡張子が指定できる

#### 対策
- 拡張子の制限だけでは対策抜けが生じる可能性があるので、ファイルを公開ディレクトリに保存しない方法をとる。
  - ダウンロードスクリプトを用いる。

### 4.12.3 ファイルダウンロードによるクロスサイト・スクリプティング
#### 概要
- アップロードしたファイルを利用者がDLする際に、ブラウザがファイルタイプを誤認する場合がある。例えば、アプリケーションがPDFファイルを想定しているにもかかわらず、PDFデータ中にHTMLタグが含まれていると、条件によってはブラウザがHTMLファイルとして認識してしまい、PDFファイルに埋め込まれたJSを実行する場合がある。これが、ファイルダウンロードによるXSSである。

#### 脆弱性が生まれる原因
- ファイルダウンロードによるXSSが生まれるのは、Content-Typeの間違った指定が原因である。この指定が間違っていると、ブラウザがコンテンツをHTMLと解釈し、コンテンツ中のJSが実行されてしまう可能性がある。
- 仮にContent-Typeが間違っていない場合でも、ブラウザが扱うことのできないContent-Typeの場合にはXSSになる場合がある。

#### 対策
- ファイルアップロード時の対策
  - 拡張子が許可されたものかをチェックする
- ファイルダウンロード時の対策
  - Content-Typeを正しく設定する（必須）
  - レスポンスヘッダX-Content-Type-Options: nosniffを指定する（必須）
  - 必要に応じてContent-Dispositionヘッダを設定する
  - PDFを扱う場合は、4.12.4項の対策を合わせて実施する

### 4.12.4 PDFのFormCalcによるコンテンツハイジャック
#### 概要
- FormCalcのURL関数を用いた仕掛けを組み込んだPDFファイルをアップロードすることにより、正規ユーザーに成りすましを行う攻撃手法が考案されている。Adobe Acrobat Readerプラグインを備えたブラウザが影響を受けるため、主にIEが対象ブラウザになる。

#### 脆弱性が生まれる原因
- Adobe Acrobat Readerのセキュリティ上好ましくない仕様を悪用したものなので、本来はAdobe Acrobat Readerの仕様が見直されるべきだが、Webアプリケーション側で対応せざるを得ないのが現状。

#### 対策
- PDFファイルはブラウザ内で開かずダウンロードを強制する
- PDFをobject要素やembed要素では開けない仕組みを実装する

## 4.13 インクルードにまつわる問題
### 4.13.1 ファイルインクルード攻撃
- PHPなどのスクリプト言語には、スクリプトのソースの一部を別ファイルから読み込む機能がある。PHPの場合はincludeなどがそれに当たる。includeなどに指定するファイル名を外部から指定できる場合、アプリケーションが意図しないファイルを指定することにより脆弱となる場合がある。これをフィルインクルード脆弱性と呼ぶ。

##### 脆弱性が生まれる原因
- インクルードファイル名を外部から指定することができる
- インクルードすべきファイル名かどうかのチェックをしていない

#### 対策
- ファイルインクルード脆弱性の解消の考え方は、ディレクトリ・トラバーサル脆弱性の場合と同様
  - 外部からファイル名を指定する仕様を避ける
  - ファイル名を英数字に限定する

## 4.14 構造化データの読み込みにまつわる問題
### 4.14.1 evalインジェクション
- ソースコードを解釈実行するevalと呼ばれる機能や関数があり、各言語のソースコードをデータとして扱うことができる。evalの利用法に問題がある場合、外部から送り込んだスクリプトを実行される場合がある。このような攻撃をevalインジェクション攻撃と言い、そのような攻撃を受ける脆弱性をevalインジェクション脆弱性と呼ぶ。
- evalインジェクションの影響は、OSコマンド・インジェクションと同じ

#### 脆弱性が生まれる原因
- evalを用いることがそもそも危険である
- evalに与えるパラメータのチェックがされていない

#### 対策
- eval（同等機能）を使わない
- evalの引数に外部からのパラメータを指定しない
- evalの与える外部からのパラメータを英数字に制限する

### 4.14.2 安全でないデシリアライゼーション
- アプリケーション内部の構造を持ったデータを保存・伝送する目的でバイト列に変換することをシリアライズと言い、シリアライズされたデータから元のデータに戻すことをデシリアライズと言う。
- シリアライズされたデータが信頼できない場合、デシリアライズ処理の際に意図しないオブジェクトがアプリケーション内に生成され、場合によっては任意のコードを実行してしまう場合がある。安全でないデシリアライゼーションの影響は、OSコマンド・インジェクション攻撃と同じ。

#### 対策
- シリアライズ形式ではなくJSON形式によりデータを受け渡す
- クッキーやhiddenパラメータではなくセッション変数など書き換えできない形でシリアライズ形式のデータを受け渡す
- HMACなどの改竄検知の仕組みを導入してデータが改竄されていないことを確認する

### 4.14.3 XML外部実体参照（XXE）
#### 概要
- XMLには外部実体参照という機能があり外部ファイルの内容を取り込むことができる。XMLデータを外部から受け取るプログラムは、外部実体参照の形でWebサーバー内部のファイルなどを不正に読み取られる可能性がある。この攻撃をXML外部実体参照攻撃と呼び、XML外部実体参照攻撃ができてしまう脆弱性をXML外部実体参照脆弱性と呼ぶ。

#### 脆弱性が生まれる原因
- XXEはXMLの機能を悪用するものであり、プログラムにコーディング上のバグがあるというものではない。

#### 対策
- XXE対策は外部実体参照を禁止する指定を行うことが基本となる。
- PHPにおけるXXE対策
  - XMLの代わりにJSONを用いる
  - libxml2のバージョン2.9以降を用いる
  - libxml_disable_entity_loader(true)を呼び出す

## 4.15 共有資源やキャッシュに関する問題
### 4.15.1 競合状態の脆弱性
#### 概要
- 共有資源とは、複数のプロセスやスレッドから同時に利用している変数、共有メモリ、ファイル、データベースなどのことである。共有資源に対する排他制御が不十分な場合、競合状態の脆弱性の原因になる場合がある。
- 競合状態の問題で起こる影響の代表例として以下がある
  - 別人の個人情報などが画面に表示される（別人問題）
  - データベースの不整合
  - ファイルの内容の破壊

#### 脆弱性が生まれる原因
- 共有変数（サーブレットクラスのインスタンス変数など）の排他制御をしていない

#### 対策
- 以下のいずれかを実施する
  - 可能であれば共有資源を使用しない
  - 共有資源に対して排他制御を行う

### 4.15.2 キャッシュからの情報漏洩
#### 概要
- 過剰にキャッシュが働いてしまうと、個人情報漏洩などの原因になる場合がある。

#### 脆弱性が生まれる原因
- 以下のいずれかがサイト側にあることが原因
  - アプリケーション側のキャッシュ制御不備
  - キャッシュサーバーの設定不備

#### 対策
- 以下の両方を実施すること
  - アプリケーション側でキャッシュ制御用の適切なレスポンスヘッダを設定する
  - キャッシュサーバー側でキャッシュ制御の適切な設定を行う

## 4.16 Web API実装における脆弱性

### 4.16.1 JSONとJSONPの概要
- JSON
  - JavaScriptのオブジェクトリテラル形式をデータ交換形式に発展させたもの
- JSONP
  - CORSができる前に同一オリジンポリシーの枠内で異なるオリジンのサーバーからデータを取得するいくつかの方法のうち、代表的なものの1つがJSONP
  - JSONPは、script要素を用いて外部のJavaScriptを直接実行することによりデータを取得する。そのためには、JSON文字列そのままではscript要素で受け取ることができないので、関数呼び出しの形でデータを生成する。

### 4.16.2 JSONエスケープの不備
#### 概要
- APIにおいてJSON文字列生成時のエスケープ処理に不備があると、意図しないJavaScriptがJSONデータに混入する場合がある。デコードの仕方などによっては、不正なJSの実行に至る。

#### 脆弱性が生まれる原因
- 以下の2つの条件が揃うこと
  - JSON文字列の生成時に適切なエスケープ処理などが行われていない
  - JSONの評価にeval関数などを用いているか、JSONPを用いている

#### 対策
- 文字列連結によるJSONデータ生成をやめ、信頼できるライブラリを用いてJSONを生成する
- eval関数ではなくJSON.parseなどの安全なAPIでJSONを解釈する
- 保険的対策として以下を強く推奨する
  - JSONPを避け、CORSを用いたWeb APIに移行する

### 4.16.3 JSON直接閲覧によるXSS
#### 概要
- JSONを返すWeb APIは、通常XMLHttpRequestによるアクセスを想定したものだが、APIが返すレスポンスデータをブラウザで直接閲覧させることにより攻撃が可能になる場合がある。

#### 脆弱性が生まれる原因
- MIMEタイプの間違いが直接の原因

#### 対策
- MIMEタイプを正しく設定する（必須）
- レスポンスヘッダX-Content-Type-Options: nosniffを出力する（強く推奨）
- 小なり記号などをUnicodeエスケープする（推奨）
- XMLHttpRequestなどCORS対応の昨日だけから呼び出せるようにする（推奨）

### 4.16.4 JSONPのコールバック関数名によるXSS
#### 概要
- JSONPはJSONデータを引数とするコールバック関数呼び出しの形式を取るが、このコールバック関数の名前は固定ではなく外部から指定できるようにするケースが多い。外部から指定したパラメータにより表示内容（関数名）が制御できることから、コールバック関数名によるXSSが可能になる場合がある。

#### 脆弱性が生まれる原因
- 外部から指定されたコールバック関数名を検証しないでそのまま表示している
- MIMEタイプをtext/javascriptとするべきところをtext/htmlとしている

#### 対策
- 以下の両方を実施すべき
  - コールバック関数名の文字種と文字数を制限する
  - MIMEタイプを正しく設定する

### 4.16.5 Web APIのクロスサイト・スクリプトフォージェリ
#### Web APIに対するCSRF攻撃経路
- GETリクエストによる攻撃
- HTMLフォームによる攻撃
- クロスオリジン対応のXMLHttpRequestによる攻撃（シンプルなリクエスト）
  - API側がクロスオリジンの呼び出しを許可していなくても、罠サイトのJSでHTTPリクエストを送ることはできるので、CSRF攻撃は成立する。
- XMLHttpRequestによる攻撃（プリフライトリクエストが必要なケース）

#### 対策
- 代表的な方法は以下
  - CSRFトークン（セッション変数にトークンを保持）
  - 二重送信クッキー
  - カスタムリクエストヘッダによる対策
    - JSライブラリの中には、Ajaxリクエストに自動的にカスタムリクエストヘッダを付与するものがある。これが付与されていることをサーバー側で確認するだけでもCSRF対策になる。
- 共通の対策として下記を実施する
  - 入力データのMIMEタイプ（application/jsonなど）を検証する
  - CORSを適切に実装する（4.16.8項参照）
- CSRFトークン、二重送信クッキーにおけるトークンパラメータの送信にはHTTPリクエストヘッダを用いることがお勧め。クロスオリジン通信でカスタムリクエストヘッダを付与するためには、プリフライトリクエストで許可される必要があるため、API側のプリフライトリクエストの処理にバグがなければ、CSRF攻撃は成立しない。

### 4.16.6 JSONハイジャック
#### 概要
- 何らかの方法でJSONデータをscript要素で受け取ることができないかが研究されており、その手法はJSONハイジャックと呼ばれている。

#### 対策
- X-Content-Type-Options: nosniffヘッダの付与（強く推奨）
- リクエストヘッダX-Requested-With: XMLHttpRequestの確認（推奨）

### 4.16.7 JSONPの不適切な利用
- JSONPは、その考案された事情から、極力使用をやめ、CORS対応のAPIに移行することが望ましい。

#### JSONPによる秘密情報提供
- JSONPにはCORSのようなアクセス制御の仕組みがないため、JSONPによる情報公開は公開情報の提供にとどめ、秘密情報の提供は避けるべき。

#### まとめ
- JSONPはできるだけ使用せずCORS+JSONに移行する
- JSONPは公開情報の提供のみに用いる
- JSONPは信頼できる提供元のみを使用する

### 4.16.8 CORSの検証不備
- CORSは非常によく考えられた仕様だが、利用者側の無知や手抜きにより問題が起こる場合はある。これはどのようなセキュリティ機構についても起こり得ること。
- 不備の例
  - オリジンとして"*"を指定する
  - オリジンのチェックをわざと緩和してしまう

### 4.16.9 セキュリティを強化するレスポンスヘッダ
- Web APIに限らず、常に出力しておくだけでブラウザのセキュリティ機能を強化するHTTPレスポンスヘッダの代表例
  - X-Frame-Options
    - 4.5.2 クリックジャッキングで紹介
  - X-Content-Type-Options
    - X-Content-Type-Options: nosniffという形で仕様。MIMEタイプの解釈を厳密にする
  - X-XSS-Protection
    - 利用者がXSSフィルタの有効化・無効化設定をしていても、当該ページについてXSSフィルタの設定を上書きする
    - XSSフィルタの動作モードを指定する
  - Content-Security-Policy
  - Strict-Transport-Security（HTTP Strict Transport Security; HSTS）

## 4.17 JavaScriptの問題
### 4.17.1 DOM Based XSS
#### 概要
- JSによる処理の不備が原因でXSSとなる場合もあり、DOM Based XSSと呼ばれる。

#### 攻撃手法と影響
- innerHTMLによるDOM Based XSS
- document.writeによるDOM Based XSS
- XMLHttpRequestのURL未検証の問題
- jQueryのセレクタの動的生成によるXSS
- javascriptスキームによるXSS location.hrefに任意の文字列を指定できるなど

#### 脆弱性が生まれる原因
- DOM操作の際に外部から指定されたHTMLタグなどが有効になってしまう機能を用いている
  - document.write() innerHTML、jQueryの$()など
- 外部から指定されたJavaScriptが動くevalなどの機能を用いている
- XMLHttpRequestのURLが未検証である
- location.hrefやsrc属性、href属性のURLが未検証である

#### 対策
- 以下のいずれか
  - 適切なDOM操作あるいは記号のエスケープ
  - eval, setTimeout, Functionコンストラクタなどの引数に文字列形式で外部からの値を渡さない
  - URLのスキームをhttpかhttpsに限定する
  - jQueryのセレクタは動的生成しない
  - 最新のライブラリを用いる
  - XMLHttpRequestのURLを検証する

### 4.17.2 Webストレージの不適切な使用
#### Webストレージとは
- 近年のブラウザでは、クッキーよりも高機能なストレージ（保管庫）として、Webストレージを用意している。

#### Webストレージには何を保存して良いか
- WebストレージはJSからのアクセスを禁止できない。そのため、WebアプリにXSS脆弱性があると、Webストレージの内容は漏洩することになる。
- 上記特性のため、重要な情報（パスワード、個人情報など）はWebストレージには保存しないようにする。

#### Webストレージの不適切な利用例
- Webストレージに秘密情報を保存していた
- Webストレージに保存した情報が、XSSやpostMessageにより漏洩する
- WebストレージがXSSやpostMessage経由で改竄される
- Webストレージを経由したDOM Based XSS

### 4.17.3 postMessage呼び出しの不備
#### postMessageとは
- iframeやwindow.openで開いたウィンドウなど、複数のウィンドウが異なるオリジンで協調して動作する環境で、メッセージやデータのやりとりを行う汎用的な仕組みがpostMessageである。

#### 問題となるケース
- メッセージ送信先の未確認
- メッセージ送信元の未確認

#### 対策のまとめ
- 送信先の（オリジンの）確認
- 送信元の（オリジンの）確認

### 4.17.4 オープンリダイレクト
#### 脆弱性が生まれる原因
- ボタンを押すとJSで何か処理を実行し、その後フラグメント識別子で指定されたURLにリダイレクトするようなケースでは、オープンリダイレクト脆弱性がある。

#### 対策
- 以下のいずれかの対策を取るのが良い
  - リダイレクト先のURLを固定にする
  - リダイレクト先URLを直接指定せず番号などで指定する

スッキリ分かるJava入門 第2版

# 第1章
Javaのソースファイルの名前は「クラス名.java」にしなければならない。

### コメント
/* コメント本文（複数行でも可） */
// コメント本文（行末まで）

### 変数宣言の文
型　変数名;
例：　int age;

変数などの名前として使える文字や数字の並びを識別子という。
基本的にキャメルケースを使う。

### 代表的な型
整数　long　８バイト
int　４バイト
short　２バイト
byte　１バイト
小数　double
float
真偽値　boolean
文字　char
文字列　String

整数は基本的にintを使う。
小数は、より厳密な計算を行えるdoubleを基本的に使用する。

文字データを記述する場合は引用符（’）、文字列データを記述する場合は二重引用符（”）を使う。

### 変数の初期化
型　変数名 = 代入するデータ;
例：　int age = 22;

### 定数の宣言方法
final 型 定数名 = 初期値;
例：　final double TAX = 1.08;

定数は値を書き換えることはできない。
定数名にはすべて大文字を使うのが一般的。

# 第2章　式と演算子
すべての式はオペランドと演算子で構成される。
オペランドは変数・定数やリテラルなど、演算子は+,-など

### オペランド
- リテラル
ソースコードに記載される数字や文字列などはリテラルと呼ぶ。それぞれのリテラルはデータ型を持っており、それはリテラルの表記方法で決まる。

- エスケープシーケンス
¥記号がエスケープシーケンスに当たる。

### 評価
式の評価には3つの原則がある

- 評価結果への置換の原則
演算子は周囲のオペランドの情報を使って計算を行い、それらオペランドを巻き込んで結果に化ける（置き換わる）。

- 優先順位の原則
式に演算子が複数ある場合は、Javaで定められた優先順位の高い演算子から順に評価される。

- 結合規則の原則
式の中に同じ優先順位グループに属する演算子が複数ある場合、演算子ごとに決められた「方向」から順に評価される。

### 演算子
- 算術演算子
  - 除算演算子/ は整数同士の割り算に用いると商を表すので注意
- 文字列結合演算子
- 代入演算子
  - 優先順位が最低なので、代入は基本的に最後に行われる
- インクリメント・デクリメント演算子
  - バグの原因となるので、他の演算子と一緒に使わない。

### 型の変換
1. 代入時の自動型変換
ある型で宣言された変数には、基本的にその型の値しか代入できない。
ただし、意味的に「小さな型」の値を「大きな型」の変数に代入する場合に限って、値が代入先の変数の型に自動的に変換されてから代入される。
int型リテラルをbyte型やshort型の変数に対して実害がない範囲で単純代入することだけは例外的に認められている。

2. 強制的な型変換
- キャストによる強制的な型変換
(変換先の型名) 式

例：　int age = (int) 3.2 // (int)はキャスト演算子と呼ばれる
実行結果： 3

元のデータの一部が失われるため、よほどの理由がない限りは使わない

3. 演算時の自動型変換
算術演算の結果は、計算で使用されたオペランドの型となる。
異なる型で演算を行った場合、「意味的に大きな型」に統一されてから演算が行われる。
片方のオペランドがStringなら、他方もStringに変換して連結する。

### 命令実行の文
Javaに用意されているさまざまな命令を実行することができる。

# 第3章 条件分岐と繰り返し
if文やwhile文を制御構文という。
- 制御構文の構成要素
[条件式] 分岐条件や繰り返しを続ける条件を示した式
[ブロック] 分岐や繰り返しで実行する一連の分の集まり

### ブロック
ブロックは複数の文をひとまとまりとして扱うためのもの。
2つのルールを守る必要がある。
1. 波カッコの省略
  - 内容が1行しかなければ、波カッコを省略しても構わない。ただし、ミス防止のためにこれは推奨されない。
2. ブロック内で宣言した変数の寿命
  - ブロック内で宣言した変数は、そのブロックが終わると同時に消滅する。
  - 変数が利用可能な場所の範囲のことをスコープという。

### 条件式
条件式とは、処理を分岐する条件などを表現するためのもの。
条件式の中では関係演算子が使われる。
関係演算子も演算子の仲間であるため、「評価されて化ける」という性質を持つ。具体的には、関係が成立するならtrueに、そうでないならfalseに化ける。
if文やwhile文で用いる条件式は、評価結果がtrueまたはfalseになる式でなければならない。

文字列の比較では、==は使えない。
- 文字列の比較
文字列型の変数.equals(比較相手の文字列)

- 論理演算子
  - && かつ
  - || または
- 否定演算子 !

### 分岐構造のバリエーション
#### if-else if-else 構文
```
if (条件式) {
  ブロック
} else if (条件式) {
  ブロック
} else {
  ブロック
}
```

- else ifブロックは複数記述できるが、ifブロックより後ろ、elseブロックより前にだけ記述できる。
- 最後のelseブロックは、中身が空ならばelseごと省略が可能。

#### switch文
置き換えられる条件
1. すべての条件式が左辺と右辺が一致するかを比較する式になっていること。
2. 比較する値が整数、文字列または文字であること。

```
switch (条件値 式ではなく変数名) {
  case 値1:
    処理1
    break;
  case 値2:
    処理2
    break;
  default:
    処理X
}
```
- defaultは省略可
- switch文は「条件に一致するcaseラベルまで処理をジャンプさせる命令」に過ぎない。そのため、break文で明示的に「処理を中断してswitch文を抜ける」という指示がない限り、制御構造「順次」にしたがって次のcase文へ進んでしまう。

#### 繰り返し構文
- while文　ブロックを実行する前に条件式を評価する
```
while (条件式) {
  ブロック
}
```

- do-while文　ブロックを実行した後に条件式を評価する。最低1回はブロックを実行する事になる。
```
do {
  ブロック
} while(条件式);
```

- for文
```
for(int i=0; i<10 ; i++>) {

}
```
左から「初期化処理」、「繰り返し条件」、「繰り返し時の処理」で構成される。
ループ変数は、すでに宣言されている変数名は使えない。

#### 制御構造の応用
- 繰り返しを中断したいとき
break文は、breakを囲んでいる最も内側の繰り返しブロックを即座に中断し、ループそのものを抜けて次のブロックを実行する。
continue文は、今の周回を中断して、同じ繰り返しの次の周回に進む。

- 無限ループ
1. while (true) {...}
2. for(;;) {...}

# 第4章 配列
配列の各要素には同一種のデータしか格納できない。
添字は0から。

- 配列変数の宣言
要素の型 [] 配列変数名
例：　int[] score;

- 要素の作成と代入
score = new int[5];

配列の要素は自動的に初期化される。どのような値で初期化されるかは、要素の型によって決められている。

### 省略記法
1. 要素の型[] 配列変数名 = new 要素の型[] {初期値1, 初期値2, 初期値3, ... };
2. 要素の型[] 配列変数名 = {初期値1, 初期値2, 初期値3, ... };

例：
int[] score1 = new int[] { 20, 30, 40, 50, 80 };
int[] score2 = { 20, 30, 40, 50, 80 };

## 配列と例外
実行中に「〜Exeption」と表示されて中断したら、例外というエラーが発生したと判断できる。

## 配列のデータをまとめて扱う
- 配列をforループで回す
```
for (int i=0; i<配列変数名.length; i++) {
  ...
}
```

- 拡張for文で配列を回す
```
for (要素の型 任意の変数名 : 配列変数名) {
  ...
}
```

例：
```
int[] score = { 20, 30, 40 }
for (int value : score) {
  System.out.println(value);
}
```

## 配列の舞台裏　メモリの割り当て関連
- 配列を作成（int[] score = new int[5]）したときのメモリ上の様子
1. int型の要素を5つ持つ配列がメモリ上に作成される
2. int[]型の配列変数scoreがメモリ上に作成される
3. scoreに**配列の先頭要素のアドレスが代入される。**

- プログラムからscore[n]と指定されたら
1. scoreの中に入っている番地（=8832）を取り出し、配列（先頭要素）を見つける
2. 見つけた配列の先頭要素からn個後ろの要素の区画を読み書きする。

配列変数scoreは配列の実体の番地を指し示す動作をしている。このことを「**参照**」と呼ぶ。
メモリ上の番地を代入する変数のことを「**参照型**」変数と呼び、intなどの「基本型」変数と区別する。

## 配列の後片付け
- **newで確保された要素たちは普通の変数ではないので、ブロックが終了しても寿命を迎えない。**結果、配列はどの配列変数からも参照されない状態でメモリに残ってしまう。
- 本来はメモリの後片付けをプログラマが行わなければならないが、Javaには**ガベージコレクション**という仕組みがあり、何らかの理由で参照されなくなったメモリ領域を自動的に探し出して解放してくれる。

### null
1. int[]型などの参照型変数に代入すると、その変数は何も参照しなくなる。
  - 結果、もともと参照していた配列要素はガベージコレクションの対象になる。
2. int型などの基本型変数には代入することができない。

nullが格納されている配列変数を利用しようとすると、NullPointerExeptionの例外が発生する。

## 多次元配列
- ２次元配列の宣言
要素の型[][] 配列変数名 = new 要素の型[行数][列数];

- 2次元配列の要素の利用
配列変数名[行の添字][列の添字]

# 第5章 メソッド
- メソッドの定義
```
public static 戻り値の型 メソッド名(引数リスト) {
  メソッドブロック
}
```

- メソッドの呼び出し
メソッド名(引数リスト)

プログラムは必ずmain()から動き始める。

## 引数
- 渡す値のことを実引数、受け取る引数のことを仮引数と呼ぶ。

例：
add(100, 20) // 100,20が実引数
public static void add(int x, int y) {...} // x,yが仮引数

- メソッド内で宣言した変数を**ローカル変数**と呼び、仮引数もその一種である。
  - 異なるメソッドに属するローカル変数は、お互いに独立していて無関係

## 戻り値
- 値の戻し方
```
public static 戻り値の型 メソッド名(引数リスト) {
  ...
  return 戻り値;  // return文
}
```

**何も戻さない場合はvoidを指定する。**voidは「何もない」という意味。

- メソッドを呼び出し、戻り値を受け取る
```
型 変数名 = メソッド名(引数リスト);
```

例：
```
int returnValue = methodA(); // -> int returnValue = 100;

public static int methodA() {
  int x = 100;
  return x;
}
```

- return文は値を戻すだけでなく、メソッドの終了も行う。return文の後に処理を書いても実行できず、コンパイルエラーになる。

## オーバーロード
同じ名前のメソッドを定義することをオーバーロードという。
**仮引数の個数か型が異なれば、同じ名前のメソッドを複数定義できる。**

メソッド宣言で「戻り値の型」の後に記述する以下の情報をまとめて、メソッドのシグネチャと呼ぶ。
  - メソッド名、引数の個数・型・並び順
オーバーロードは、「シグネチャが重複しない場合のみ許される」とも言える。

## 引数や戻り値に配列を用いる
- 基本データ型の変数をメソッド呼び出しで渡すと
  - 呼び出し元の変数に入っている値が、呼び出し先の仮引数にコピーされる。
  - 呼び出し先で引数の内容を書き換えても、呼び出し元の変数は変化しない。
  - このように、**値そのものが渡される呼び出しを値渡しと呼ぶ。**

- 配列をメソッド呼び出しで渡すと
  - 呼び出し元の配列のアドレスが、呼び出し先の仮引数にコピーされる。
  - 呼び出し先で配列の実体を書き換えると、呼び出し元にも影響する。
  - このように、**引数としてアドレスを渡すことを参照渡しと呼ぶ。**参照渡しを行うと、「呼び出し先で加えた変更が呼び出し元にも影響する」ようになる。

## コマンドライン引数
プログラム起動時の追加情報のことを**コマンドライン引数**と呼ぶ。

- コマンドライン引数
java プログラム名 引数リスト(半角スペース区切り)
プログラム起動時に指定したコマンドライン引数が、JVMによって配列に変換され、mainメソッド起動時に渡される。

# 第6章 複数クラスを用いた開発
- Javaプログラムの完成品
  - Javaプログラムの完成品は、複数のクラスファイルの集合体。
  - 誰かに配布する場合には、すべてのクラスファイル（が入っているフォルダ）を渡す必要がある。

- JVMは起動時に指定されたクラスの中にあるmainメソッドを呼び出してプログラムの実行を開始する。
- よって、Javaのプログラムを実行する人は**「渡された複数のクラスファイルのうち、mainメソッドが含まれているクラスの名前」を指定する必要がある**
- そのため、Javaプログラムを配布・納品するときは、「どのクラスにmain()が入っているか」も伝える必要がある。
- Javaでは「複数のクラスファイルを1つにまとめるファイル形式」として**JAR**が定められている。

## パッケージ
- Javaには複数クラスを**パッケージ**というグループに所属させて、分類・管理できる仕組みがある。

- **クラスをパッケージに所属させるには、そのクラスのソースコードの先頭にpackage文を記述する。**

例：
```
package calcapp.main;
public class Calc {
```

- パッケージ名は、アルファベットは小文字を使うのが一般的。
- パッケージ名の一部が同じだったとしても、**それぞれのパッケージに親子関係や階層関係はない。**

別パッケージに属するクラスを利用する場合、所属パッケージ名を添えたクラスメイを指定する必要がある。
例：
```
package calcapp.main;
public class Calc {
  public static void main(String[] args) {
    ...
    int total = calcapp.logics.CalcLogic.tasu(a, b);
  }
}
```

別パッケージのクラスを利用する場合、「パッケージ名を頭につけた完全なクラス名」を使う必要がある。この完全なクラス名を、**完全限定クラス名**または略してFQCNという。

- 完全限定クラス名(FQCN)
パッケージ名.クラス名

## 名前空間
Javaではクラス名の衝突は原則として許されていない。使うことができる名前の総量（=名前空間）は限られている。
パッケージが異なれば、同じクラス名を使っても良いことになっている。パッケージが異なれば、完全限定クラス名が異なるので両者を区別できるからである。
パッケージを使うことで、それぞれのパッケージ内では自由にクラス名をつけることが可能になる。

- 推奨されるパッケージ名
  - パッケージ名は、「保有するインターネットドメインを前後逆順にしたもの」から始める。
  - ドメインは固有のものなので、こうすることでパッケージ名が衝突することはない。

#### 完全限定クラス名の入力を省略する
- FQCN入力の手間を省くための宣言
import パッケージ名.クラス名;

import文はソースコードの先頭に、ただしpackage文より後に記述する。

例：
```
package calcapp.main;
import calcapp.logics.CalcLogic;
public class Calc {
  public static void main(String[] args) {
    ...
    int total = CalcLogic.tasu(a, b) // FQCNでなくてもエラーにならない
  }
}
```

- パッケージに属するすべてのクラスをインポートしたい場合
```
import calcapp.logics.*;
```

## Java API
- JavaにはAPIとして200を超えるパッケージ、3500を超える多くのクラスが標準提供されている。
- **java.langパッケージに属するクラスは頻繁に利用するものが多いので、「特にimport文を記述しなくても自動的にインポートされる」という特別扱いを受けている。**

## クラスが読み込まれる仕組み
Javaのクラスローディングは、必要になった時に、必要なクラスだけを読み込みようになっている。
JVMのなかでクラスファイルを読み込む仕事をするのはクラスローダーという部分である。
クラスローダーは読み込み対象クラスのFQCNに基づき、クラスパスというヒント情報を使ってファイルを探し出す。
クラスパスの指定方法はいくつかあり、OSに登録しておくことなどができる。
クラスを作ったのにプログラムがうまく起動できない場合、まずクラスパスを確認する。

## パッケージに属したクラスの実行方法
javaコマンドの正確な構文
>java 起動したいクラスの完全限定クラス名

- クラスローダーの動作原則
あるパッケージx.y.zに属するクラスCを探す場合、クラスローダーは「クラスパスで指定されたフォルダ¥x¥y¥z¥C.class」というファイルを読み込もうとする。

つまり、**現在のクラスパスを基準として、パッケージ階層に対応したフォルダ階層を作り、その中に必要なクラスファイルを配置しておく必要がある。**

# 第7章 オブジェクト指向をはじめよう
- オブジェクト指向の目的
  人間が把握しきれない複雑さを克服するためにオブジェクト指向は生まれた。
- オブジェクト指向の学習は、「正解に辿り着くための考え方」を学ぶ。基本文法の学習が「正解自体を学ぶ」のであったこととは異なる。そのため、理解することやイメージすることを、より大事にする必要がある。

- オブジェクト指向の定義
  オブジェクト指向とは**ソフトウェアを開発するときに用いる部品下の考え方**のこと。

- オブジェクト指向を用いるメリット（初心者の時点でのもの）
  「ラクして、楽しく、良いもの」を作れる

## 責務
- 責務の割り当て
  オブジェクト指向プログラミングでは、プログラマはそれぞれの部品に「責務」をプログラムとして書き込む。

# 第8章 インスタンスとクラス
Javaプログラムの組成に必要なクラスたち
  - mainメソッドを含む、1つの「神様のクラス」
  - 複数の登場人物クラス

## クラス定義
クラスブロック内に宣言された変数 -> フィールド
finalをつけると定数フィールドになる。変数名は大文字が推奨される。
thisは自分自身のインスタンスを意味する。省略できる場合もあるが、フィールドを用いるときは明示的にthisをつけるのが良い。

例：
```
public class Hero {
  String name;
  int hp;
  void sit(int sec) { ... }
}
```

- インスタンスの生成
```
クラス名 変数名 = new クラス名();
```
例：　Hero h = new Hero();

- フィールドへの値の代入
```
変数名.フィールド名 = 値;
```

- メソッド呼び出し
```
変数名.メソッド名();
```

# 第9章 さまざまなクラス機構
Javaのプログラムを実行する際に、JVMが大量にメモリ領域を使って準備する領域（通常は数百MB~数GB）を**ヒープ**という。
インスタンスとは「ヒープの中に確保されたメモリ領域」である。

クラス型は参照型。クラス型の変数には、インスタンスのアドレス情報（参照）が入る。
1.まず変数から番地情報を取り出し、2.次に実際にその番地にアクセスする、というJVMの動作を**参照の解決**や**アドレス解決**という。

実はString型もクラス型。
  - java.langパッケージに宣言されている。
  - 二重引用符で文字列を囲めば、その文字列情報を持ったStringインスタンスを利用できるという特例が設けられている。

## コンストラクタ
- コンストラクタと見なされる条件
  1. メソッド名がクラス名と完全に等しい
  2. メソッド宣言に戻り値が記述されていない（voidもダメ）

例： newする際に引数を渡す
```
public class Hero {
  ...
  Hero(String name) {
    this.name = name;
  }
}

public Class Main {
  public static void main(String[] args) {
    Hero h = new Hero("ミナト");
    ...
  }
}
```

- 複数のコンストラクタが定義されていた場合
  newする時に渡した引数の型・数・順番に対応するコンストラクタが動作する（複数のコンストラクタが定義されていても、1つだけしか動作しない）。オーバーロードはコンストラクタでも可能ということ。

Javaでは、すべてのクラスはインスタンス化に際して必ず何らかのコンストラクタを実行することになっている。
ただし、クラスに1つもコンストラクタが定義されていない場合に限って、「引数なし、処理内容なし」のコンストラクタ（デフォルトコンストラクタ）の定義がコンパイル時に自動的に追加される。

- 別コンストラクタの呼び出しに関するルール
  「this.クラス名(引数);」と記述することはできない。その代わりに「this(引数);」と記述する。
  インスタンスの時に使っていたthisとは関係ない。

例：
```
  Hero(String name) {  // コンストラクタ①
    this.hp = 100;
    this.name = name;
  }
  Hero() {  // コンストラクタ②
    this("ダミー");
  }
```

## 静的メンバ
### 静的フィールド
同じクラスから生成されたインスタンスでフィールドを共有したい場合、フィールド宣言の先頭にstaticキーワードを追加する。
staticキーワードを指定したフィールドは特に静的フィールドといわれ、下記のような3つの特殊な効果をもたらす。
1. フィールド変数の実体がクラスに準備される。
  静的フィールドへのアクセス方法
  クラス名.静的フィールド名
2. 全インスタンスに、箱の分身が準備される。
  静的フィールドへの別名によるアクセス
  「インスタンス変数名.静的フィールド名」と書いてもよいが、「クラス名.静的フィールド名」と同じ意味になる。(同じ実体にアクセスすることになる) 
3. インスタンスを1つも生み出さなくても箱が利用可能になる。
  静的フィールドはクラスにフィールドが所属するという特徴から、クラス変数といわれることもある。

多くの場合、staticはfinalやpublicと一緒に指定され、「変化しない定数を各インスタンスで共有するため」に利用される。

### 静的メソッド
staticキーワードが付いているメソッドは、静的メソッドまたはクラスメソッドと呼ばれ、静的フィールドとあわせて**静的メンバ**と総称される。静的メソッドには以下の3つの効果が現れる。
1. メソッド自体がクラスに属するようになる　クラス名.メソッド名();で呼び出せる。
2. インスタンスにメソッドの分身が準備される　インスタンス変数名.メソッド名();でも呼び出せる。
3. インスタンスを1つも生み出すことなく呼び出せる

- 静的メソッドの制約
**静的メソッドの中に記述するコードでは、staticが付いていないフィールドやメソッドは利用できない。**

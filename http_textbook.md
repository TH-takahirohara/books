HTTPの教科書

## 2.7 持続的接続で通信料を節約
- HTTPの初期のバージョンでは、HTTPによる通信を1回行うごとにTCPによる接続と切断を行う必要があった。
- HTTP/1.1と一部のHTTP/1.0では、**持続的接続**という方法が考え出された。これは、どちらかが明示的に接続を切断しない限り、TCP接続を繋げっぱなしにしておくということ。
- これにより、TCPコネクションの接続と切断を繰り返すオーバーヘッドを減らせるので、その分Webページの表示が速くなる。
- これは、複数のリクエストを発行できる**パイプライン化**を可能にする。これにより、複数のリクエストを並行して発行できるので、1つ1つのレスポンスを待つ必要がなくなった。

## 2.8 Cookieを使った状態管理
- Cookieは、リクエストとレスポンスにCookieという情報を載せることによって、クライアントの状態を把握するための仕組み。
- Cookieは、サーバーからのレスポンスで送られたSet-Cookieというヘッダーフィールドによって、Cookieをクライアントに保存してもらうように指示を出す。次にクライアントが同じサーバーにリクエストを出す際には、クライアントが自動的に Cookieの値を入れて送信する。
- サーバーはクライアントが送ってきた Cookieを見ることで、どのクライアントからのアクセスなのかをチェックし、サーバー上の記録を確かめることで、以前の状態を知ることができる。

# 第3章 HTTPの情報はHTTPメッセージにある

## 3.1 HTTPメッセージ
- HTTPでやり取りされる情報はHTTPメッセージと呼ばれていて、リクエスト側のHTTPメッセージをリクエストメッセージ、レスポンス側をレスポンスメッセージと呼ぶ。
- HTTPメッセージを大きく分けると、メッセージヘッダーとメッセージボディから構成されて、空行が区切りになる。

## 3.2 リクエストメッセージとレスポンスメッセージの構造
- メッセージヘッダーの中身は、次のデータで構成される。
  - リクエストライン
  - ステータスライン
  - ヘッダーフィールド
    - 一般ヘッダーフィールド、リクエストヘッダーフィールド、レスポンスヘッダーフィールド、エンティティヘッダーフィールドの4種類
  - その他

## 3.3 エンコーディングで転送効率を上げる
- HTTPでデータを転送する場合、転送の際にエンコーディングを施すことで転送効率を上げることができる。
- メッセージ
- エンティティ
- コンテンツコーディング: エンティティに適用するエンコーディングのことで、エンティティの情報を保ったまま圧縮する。
- チャンク転送コーディング: エンティティを分割してから送信すること

## 3.4 複数のデータを送れるマルチパート
- マルチパート: MIMEの拡張仕様にある、複数の異なる種類のデータを格納する方式
  - MIME: メールでテキスト、画像、動画といった複数の異なるデータを扱うための仕組み
- HTTPもマルチパートに対応していて、1つのメッセージボディの中に複数のエンティティを含めて送ることができる。主に画像やテキストファイルなどのファイルアップロードの際に使われる。
- 詳細はRFC2046も参考のこと

## 3.5 一部分だけ貰えるレンジリクエスト
- 範囲を指定してリクエストを行うことを、**レンジリクエスト**と呼ぶ。
  - レジューム機能（以前ダウンロードを中断した箇所からダウンロードを再開できる）を実現する上で、エンティティの範囲を指定してDLを行う必要があり、その時などに使われる。
- レンジリクエストを行う場合、Rangeヘッダーフィールドを使って、リソースのバイトレンジを指定する。
- レンジリクエストに対するレスポンスは、ステータスコード206 Partial Contentが返される。

## 3.6 最適なコンテンツを返すコンテンツネゴシエーション
- 同じコンテンツだが、複数のページを持つWebページ（例えば、英語版と日本語版）について、クライアントに最も適したリソースを提供するための仕組みをコンテンツネゴシエーションと呼ぶ。
- コンテンツネゴシエーションでは、提供するリソースを言語や文字セット、エンコーディング方式などを基準に判断している。

# 第4章 結果を伝えるHTTPステータスコード

## 4.1 ステータスコードはサーバーからのリクエスト結果を伝える
- クライアントからサーバーに対してリクエストを送信したとき、その結果がどうだったのかということを伝えるのがステータスコードの役目
- ステータスコードは3桁の数値と説明で表す。（例：200 OK）
- 数値の最初の1桁でレスポンスのクラスを指定する。レスポンスのクラスは次の5つが定義されている。
  - 1XX: Informational リクエストが受け付けられて処理中
  - 2XX: Success リクエストは正常に処理を完了した
  - 3XX: Redirection リクエストが完了するには追加動作が必要
  - 4XX: Client Error サーバーはリクエストを理解できなかった
  - 5XX: Server Error サーバーはリクエストの処理を失敗した

## 4.2 2XX 成功 (Success)
- 200 OK
- 204 No Content
  - レスポンスにエンティティボディを含まない。
  - クライアントからサーバーに情報を送るだけでよく、クライアントに対して新たな情報を送る必要がない場合に使われる。
- 206 Partial Content

## 4.3 3XX リダイレクト (Redirection)
- 301 Moved Permantently
  - リクエストされたリソースには新しいURIが割り当てられているので、今後はそのリソースを参照するURIを使用すべきであるということを表す。
- 302 Found
  - リクエストされたリソースには新しいURIが割り当てられているので、そのURIを参照してほしいということを表す。ただし、移動はあくまで一時的なものである。
- 303 See Other
  - このレスポンスは、リクエストに対するリソースは別のURIにあるので、GETメソッドを使用して取得すべきであるということを表している。リダイレクト先をGETメソッドで取得するということが明確になっている点が302と意味が異なる。
- 304 Not Modified
- 307 Temporary Redirect

## 4.4 4XX クライアントエラー (Client Error)
- 400 Bad Request
  - リクエストの構文が間違っていることを表す。ブラウザはこれを200 OKと同様に扱う。
- 401 Unauthorized
  - 送信したリクエストにはHTTP認証の認証情報が必要であることを表す。すでに1度リクエストが行われている場合には、ユーザー認証に失敗したことを表す。
  - ブラウザで最初の401レスポンスを受け取った場合には、認証のためのダイアログが表示される。
- 403 Forbidden
  - リクエストされたリソースへのアクセスが拒否されたことを表す。
- 404 Not Found
  - リクエストしたリソースがサーバー上にないことを表す。

## 4.5 5XX サーバーエラー (Server Error)
- 500 Internal Server Error
  - サーバーでリクエストを実行する際にエラーが起きたことを表す。
- 503 Service Unavailable
  - サーバーが一時的な過負荷かメンテナンスのため、現在リクエストを処理することができないことを表す。

# 第5章 HTTPと連携するWebサーバー

## 5.1 1台で複数ドメインを実現するバーチャルホスト
- バーチャルホストの機能を使うと、物理的にはサーバーが 1台でも、仮想的に複数台あるかのように扱うことができる。
- 同じIPアドレスで、異なるホスト名やドメイン名を持った複数のWebサイトが稼動しているバーチャルホストの仕組みがあるため、HTTP リクエストを送る場合には、ホスト名やドメイン名を完全に含んだURIの指定か、Host ヘッダーフィールドでの指定が必ず必要になってくる。

## 5.2 通信を中継するプログラム：プロキシ、ゲートウェイ、トンネル

### プロキシ
- サーバーとクライアントの両方の役割をする中継プログラムで、クライアントからのリクエストをサーバーに転送し、サーバーからのレスポンスをクライアントに転送する。
- リソース本体を持ったサーバーのことを、オリジンサーバーと呼ぶ。
- プロキシを中継する際には、Viaヘッダーフィールドに経由したホストの情報を追加していく。
  - 例： proxy1, proxy2を経由したら、Via: proxy2, proxy1となる。
- プロキシサーバーを使用する理由としては、キャッシュを使ってネットワーク帯域などを効率よく使用することや、組織内で特定Webサイトに対するアクセス制限や、アクセスログを取得するといったポリシーを徹底させる目的として使用することもできる。
- プロキシは2つの基準で分類される。
  - キャッシュするかしないか　キャッシュするプロキシは**キャッシングプロキシ**と呼ぶ。
  - メッセージを変更するかしないか　中継時にメッセージに何ら変更を加えないタイプのプロキシを**透過型プロキシ**と呼ぶ

### ゲートウェイ
- 他のサーバーを中継するサーバーで、クライアントから受け取ったリクエストを、リソースを持っているサーバーであるかのように受け取る。
- ゲートウェイは、その先にあるサーバーがHTTPサーバー以外のサービスを提供するサーバーとなる。ゲートウェイを使うことで、HTTPリクエストによって、別のプロトコルを動作させることができる。

### トンネル
- 2つの離れたクライアントとサーバーの間で中継することで、2台の接続を取り持つ中継プログラム
- トンネルを使うことで、離れたサーバーと安全に通信させることができる。

## 5.3 リソースを保管するキャッシュ
- キャッシュ(Cache)は、プロキシサーバーやクライアントのローカルディスクに保存されたリソースのコピーのことを指す。キャッシュを使うことで、リソースを持ったサーバーへのアクセスを減らすことができるため、通信量や通信時間などを節約することができる。
- キャッシュサーバーというキャッシングプロキシの一種があり、転送時にリソースのコピーを保存する。キャッシュサーバーのメリットは、同じデータを何度もオリジンサーバーから転送する必要がなくなり、サーバー側が同じリクエストを何度も処理しなくて済むようになる。
- キャッシュには有効期限がある。
- キャッシュサーバーだけでなく、クライアントが使用するブラウザでもキャッシュを持つことができる。

# 第6章 HTTPヘッダー

## 6.1 HTTPメッセージヘッダー
- HTTPプロトコルのリクエストとレスポンスには、必ずメッセージヘッダーがあり、クライアントやサーバーの処理に必要な重要情報はほとんどこのメッセージヘッダーにある。
- メッセージヘッダーの要素の中で、最も多様な情報を持つのがHTTPヘッダーフィールド

## 6.2 HTTPヘッダーフィールド
- HTTPヘッダーフィールドは、メッセージボディのサイズや、使用している言語、認証情報などをブラウザやサーバーに提供するために使用される。

### HTTPヘッダーフィールドの構造
- HTTP ヘッダーフィールドは、ヘッダーフィールド名とフィールド値から構成されていて、コロンで区切られている。

### 4種類のHTTP ヘッダーフィールド
- HTTPヘッダーフィールドは、その用途に合わせて次の4種類に分類される。
  - 一般ヘッダーフィールド
  - リクエストヘッダーフィールド
  - レスポンスヘッダーフィールド
  - エンティティヘッダーフィールド

- HTTP/1.1ヘッダーフィールドには47種類ある。
- HTTP/1.1以外のヘッダーフィールドもある。（例えばCookieなど）非標準ヘッダーフィールドはRFC4229 HTTP Header Field Registrationsにまとめられている。

### エンドトゥエンドヘッダーとホップバイホップヘッダー
- HTTPヘッダーフィールドは、キャッシュと非キャッシュプロキシの振る舞いを定義する目的のために2つのカテゴリに分類されている。
  - エンドトゥエンドヘッダー
    - このカテゴリに分類されるヘッダーは、リクエストやレスポンスの最後の受信者宛に転送されるもの。
  - ホップバイホップヘッダー
    - 一度の転送に対して有効で、キャッシュやプロ棋士によって転送されたりしないものもある。

## 6.3 HTTP/1.1 一般ヘッダーフィールド
- 一般ヘッダーフィールドは、リクエストメッセージとレスポンスメッセージの両方で使用されるヘッダー
- Cache-Control
  - ディレクティブと呼ばれるコマンドを指定することで、キャッシングの動作を指定する
- Connection
  - プロキシに対してそれ以上転送しないヘッダーフィールドの指定
  - 持続的接続の管理
- Date
  - HTTPメッセージを生成した日時を示す。
- Pragma
  - HTTP/1.1より古いバージョンのなごりで、HTTP/1.0との後方互換性のためだけに定義されているヘッダーフィールド
  - Pragma: no-cacheと指定でき、クライアントが全ての中間サーバーに対して、キャッシュされたリソースでの応答を望まないことを要求するために使用される。
- Trailer
  - メッセージボディの後に記述されているヘッダーフィールドをあらかじめ伝えることができる。HTTP/1.1で実装されているチャンク転送エンコーディングを使用している場合に使うことができる。
- Transfer-Encoding
  - メッセージボディの転送コーディング形式を指定する場合に使用される。
  - HTTP/1.1において転送コーディング形式は、チャンク転送コーディングのみが定義されている。
- Upgrade
  - HTTPおよび他のプロトコルの新しいバージョンが通信に利用される場合に使用される。
- Via
  - クライアントとサーバー間でのリクエストまたはレスポンスのメッセージの経路を知るために使用される。
  - Viaヘッダーフィールドは、転送されるメッセージの追跡や、リクエストループの回避などに用いられるため、右プロキシを経由する場合には必ず付加する必要がある。
- Warning
  - レスポンスに関する追加情報を伝える。基本的にはキャッシュに関する問題の警告をユーザーに伝える。

## 6.4 リクエストヘッダーフィールド
- Accept
  - ユーザーエージェントが処理することができるメディアタイプと、メディアタイプの相対的な優先度を伝えるために使用される。
- Accept-Charset
  - ユーザーエージェントが処理することができる文字セットと、文字セットの相対的な優先度を伝えるために使用される。
- Accept-Encoding
  - ユーザーエージェントが処理することができるコンテンツコーディングと、コンテンツコーディングの相対的な優先度を伝えるために使用される。
- Accept-Language
  - ユーザーエージェントが処理することができるし全言語のセット（日本語や英語という意味）と、自然言語セットの相対的な優先度を伝えるために使用される。
- Authorization
  - ユーザーエージェントの認証情報（credentials値）を伝えるために使用される。
- Expect
- From
- Host
  - リクエストしたリソースのインターネットホストとポート番号を伝える。
  - HTTP/1.1で唯一の必須ヘッダーフィールド
  - 同じIPアドレスで複数のドメインが運用されていた場合に、どのドメインに対してのリクエストなのかを識別するために使う。
- If-Match
  - "If-xxx"という書式のリクエストヘッダーフィールドは、条件付きリクエストと呼ばれる。条件付きリクエストを受け取ったサーバーは、指定された条件が真の場合にのみリクエストを受け付ける。
  - If-Matchは、サーバー上のリソースを特定するためにエンティティタグ（ETag）値を伝える。
- If-Modified-Since
  - 指定されたフィールド値の日時以降にリソースが更新されていればリクエストを受け付ける。
- If-None-Match
- If-Range
- If-Unmodified-Since
- Max-Forwards
  - TRACEまたはOPTIONSメソッドによるリクエストの際に転送しても良いサーバー数の最大値を10進数の整数で指定する。
  - サーバーは、次のサーバーにリクエストを転送する際には、Max-Forwardsの値から1引いたものをセットし直す。Max-Forwardsの値が0のリクエストを受け取った場合には、転送せずにレスポンスを返す必要がある。
- Proxy-Authorization
- Range
- Referer
  - リクエストが発生した元のリソースのURIを伝える。
- TE
- User-Agent

## 6.5 レスポンスヘッダーフィールド
- Accept-Ranges
- Age
- ETag
- Location
- Proxy-Authenticate
- Retry-After
- Server
  - サーバーに実装されているHTTPサーバーのソフトウェアを伝える。
- Vary
  - オリジンサーバーからVaryで指定されたレスポンスを受け取ったプロキシサーバーは、以後はキャッシュしたときのリクエストと同様のVaryに指定されているヘッダーフィールドを持つリクエストに対してのみキャッシュを返すことができる。
- WWW-Authenticate

## 6.6 エンティティヘッダーフィールド
- Allow
- Content-Encoding
- Content-Language
- Content-Length
- Content-Location
- Content-MD5
  - コンテンツが偶発的に変更されたことは知ることができるが、悪意を持った改竄は検出できない。
- Content-Range
- Content-Type
  - エンティティボディに含まれるオブジェクトのメディアタイプを伝える。
- Expires
- Last-Modified

## 6.7 Cookieのためのヘッダーフィールド

### Set-Cookie
- サーバーがクライアントに対して状態管理を始める際に、さまざまな情報を伝える。
- フィールド値には次の情報が記される。
  - NAME=VALUE　：　Cookieにつける名前とその値（必須）
  - expires=DATE　：　Cookieの有効期限（指定しない場合はブラウザを閉じるまで）
  - path=PATH　：　Cookieの適用対象となるサーバー上のディレクトリ（指定しない場合はドキュメントと同じディレクトリ）
  - domain=ドメイン名　：　Cookieの適用対象となるドメイン名（指定しない場合はCookieを生成したサーバーのドメイン名）　後方一致になるので、明示的に複数のドメインに対してCookieを送出する場合を除いて、domain属性は指定しない方が安全。
  - Secure　：　HTTPSで通信している場合にのみCookieを送信
  - HttpOnly　：　CookieをJavaScriptからアクセスできないように制限する。クロスサイトスクリプティングからCookieの盗聴を防ぐことを目的としている。

### Cookie
- クライアントがHTTPの状態管理のサポートを望むときに、サーバーから受け取ったCookieを以後のリクエストに含めて伝える。Cookieを複数受け取っている場合には、複数のクッキーを送ることもできる。

## 6.8 その他のヘッダーフィールド
- HTTPヘッダーフィールドは、独自に拡張を行うことができる。よく使うのは以下。
- X-Frame-Options
  - 他のWebサイトのフレームでの表示を制御するHTTPレスポンスヘッダーで、クリックジャッキングという攻撃を防ぐことを目的としている。
- X-XSS-Protection
  - クロスサイトスクリプティング(XSS)対策としてのブラウザのXSS保護機能を制御するHTTPレスポンスヘッダーです。
- DNT
- P3P

# 第7章 Webを安全にするHTTPS

## 7.1 HTTPの弱点
- HTTPは主に次のような弱点を持っている。
  - 通信が平文（暗号化しない）なので盗聴可能
  - 通信相手を確かめないのでなりすまし可能
  - 完全性を証明できないので改竄可能

### 通信が平文なので盗聴可能
- 通信が平文であることが弱点になる理由は、TCP/IPの仕組みとして通信の内容はすべて通信経路の途中で覗き見ることができるからである。暗号化されている場合も同様に通信内容を除き見れるが、メッセージの中身の意味は読み取れない。
- 盗聴から情報を守るための方法で最も普及している技術が暗号化。暗号化にはいくつかの対象がある。
  - 通信の暗号化
    - SSLやTLSというHTTPとは別のプロトコルを組み合わせることで、HTTPの通信内容を暗号化できる。
    - SSLなどによって安全な通信路を確立してから、その通信路を使ってHTTPの通信を行う。このSSLを組み合わせたHTTPは、HTTPSやHTTP over SSLと呼ばれる。
  - コンテンツの暗号化
    - もう1つは、通信しているコンテンツの内容自体を暗号化してしまうこと。
    - この場合、クライアント側でHTTPメッセージを暗号化して出力するような処理が必要になる。
    - 通信経路を暗号化するわけではないので、改竄やなりすましの危険性などが残る。

### 通信相手を確かめないのでなりすまし可能
- HTTPによる通信は、相手が誰かを確かめる処理はない。それゆえにシンプルな実装になり普及したという面もあるが、弱点に繋がることもある。
  - リクエストを送った先のWebサーバーが、なりすましたWebサーバーである恐れがある。
  - 通信相手が、アクセスを許可された者であるかどうか確認できない。
  - どこの誰がリクエストしたのかを確認できない。
  - 意味のないリクエストでも受け付けてしまうので、大量のリクエストによるDoS攻撃を防ぐことができない。
- SSLは暗号化だけでなく、証明書と呼ばれる相手を確かめる手段を提供している。
  - 通信相手のサーバーやクライアントが持っている証明書を確認することで、通信相手が本来意図した相手であるかどうかを判断することができる。

### 完全性を証明できないので改竄可能
- 完全性というのは情報の正確さを指す。HTTPが完全性を証明できないということは、もしリクエストやレスポンスが発信されてから相手が受け取るまでの間に改竄されたとしても、それを知ることができないということである。
- 途中で攻撃者によってリクエストやレスポンスを横取りされて改竄される攻撃を中間者攻撃と呼ぶ。
- HTTPを使って完全性を確かめるための方法はあるが、確実で便利な方法は今のところ存在しない。その中でもよく使われている方法は、MD5やSHA-1などのハッシュ値を確かめる方法と、ファイルのデジタル署名を確認する方法である。
- 改竄を確実に防ぐにはHTTPSを使う必要がある。SSLには認証や暗号化、そしてダイジェスト機能を提供している。

## 7.2 HTTP+暗号化+認証+完全性保護=HTTPS
- 暗号化や認証などの仕組みをHTTPに付け加えたものをHTTPS（HTTP Secure）と呼ぶ。
- HTTPSは新しいアプリケーション層のプロトコルではない。HTTPの通信を行うソケット部分をSSLやTLSというプロトコルに置き換えているだけ。SSLを使用した場合には、HTTPはSSLと通信し、SSLがTCPと通信するようになる。
- SSLを使うことで、HTTPはHTTPSとして暗号化と証明書と完全性保護を利用することができるようになる。
- SSLはHTTPだけでなくアプリケーション層で動作する他のプロトコルにも使うことができる。SSLは現在最も広く使われているネットワークセキュリティ技術と言える。
- SSLでは公開鍵暗号方式と呼ばれる暗号化方式を採用している。現代の暗号は、アルゴリズムは公開されていて鍵を秘密にすることで安全性を保つ。暗号化や復号には、この鍵を使う。

#### 共通鍵暗号
- 暗号化と復号に同じ1つの鍵を使用する方式を共通鍵暗号と呼ぶ。
- 共通鍵暗号方式は、相手に鍵を渡さなければならないが、相手に安全に鍵を渡すのが難しいのが問題である。

#### 公開鍵暗号
- 公開鍵暗号では異なる2つの鍵ペアを使う。片方は秘密鍵、もう一方は公開鍵と呼ばれる。
- 公開鍵暗号を使った暗号化は、暗号を送る側が相手の公開鍵を使って暗号化を行う。そして、暗号化された情報を受け取った相手は自分の秘密鍵を使って復号を行う。この方式は、暗号を解く秘密鍵を通信で送る必要がないので、鍵を盗聴で盗まれる心配がない。

#### HTTPSはハイブリッド暗号システム
- HTTPSは、共通鍵暗号と公開鍵暗号の両方を使うハイブリッド暗号システムである。鍵を安全に交換できるなら、公開鍵暗号だけを使って通信しても良いと考えるかもしれないが、公開鍵暗号は共通鍵暗号に比べて処理速度が遅い。
- そこで、それぞれの方式を組み合わせて通信を行う。具体的には、共通鍵暗号で使う鍵を交換するところまでは公開鍵暗号を使い、その後の通信でメッセージを交換するところでは共通鍵暗号を使う。

### 公開鍵が正しいかどうかを証明する証明書
- 公開鍵暗号方式の問題点は、公開鍵が本物であるかどうかを証明できないということ。
- この問題の解決には、認証局（CA：Certificate Authority）とその期間が発行する公開鍵証明書が利用される。
- 認証局とは、クライアントとサーバーが双方ともに信頼する第三者機関がその立場に立つ。認証局は証明機関と呼ばれることもある。
- 認証局の利用方法は下記
  1. サーバーの運営者が、サーバーの公開鍵を認証局に登録
  2. 認証局は、認証局の秘密鍵でサーバーの公開鍵にデジタル署名して公開鍵証明書を作成し、サーバーに送る
  3. サーバーは公開鍵証明書をクライアントに送って、公開鍵暗号で通信を開始する。
  4. クライアントは、サーバーの公開鍵証明書（サーバーの公開鍵+認証局のデジタル署名からなる。デジタル証明書とも呼ぶ。）を入手し、デジタル署名を認証局の公開鍵で検証し、公開鍵が本物かを確認
    - 認証局の公開鍵はあらかじめブラウザに組み込まれている。
  5. クライアントは、サーバーの公開鍵で暗号化しメッセージを送信
  6. サーバーは、サーバーの秘密鍵でメッセージを復号

#### 組織の実在性を証明するEV SSL証明書
- 証明書には、相手が実在する企業であるかを確かめるという役割もある。そういう役割を持った証明書をEV SSL証明書と言う。
- EV SSL証明書で証明されたWebサイトは、ブラウザのアドレスバーの色が緑色になるので視覚的にわかる。これはフィッシング詐欺の防止を意図したものだが、多くのユーザーはEV SSL証明書のことを知らないので、効果のほどは疑問である。

#### クライアント証明書
- HTTPSではクライアント証明書も利用できる。これを利用することで、サーバー証明書と同じく、サーバーが通信している相手が意図したクライアントであることを証明するクライアント認証を行うことができる。
- クライアント証明書にはいくつかの問題点がある。
  - 証明書の入手と配布の問題　ユーザーが有料で購入する必要がある
  - クライアント証明書はあくまでクライアントの実在を証明するだけで、ユーザーの実在を証明するわけではない
    - クライアント証明書が入ったコンピュータを使う権限があれば、クライアント証明書を利用できてしまう。

#### 自己認証局発行の証明書はオレオレ証明書
- OpenSSLなどのソフトウェアを使えば、誰でも認証局を構築することができ、サーバー証明書を発行できる。しかし、このサーバー証明書はインターネット上では証明書としての用をなさない。
- 独自に構築した認証局を自己認証局と呼び、そこが発行した役に立たない証明書を揶揄してオレオレ証明書と呼ぶことがある。
- オレオレ証明書を使ったWebサイトにブラウザでアクセスすると警告メッセージが表示される。
- オレオレ証明書が役に立たないのは、なりすましの可能性を払拭できないからである。

### 安全な通信を行うHTTPSの仕組み
- 通信手順は12段階ほどある。詳細は省略

#### SSLとTLS
- SSL3.0をベースにしたTLS1.0が作成され、TLS1.1、TLS1.2がある。現在はSSL3.0、TLS1.0が主流である。
- TLSはSSLを元にしたプロトコルだが、これらを総称してSSLと呼ぶこともある。

#### SSLは遅い
- HTTPSの問題点として、SSLを使うと処理が遅くなると言うことがある。
- SSLの遅さには2種類ある。
  - 通信が遅くなる TCP接続とHTTPのリクエスト・レスポンス以外にSSLに必要な通信が入るため
  - CPUやメモリなどのリソースを多量に消費することで処理が遅くなる 暗号化や複合のための計算にリソースを割く。

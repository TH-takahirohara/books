HTTPの教科書

## 2.7 持続的接続で通信料を節約
- HTTPの初期のバージョンでは、HTTPによる通信を1回行うごとにTCPによる接続と切断を行う必要があった。
- HTTP/1.1と一部のHTTP/1.0では、**持続的接続**という方法が考え出された。これは、どちらかが明示的に接続を切断しない限り、TCP接続を繋げっぱなしにしておくということ。
- これにより、TCPコネクションの接続と切断を繰り返すオーバーヘッドを減らせるので、その分Webページの表示が速くなる。
- これは、複数のリクエストを発行できる**パイプライン化**を可能にする。これにより、複数のリクエストを並行して発行できるので、1つ1つのレスポンスを待つ必要がなくなった。

## 2.8 Cookieを使った状態管理
- Cookieは、リクエストとレスポンスにCookieという情報を載せることによって、クライアントの状態を把握するための仕組み。
- Cookieは、サーバーからのレスポンスで送られたSet-Cookieというヘッダーフィールドによって、Cookieをクライアントに保存してもらうように指示を出す。次にクライアントが同じサーバーにリクエストを出す際には、クライアントが自動的に Cookieの値を入れて送信する。
- サーバーはクライアントが送ってきた Cookieを見ることで、どのクライアントからのアクセスなのかをチェックし、サーバー上の記録を確かめることで、以前の状態を知ることができる。

# 第3章 HTTPの情報はHTTPメッセージにある

## 3.1 HTTPメッセージ
- HTTPでやり取りされる情報はHTTPメッセージと呼ばれていて、リクエスト側のHTTPメッセージをリクエストメッセージ、レスポンス側をレスポンスメッセージと呼ぶ。
- HTTPメッセージを大きく分けると、メッセージヘッダーとメッセージボディから構成されて、空行が区切りになる。

## 3.2 リクエストメッセージとレスポンスメッセージの構造
- メッセージヘッダーの中身は、次のデータで構成される。
  - リクエストライン
  - ステータスライン
  - ヘッダーフィールド
    - 一般ヘッダーフィールド、リクエストヘッダーフィールド、レスポンスヘッダーフィールド、エンティティヘッダーフィールドの4種類
  - その他

## 3.3 エンコーディングで転送効率を上げる
- HTTPでデータを転送する場合、転送の際にエンコーディングを施すことで転送効率を上げることができる。
- メッセージ
- エンティティ
- コンテンツコーディング: エンティティに適用するエンコーディングのことで、エンティティの情報を保ったまま圧縮する。
- チャンク転送コーディング: エンティティを分割してから送信すること

## 3.4 複数のデータを送れるマルチパート
- マルチパート: MIMEの拡張仕様にある、複数の異なる種類のデータを格納する方式
  - MIME: メールでテキスト、画像、動画といった複数の異なるデータを扱うための仕組み
- HTTPもマルチパートに対応していて、1つのメッセージボディの中に複数のエンティティを含めて送ることができる。主に画像やテキストファイルなどのファイルアップロードの際に使われる。
- 詳細はRFC2046も参考のこと

## 3.5 一部分だけ貰えるレンジリクエスト
- 範囲を指定してリクエストを行うことを、**レンジリクエスト**と呼ぶ。
  - レジューム機能（以前ダウンロードを中断した箇所からダウンロードを再開できる）を実現する上で、エンティティの範囲を指定してDLを行う必要があり、その時などに使われる。
- レンジリクエストを行う場合、Rangeヘッダーフィールドを使って、リソースのバイトレンジを指定する。
- レンジリクエストに対するレスポンスは、ステータスコード206 Partial Contentが返される。

## 3.6 最適なコンテンツを返すコンテンツネゴシエーション
- 同じコンテンツだが、複数のページを持つWebページ（例えば、英語版と日本語版）について、クライアントに最も適したリソースを提供するための仕組みをコンテンツネゴシエーションと呼ぶ。
- コンテンツネゴシエーションでは、提供するリソースを言語や文字セット、エンコーディング方式などを基準に判断している。

# 第4章 結果を伝えるHTTPステータスコード

## 4.1 ステータスコードはサーバーからのリクエスト結果を伝える
- クライアントからサーバーに対してリクエストを送信したとき、その結果がどうだったのかということを伝えるのがステータスコードの役目
- ステータスコードは3桁の数値と説明で表す。（例：200 OK）
- 数値の最初の1桁でレスポンスのクラスを指定する。レスポンスのクラスは次の5つが定義されている。
  - 1XX: Informational リクエストが受け付けられて処理中
  - 2XX: Success リクエストは正常に処理を完了した
  - 3XX: Redirection リクエストが完了するには追加動作が必要
  - 4XX: Client Error サーバーはリクエストを理解できなかった
  - 5XX: Server Error サーバーはリクエストの処理を失敗した

## 4.2 2XX 成功 (Success)
- 200 OK
- 204 No Content
  - レスポンスにエンティティボディを含まない。
  - クライアントからサーバーに情報を送るだけでよく、クライアントに対して新たな情報を送る必要がない場合に使われる。
- 206 Partial Content

## 4.3 3XX リダイレクト (Redirection)
- 301 Moved Permantently
  - リクエストされたリソースには新しいURIが割り当てられているので、今後はそのリソースを参照するURIを使用すべきであるということを表す。
- 302 Found
  - リクエストされたリソースには新しいURIが割り当てられているので、そのURIを参照してほしいということを表す。ただし、移動はあくまで一時的なものである。
- 303 See Other
  - このレスポンスは、リクエストに対するリソースは別のURIにあるので、GETメソッドを使用して取得すべきであるということを表している。リダイレクト先をGETメソッドで取得するということが明確になっている点が302と意味が異なる。
- 304 Not Modified
- 307 Temporary Redirect

## 4.4 4XX クライアントエラー (Client Error)
- 400 Bad Request
  - リクエストの構文が間違っていることを表す。ブラウザはこれを200 OKと同様に扱う。
- 401 Unauthorized
  - 送信したリクエストにはHTTP認証の認証情報が必要であることを表す。すでに1度リクエストが行われている場合には、ユーザー認証に失敗したことを表す。
  - ブラウザで最初の401レスポンスを受け取った場合には、認証のためのダイアログが表示される。
- 403 Forbidden
  - リクエストされたリソースへのアクセスが拒否されたことを表す。
- 404 Not Found
  - リクエストしたリソースがサーバー上にないことを表す。

## 4.5 5XX サーバーエラー (Server Error)
- 500 Internal Server Error
  - サーバーでリクエストを実行する際にエラーが起きたことを表す。
- 503 Service Unavailable
  - サーバーが一時的な過負荷かメンテナンスのため、現在リクエストを処理することができないことを表す。

# 第5章 HTTPと連携するWebサーバー

## 5.1 1台で複数ドメインを実現するバーチャルホスト
- バーチャルホストの機能を使うと、物理的にはサーバーが 1台でも、仮想的に複数台あるかのように扱うことができる。
- 同じIPアドレスで、異なるホスト名やドメイン名を持った複数のWebサイトが稼動しているバーチャルホストの仕組みがあるため、HTTP リクエストを送る場合には、ホスト名やドメイン名を完全に含んだURIの指定か、Host ヘッダーフィールドでの指定が必ず必要になってくる。

## 5.2 通信を中継するプログラム：プロキシ、ゲートウェイ、トンネル

### プロキシ
- サーバーとクライアントの両方の役割をする中継プログラムで、クライアントからのリクエストをサーバーに転送し、サーバーからのレスポンスをクライアントに転送する。
- リソース本体を持ったサーバーのことを、オリジンサーバーと呼ぶ。
- プロキシを中継する際には、Viaヘッダーフィールドに経由したホストの情報を追加していく。
  - 例： proxy1, proxy2を経由したら、Via: proxy2, proxy1となる。
- プロキシサーバーを使用する理由としては、キャッシュを使ってネットワーク帯域などを効率よく使用することや、組織内で特定Webサイトに対するアクセス制限や、アクセスログを取得するといったポリシーを徹底させる目的として使用することもできる。
- プロキシは2つの基準で分類される。
  - キャッシュするかしないか　キャッシュするプロキシは**キャッシングプロキシ**と呼ぶ。
  - メッセージを変更するかしないか　中継時にメッセージに何ら変更を加えないタイプのプロキシを**透過型プロキシ**と呼ぶ

### ゲートウェイ
- 他のサーバーを中継するサーバーで、クライアントから受け取ったリクエストを、リソースを持っているサーバーであるかのように受け取る。
- ゲートウェイは、その先にあるサーバーがHTTPサーバー以外のサービスを提供するサーバーとなる。ゲートウェイを使うことで、HTTPリクエストによって、別のプロトコルを動作させることができる。

### トンネル
- 2つの離れたクライアントとサーバーの間で中継することで、2台の接続を取り持つ中継プログラム
- トンネルを使うことで、離れたサーバーと安全に通信させることができる。

## 5.3 リソースを保管するキャッシュ
- キャッシュ(Cache)は、プロキシサーバーやクライアントのローカルディスクに保存されたリソースのコピーのことを指す。キャッシュを使うことで、リソースを持ったサーバーへのアクセスを減らすことができるため、通信量や通信時間などを節約することができる。
- キャッシュサーバーというキャッシングプロキシの一種があり、転送時にリソースのコピーを保存する。キャッシュサーバーのメリットは、同じデータを何度もオリジンサーバーから転送する必要がなくなり、サーバー側が同じリクエストを何度も処理しなくて済むようになる。
- キャッシュには有効期限がある。
- キャッシュサーバーだけでなく、クライアントが使用するブラウザでもキャッシュを持つことができる。

# 第6章 HTTPヘッダー

## 6.1 HTTPメッセージヘッダー
- HTTPプロトコルのリクエストとレスポンスには、必ずメッセージヘッダーがあり、クライアントやサーバーの処理に必要な重要情報はほとんどこのメッセージヘッダーにある。
- メッセージヘッダーの要素の中で、最も多様な情報を持つのがHTTPヘッダーフィールド

## 6.2 HTTPヘッダーフィールド
- HTTPヘッダーフィールドは、メッセージボディのサイズや、使用している言語、認証情報などをブラウザやサーバーに提供するために使用される。

### HTTPヘッダーフィールドの構造
- HTTP ヘッダーフィールドは、ヘッダーフィールド名とフィールド値から構成されていて、コロンで区切られている。

### 4種類のHTTP ヘッダーフィールド
- HTTPヘッダーフィールドは、その用途に合わせて次の4種類に分類される。
  - 一般ヘッダーフィールド
  - リクエストヘッダーフィールド
  - レスポンスヘッダーフィールド
  - エンティティヘッダーフィールド

- HTTP/1.1ヘッダーフィールドには47種類ある。
- HTTP/1.1以外のヘッダーフィールドもある。（例えばCookieなど）非標準ヘッダーフィールドはRFC4229 HTTP Header Field Registrationsにまとめられている。

### エンドトゥエンドヘッダーとホップバイホップヘッダー
- HTTPヘッダーフィールドは、キャッシュと非キャッシュプロキシの振る舞いを定義する目的のために2つのカテゴリに分類されている。
  - エンドトゥエンドヘッダー
    - このカテゴリに分類されるヘッダーは、リクエストやレスポンスの最後の受信者宛に転送されるもの。
  - ホップバイホップヘッダー
    - 一度の転送に対して有効で、キャッシュやプロ棋士によって転送されたりしないものもある。

## 6.3 HTTP/1.1 一般ヘッダーフィールド
- 一般ヘッダーフィールドは、リクエストメッセージとレスポンスメッセージの両方で使用されるヘッダー
- Cache-Control
  - ディレクティブと呼ばれるコマンドを指定することで、キャッシングの動作を指定する
- Connection
  - プロキシに対してそれ以上転送しないヘッダーフィールドの指定
  - 持続的接続の管理
- Date
  - HTTPメッセージを生成した日時を示す。
- Pragma
  - HTTP/1.1より古いバージョンのなごりで、HTTP/1.0との後方互換性のためだけに定義されているヘッダーフィールド
  - Pragma: no-cacheと指定でき、クライアントが全ての中間サーバーに対して、キャッシュされたリソースでの応答を望まないことを要求するために使用される。
- Trailer
  - メッセージボディの後に記述されているヘッダーフィールドをあらかじめ伝えることができる。HTTP/1.1で実装されているチャンク転送エンコーディングを使用している場合に使うことができる。
- Transfer-Encoding
  - メッセージボディの転送コーディング形式を指定する場合に使用される。
  - HTTP/1.1において転送コーディング形式は、チャンク転送コーディングのみが定義されている。
- Upgrade
  - HTTPおよび他のプロトコルの新しいバージョンが通信に利用される場合に使用される。
- Via
  - クライアントとサーバー間でのリクエストまたはレスポンスのメッセージの経路を知るために使用される。
  - Viaヘッダーフィールドは、転送されるメッセージの追跡や、リクエストループの回避などに用いられるため、右プロキシを経由する場合には必ず付加する必要がある。
- Warning
  - レスポンスに関する追加情報を伝える。基本的にはキャッシュに関する問題の警告をユーザーに伝える。

## 6.4 リクエストヘッダーフィールド
- Accept
  - ユーザーエージェントが処理することができるメディアタイプと、メディアタイプの相対的な優先度を伝えるために使用される。
- Accept-Charset
  - ユーザーエージェントが処理することができる文字セットと、文字セットの相対的な優先度を伝えるために使用される。
- Accept-Encoding
  - ユーザーエージェントが処理することができるコンテンツコーディングと、コンテンツコーディングの相対的な優先度を伝えるために使用される。
- Accept-Language
  - ユーザーエージェントが処理することができるし全言語のセット（日本語や英語という意味）と、自然言語セットの相対的な優先度を伝えるために使用される。
- Authorization
  - ユーザーエージェントの認証情報（credentials値）を伝えるために使用される。
- Expect
- From
- Host
  - リクエストしたリソースのインターネットホストとポート番号を伝える。
  - HTTP/1.1で唯一の必須ヘッダーフィールド
  - 同じIPアドレスで複数のドメインが運用されていた場合に、どのドメインに対してのリクエストなのかを識別するために使う。
- If-Match
  - "If-xxx"という書式のリクエストヘッダーフィールドは、条件付きリクエストと呼ばれる。条件付きリクエストを受け取ったサーバーは、指定された条件が真の場合にのみリクエストを受け付ける。
  - If-Matchは、サーバー上のリソースを特定するためにエンティティタグ（ETag）値を伝える。
- If-Modified-Since
  - 指定されたフィールド値の日時以降にリソースが更新されていればリクエストを受け付ける。
- If-None-Match
- If-Range
- If-Unmodified-Since
- Max-Forwards
  - TRACEまたはOPTIONSメソッドによるリクエストの際に転送しても良いサーバー数の最大値を10進数の整数で指定する。
  - サーバーは、次のサーバーにリクエストを転送する際には、Max-Forwardsの値から1引いたものをセットし直す。Max-Forwardsの値が0のリクエストを受け取った場合には、転送せずにレスポンスを返す必要がある。
- Proxy-Authorization
- Range
- Referer
  - リクエストが発生した元のリソースのURIを伝える。
- TE
- User-Agent

## 6.5 レスポンスヘッダーフィールド
- Accept-Ranges
- Age
- ETag
- Location
- Proxy-Authenticate
- Retry-After
- Server
  - サーバーに実装されているHTTPサーバーのソフトウェアを伝える。
- Vary
  - オリジンサーバーからVaryで指定されたレスポンスを受け取ったプロキシサーバーは、以後はキャッシュしたときのリクエストと同様のVaryに指定されているヘッダーフィールドを持つリクエストに対してのみキャッシュを返すことができる。
- WWW-Authenticate

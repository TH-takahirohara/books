SQL 第2版 ゼロから始めるデータベース操作

# 第0章 イントロダクション
macでのpostgresqlインストール
- [この記事](https://qiita.com/ksh-fthr/items/b86ba53f8f0bccfd7753)を参照

設定後のログイン
```
psql -Upostgres
```

DBの作成、psqlの終了
```
postgres=# CREATE DATABASE shop;
CREATE DATABASE
postgres=# \q
```

学習用データベースshopへのログイン
```
% psql -Upostgres -dshop
psql (13.1)
Type "help" for help.

shop=#
```
後の章ではこのDBでSQLを実行していく。

# 第1章 データベースとSQL

## 1-1 データベースとは何か
- 大量の情報を保存し、コンピュータから効率よくアクセスできるように加工したデータの集まりのことを「データベース」と呼ぶ。
- データベースを管理するコンピュータシステムのことを、「データベース管理システム（DBMS）」と呼ぶ。
- DBMSを使うことにより、大量のデータを多人数でも安全かつ簡単に扱える。
- 本書では「リレーショナルデータベース（RDB）」を「SQL」という専門言語で操作する方法を学ぶ。RDBは「リレーショナルデータベース管理システム（RDBMS）」で管理する。

## 1-2 データベースの構成
- RDBMSは一般に、「クライアント／サーバ型」のシステム構成で使用される。
- RDBMSはサーバの一種で、ハードディスクに保存されているデータベースからデータを取り出して返したり、指示された内容でデータを書き換えたりする。
- RDBMSのクライアント（サーバに要求を出すプログラム）は、サーバであるRDBMSにSQL文を送信する。RDBMSはその文の内容に従ってデータを返信したりする。
- **SQL文の内容に従ってクライアントに返信されるデータも、必ずテーブルと同じように2次元表の形になる。**
- テーブルの行はレコードとも呼び、1件のデータに相当する。**RDBでは、必ず行単位でデータを読み書きする。**
- 行と列が交わる1つのマス目を、本書ではセルと呼ぶ。**1つのセルの中には、1つのデータしか入れられない。**

## 1-3 SQLの概要
- SQLにはISOで定められた標準規格があり、それに準拠したSQLを**標準SQL**と呼ぶ。最近は様々なRDBMSで標準SQLのサポートが進んでいるので、標準SQLの書き方を覚えると良い。（本書も標準SQLでの書き方を解説する。）
- SQL文は、RDBMSに与える命令の種類により、次の3つに分類される。最も使われるのはDML。
  - DDL（データ定義言語） CREATE, DROP, ALTER
  - DML（データ操作言語） SELECT, INSERT, UPDATE, DELETE
  - DCL（データ制御言語） COMMIT, ROLLBACK, GRANT, REVOKE
- SQL文の書き方にはいくつかの決まりがある。
  - SQL文の最後にセミコロンをつける。
  - キーワードの大文字・小文字は区別されない。
  - 定数の書き方には決まりがある。
    - SQL文の中に直に書く文字列や日付、数値などを定数と呼ぶ。
    - 文字列はシングルクォーテーションで囲む。数値は何かの記号で囲む必要はない。
  - 単語は半角スペースか改行で区切る。

## 1-4 テーブルの作成
- RDBMS上にデータベースを作成するSQL文
```
CREATE DATABASE <データベース名>;
```
- テーブルの作成
```
CREATE TABLE <テーブル名>
(<列名1> <データ型> <この列の制約>,
 <列名2> <データ型> <この列の制約>,
 <列名3> <データ型> <この列の制約>
 ...
 <このテーブルの制約1>, <このテーブルの制約2>, ...);
```
- DBやテーブル、列などの名前に使って良い文字は、半角のアルファベット、半角数字、アンダーバーのみである。
- 名前の最初の文字は「半角のアルファベット」にする。
- 名前は重複してはならない。（1つのデータベースに同じ名前のテーブルを2つは作れない）

### データ形
- CHAR型：　固定長文字列　CHAR(8)などで最大文字数を指定する。格納する文字数が最大長に満たない場合は、空白スペースで埋める
- VARCHAR型：　可変長文字列　格納する文字数が最大長に満たなくても、そのまま格納する。

### キー
- キーとは、特定のデータを指定するときに使う列の組み合わせのこと。
- 主キーは1つの行を特定できる列のこと。主キー制約を設定すると、その列には重複した値を格納できない。

## 1-5 テーブルの削除と変更

### テーブルの削除
```
DROP TABLE <テーブル名>;
```
- **削除したテーブルは復活できないので、実行前によく確認すること。**

### テーブル定義の変更
- 後からテーブルの定義を変更するにはALTER TABLE文を使う。
- 列を追加する場合
```
ALTER TABLE <テーブル名> ADD COLUMN <列の定義>;
```
- **テーブル定義を変更したら元に戻せないので注意**

# 第2章 検索の基本

## 2-1 SELECT文の基本
- テーブルからデータを取り出すときはSELECT文を使う。
- 基本的なSELECT文
```
SELECT <列名>, ...
  FROM <テーブル名>;
```
- SELECT文にはSELECT句とFROM句という2つの「**句**」がある。句はSQL文を構成する要素で、SELECTやFROMなどのキーワードから始まるフレーズ。

### 列に別名をつける
- SQL文では、ASキーワードを使って、列に別名をつけられる。別名はSELECT文の実行結果を見やすくしたり扱いやすくするために使う。
- 別名には日本語を使うこともできる。その場合は、別名をダブルクォーテーションで囲む。

### 結果から重複行を省く
- 重複行を省いて結果を得たいときは、DISTINCTというキーワードを使う。
```
例：
SELECT DISTINCT shohin_bunrui
  FROM Shohin;
```
- DISTINCTは複数列の前にも置くことができる。この場合、複数の列を組み合わせてもなお重複する行が1つにまとめられる。
- DISTINCTは先頭の列名の前にしか書けない。

### WHERE句
- SELECT文では、選択したい行の条件をWHERE句で指定する。
```
SELECT <列名>, ...
  FROM <テーブル名>
  WHERE <条件式>;

例：
SELECT shohin_mei, shohin_bunrui
  FROM Shohin
  WHERE shohin_bunrui = '衣服';
```
- 実行順としては、WHERE句で指定した条件に合う行をまず選択し、その後にSELECT句で指定された列を出力する。
- SQLでは句の記述順が決まっており、勝手に変えることはできない。WHERE句はFROM句の直後に置く。

## 2-2 算術演算子と比較演算子
- SELECT句には計算式も書ける。演算は行ごとに行われる。
### 算術演算子
- 四則演算を行う記号は算術演算子と呼ばれる。
- NULLを含んだ計算は、問答無用でNULLになるので注意。
  - 5 + NULL = 5 という結果が欲しいケースに対応する方法も用意されている（6-1節）

### 比較演算子
- =記号のように、両辺に記述した列や値を比較する記号のことを比較演算子とよぶ。
- 以上（>=）あるいは以下（<=）は、必ず不等号が左側、イコールが右側になるように書く。
- 文字列型の順序の原則は辞書式。数値の大小順序と混同してはいけない。
  - 例： 文字列型では次のような順序になる。　1, 10, 11, 2, 222, 3
- NULLである行を選択したい時は、条件式にIS NULL演算子を使う。NULLでない行を選択したい場合は、IS NOT NULL演算子を使う。

## 2-3 論理演算子
- 条件を否定するのはNOT演算子。しかし、無理に使う必要はない。
```
NOT演算子の例

SELECT shohin_mei, shohin_bunrui, hanbai_tanka
  FROM Shohin
  WHERE NOT hanbai_tanka >= 1000;
```
- 複数の検索条件を組み合わせる時は、AND演算子とOR演算子を使う。
- OR演算子よりAND演算子の方が優先される。OR演算子を優先したいときは、両辺をカッコ()で囲む。
- NOT,AND,ORは論理演算子。ここでいう論理とは真理値を操作すること。真理値はTRUEかFALSEのいずれかになる値のこと。
  - 比較演算子は演算の結果として真理値を返す。論理演算子は、比較演算子などが返した真理値を操作する。

### NULLを含む真理値
- NULLを含む比較演算の結果としての真理値は、「不明（UNKNOWN）」という第三の値になる。

# 第3章 集約と並べ替え

## 3-1 テーブルを集約して検索する
- SQLでデータに対して何らかの操作や計算を行うには、「**関数**」を使う。
- 集計用の関数を「**集約関数**」という。代表的なものは、COUNT, SUM, AVG, MAX, MIN
  - 集約関数はすべて、複数行の入力から1行を出力する働きをもつ。

### 使い方の例（COUNT関数の場合）
- COUNT関数は、テーブルの列を入力すると、行数を出力する。
- テーブルの全行を数えたい場合は、入力（引数）をアスタリスクにする。アスタリスクはすべての列を意味する。
- COUNT関数は引数によって動作が異なる。COUNT(*)はNULLを含む行数を、COUNT(<列名>)は当該列のNULLを除外した行数を数える。（この特性はCOUNT関数だけに当てはまる特殊なもの。）
```
全行数を数える
SELECT COUNT(*)
  FROM Shohin;

特定列のNULLを除外した行数を数える
SELECT COUNT(shiire_tanka)
  FROM Shohin;
```

### その他の集約関数
- 合計を求める関数はSUM関数。NULLを含む列を入力としても合計値が出力される。
- **すべての集約関数は、列名を引数に取った場合、計算前にNULLを除外する。ただしCOUNT(*)は例外的にNULLを除外しない。**
- 平均値を求める関数はAVG関数。NULLの場合、その分レコード数は減る。
  - NULLを0とみなしてNULLのレコード数も含めて平均を取りたい場合がある。実現方法は第6章で取り上げる。
- 最大値・最小値を求める関数はMAX、MIN関数。
- MAX/MIN関数はほとんどすべて（順序をつけられる）のデータ型に適用できる。一方、SUM/AVG関数は数値のみにしか使えない。
- ある列について、値の種類を数えたい時は、COUNT関数の引数にDISTINCTをつける。
- 重複値を除外して集約するには、集約関数の引数にDISTINCTをつける。

## 3-2 テーブルをグループに切り分ける
- テーブルを幾つかのグループに切り分けるために使うのがGROUP BY句である。
```
-- GROUP BY句の構文
SELECT <列名1>, <列名2>, <列名3>, ...
  FROM <テーブル名>
  GROUP BY <列名1>, <列名2>, <列名3>, ...;

-- 例：　商品分類ごとの行数を数える
SELECT shohin_bunrui, COUNT(*)
  FROM Shohin
  GROUP BY shohin_bunrui;

-- 結果
shohin_bunrui | count
--------------+-------
衣服           |     2
事務用品        |     2
キッチン用品    |     4 
```
- GROUP BY句はケーキを切り分けるようにテーブルをカットしてグループ分けする。
- GROUP BY句に指定する列のことを集約キーやグループ化列とよぶ。
- GROUP BY句の位置は、WHERE句より後ろに置く。
- 集約キーにNULLが含まれる場合、結果にも「不明」行（空行）として現れる。

### WHERE句を使った場合のGROUP BYの動作
- WHERE句をつけた集約を行う場合、WHERE句で指定した条件で先にレコードが絞り込まれてから集約が行われる。
- つまり、**GROUP BY/WHEREを併用する場合の実行順序は、　FROM -> WHERE -> GROUP BY -> SELECT**

### よくある間違い

#### よくある間違い① - SELECT句に余計な列を書いてしまう
- 集約関数を使うときは、次の3つしかSELECT句に書くことができない。
  - 定数
  - 集約関数
  - GROUP BY句で指定した列名（つまり集約キー）
- GROUP BY句を使う時は、SELECT句に集約キー以外の列名を書けないので注意。

#### よくある間違い② - GROUP BY句に別の列名を書いてしまう
- GROUP BY句にSELECT句でつけた別名（AS ...のやつ）は使えない。理由は、SELECT句がGROUP BY句よりも後に実行されるから。

#### よくある間違い③ - GROUP BY句は結果の順序をソートする？
- GROUP BY句を使って結果を選択した時、表示の順はランダムである。ソートされるわけではない。
- ソートするためにはそのための指定をきっちりとSELECT文でしておく必要がある。（3-4節参照）

#### よくある間違い④ - WHERE句に集約関数を書いてしまう
- 集約関数を書ける場所はSELECT句とHAVING句（とORDER BY句）だけ。

## 3-3 集約した結果に条件を指定する
- GROUP BY句で分けたグループに対して条件を指定して選択する場合はどうするか。
- WHERE句は「レコード（行）」に対してのみしか条件を指定できない。グループに対する条件指定（「平均値が500」など）には**HAVING句**を使う。

```
-- HAVING句の構文
SELECT <列名1>, <列名2>, <列名3>, ...
  FROM <テーブル名>
  GROUP BY <列名1>, <列名2>, <列名3>, ...
  HAVING <グループの値に対する条件>
```
- HAVING句はGROUP BY句の後ろに書く。

### HAVING句に書ける要素
- HAVING句に書ける要素は次の3つ。（GROUP BY句と同じ。）
  - 定数
  - 集約関数
  - GROUP BY句で指定した列名（つまり集約キー）

### HAVING句よりもWHERE句に書いたほうが良い条件
- 集約キーに対する条件は、HAVING句ではなくWHERE句に書く。

## 3-4 検索結果を並べ替える
- 一般に、テーブルからデータを選択する場合、その順番は、特に指定がない限りはランダムである。
- 順番を指定したい時にはORDER BY句を使う。
```
-- ORDER BY句の構文
SELECT <列名1>, <列名2>, <列名3>, ...
  FROM <テーブル名>
  ORDER BY <並べ替えの基準となる列1>, <並べ替えの基準となる列2>, ...
```
- ORDER BY句はSELECT文の最後に書く。また、ORDER BY句に書く列名を**ソートキー**と呼ぶ。
- ORDER BY句で並び順を指定しないと暗黙的に昇順扱いになる。
- 降順に並べる場合は列名の後ろに**DESCキーワード**を使う。（昇順も正式にはASCキーワードがある。）
```
...
ORDER BY hanbai_tanka DESC;
```
- ASCとDESCのキーワードは列単位で指定するものなので、1つの列は昇順を指定し、別の列は降順を指定するということも可能。

### 複数のソートキーを指定する
- ORDER BY句は複数のソートキーを指定できる。左側のキーから優先的に使用され、そのキーで同じ値が存在した場合に、右のキーが参照される、というルールがある。

### ソートキーにNULLがある場合
- ソートキーにNULLが含まれていた場合、そのレコード群は先頭か末尾にまとめられる。

### ソートキーに表示用の別名を使う
- ORDER BY句では、SELECT句でつけた列の別名を使うことができる。
- これは、SELECT文の実行順序が FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY となっており、ORDER BY句の実行時にSELECT句で列の別名が定義されているからである。

### ORDER BY句に使える列
- ORDER BY句では、SELECT句に含まれていない列や集約関数も使える。

# 第4章 データの更新

## 4-1 データの登録 (INSERT文の使い方)
- テーブルにデータ（行）を登録するにはINSERT文を使う。
```
-- INSERT文の基本構文
INSERT INTO <テーブル名> (列1, 列2, 列3, ...) VALUES (値1, 値2, 値3, ...);

-- 使用例
INSERT INTO ShohinIns (shohin_id, shohin_mei, shohin_bunrui, hanbai_tanka, shiire_tanka, torokubi) VALUES ('0001', 'Tシャツ', '衣服', 1000, 500, '2009-09-20');
```
- 外側をカッコ()でくくった形式をリストと呼ぶ。列のリストを列リスト、値のリストを値リストという。
- 原則として、INSERT文は1回の実行で1行を挿入する。
  - 複数行INSERTもあるが、エラーが出た時にどの行のどの箇所がエラーだったのか特定するのが難しいということと、Oracleでは利用できないことという注意点がある。

### 列リストの省略
- テーブル名の後の列リストは、テーブルの全列に対してINSERTを行う場合省略できる。

### NULLを挿入する
- INSERT文で、ある列にNULLを割り当てたい場合は、VALUES句の値リストにNULLをそのまま記述する。ただし、NOT NULL制約のついている列に指定すると当然エラーとなる。

### デフォルト値を挿入する
- 列にデフォルト値を設定するには、CREATE TABLE文の中で列に対してDEFAULT制約をつける。
```
CREATE TABLE ShohinIns
(...
hanbai_tanka INTEGER DEFAULT 0, -- 販売単価のデフォルト値を0に設定
...
);
```
- 利用方法には「明示的な方法」と「暗黙的な方法」の2種類がある。
  - 1. 明示的にデフォルト値を指定する -> VALUES句にDEFAULTキーワードを指定する。
  ```
  INSERT INTO ShohinIns (..., hanbai_tanka, ...) VALUES (..., DEFAULT, ...)
  ```
  - 2. 暗黙的にデフォルト値を挿入する -> デフォルト値が設定されている列を、列リストからも値リストからも省略する。
- 著者の私見では、明示的な書き方がおすすめ。ぱっと見てデフォルト値が利用されていることが分かり、意味が捉えやすいため。
- デフォルト値が設定されていない列を省略した場合は、NULLが割り当てられる。

### ほかのテーブルからデータをコピーする
- データを挿入する方法としては、他のテーブルからコピーするという方法もある。INSERT ••• SELECT文を使う。
```
-- 商品テーブルのデータを商品コピーテーブルへ「コピー」
INSERT INTO ShohinCopy (shohin_id, shohin_mei, shohin_bunrui, hanbai_tanka, shiire_tanka, torokubi)
SELECT shohin_id, shohin_mei, shohin_bunrui, hanbai_tanka, shiire_tanka, torokubi
  FROM Shohin;
```
- INSERT文内のSELECT文では、WHERE句やGROUP BY句など、どんなSQL構文も使うことができる。（ただし、ORDER BY句は使っても効果がない。）

## 4-2 データの削除 (DELETE文の使い方)
- データの削除方法は大きく分けて2つある。
  - 1. DROP TABLE文によって、テーブルそのものを削除する。
  - 2. DELETE 文によって、テーブルは残したまま、テーブル内のすべての行を削除する。(本章ではこちらを扱う)

### DELETE文の基本構文
```
-- 基本構文（全行削除に対応する）
DELETE FROM <テーブル名>;
```
- DELETE文の削除対象はテーブルや列ではなく「レコード（行）」である。「DELETE <列名> FROM <テーブル名>」などとするのは間違い。

### 削除対象を制限したDELETE文（探索型DELETE）
- 一部の行だけを削除する場合は、WHERE句で条件を記述する。
```
DELETE FROM <テーブル名>
  WHERE <条件>;
```

## 4-3 データの更新 (UPDATE文の使い方)
- テーブルのデータを変更（更新）するにはUPDATE文を使う。
```
-- UPDATE文の基本構文（全行同一の値に変更する）
UPDATE <テーブル名>
  SET <列名> = <式>;
```

### 条件を指定したUPDATE文 (探索型UPDATE)
- 更新対象の行を制限するには、DELETE文の時と同様、WHERE句を使う。
```
UPDATE <テーブル名>
  SET <列名> = <式>
  WHERE <条件>;
```

### NULLで更新するには
- UPDATE文では列をNULLで更新する（NULLクリアと呼ぶ）こともできる。ただし、NOT NULL制約のついていない列に限る。
```
例：
UPDATE Shohin
  SET torokubi = NULL
  WHERE shohin_id = '0008';
```

### 複数列の更新
- 1つのUPDATE文で複数列の更新ができる。
```
-- 1. 列をカンマ区切りで並べる
UPDATE Shohin
  SET hanbai_tanka = hanbai_tanka * 10,
      shiire_tanka = shiire_tanka / 2
  WHERE shohin_bunrui = 'キッチン用品';

-- 2. 列をカッコで囲むことによるリスト表現
UPDATE Shohin
  SET (hanbai_tanka, shiire_tanka) = (hanbai_tanka * 10, shiire_tanka / 2)
  WHERE shohin_bunrui = 'キッチン用品';
```
- 方法1はどのDBMSでも利用できるが、方法2は一部のDBMSでしか使用できないため、方法1が確実。

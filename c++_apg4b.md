C++入門 AtCoder Programming Guide for beginners (APG4b)

## 3.01.数値型
int は10^9程度まで
それより大きな値には `int64_t` 型を使う

### 数値型の変換　キャスト
```
(型)値
(double)a
```

double型をint型にキャストすると小数点以下が切り捨てになる。

### 文字列との変換
- 数値型から文字列への変換　`to_string`関数
- 文字列からint型に変換　`stoi`関数

## 3.02.pair/tupleとauto
### pair/tuple
- 宣言・初期化
```
pair<型1, 型2> 変数名;
pair<型1, 型2> 変数名(値1, 値2);
```

- アクセス
```
変数名.first   // 1つ目の値
変数名.second  // 2つ目の値
```

- pairの生成
```
make_pair(値1, 値2)
pair<型1, 型2>(値1, 値2)
```

## 3.03.STLのコンテナ
### map
- 連想配列や辞書と呼ばれるデータ構造
- mapの宣言
```
map<Keyの型, Valueの型> 変数名;
```

- mapの操作

| 操作 | 記法 | 計算量 |
| --- | --- | --- |
| 値の追加 | `変数[key] = value;` | O(logN) |
| 値の削除 | `変数.erase(key);` | O(logN) |
| 値へのアクセス | `変数.at(key)` | O(logN) |
| 所属判定 | `変数.count(key)` | O(logN) |
| 要素数の取得 | `変数.size()` | O(1) |

## 3.04.構造体
- 構造体の定義
```
struct 構造体名 {
  型1 メンバ変数名1
  型2 メンバ変数名2
  型3 メンバ変数名3
  ...(必要な分だけ書く)
};  // ← セミコロンが必要
```

- 宣言と同時に初期化
```
構造体名 オブジェクト名 = {メンバ変数1の値, メンバ変数2の値, メンバ変数3の値, ...(必要な分だけ書く)};
```

- メンバ関数の定義
```
struct 構造体名 {
  返り値の型 メンバ関数名(引数の型1 引数名1, 引数の型2 引数名2, ...) {
    // 関数の内容
    //   (ここではメンバ変数に直接アクセスすることができる)
  }
};
```

## 3.05.ビット演算
### STLのbitset
- 宣言・初期化
```
bitset<ビット数> 変数名;  // すべてのビットが0の状態で初期化される
bitset<ビット数> 変数名("ビット列(長さはビット数に合わせる)");  // 指定したビット列で初期化される
```

- ビット演算

| ビット演算 | bitsetの演算子 | 使い方 |
| --- | --- | --- |
| ビット毎のAND演算 | `&` | `変数1 & 変数2` |
| ビット毎のOR演算 | `|` | `変数1 | 変数2` |
| ビット毎のXOR演算 | `^` | `変数1 ^ 変数2` |
| ビット毎のNOT演算 | `~` | `~変数` |
| 論理左シフト演算 | `<<` | `変数 << シフトするビット数` |
| 論理右シフト演算 |  `>>` | `変数 << シフトするビット数` |

### ビット全探索
- 2のk乗の値を得るために、1 << kという書き方をすることがよくある。

### ビット全探索の雛形
```
for (int tmp = 0; tmp < (1 << ビット数); tmp++) {
  bitset<ビット数> s(tmp);
  // (ビット列sに対する処理)
}
```

### bitsetと整数の相互変換
- 整数からbitsetへの変換
```
bitset<ビット数> 変数名(整数);
```

- bitsetから整数への変換
```
bitsetの変数.to_ullong()
```
bitsetのビット数が64ビットを超えている場合は、整数に変換できずに実行時エラーになる。

### 2進数リテラル
`0b`に続けて01のビット列を書く。

## 4.03.テンプレート
- テンプレートは構造体や関数の「型」を一般化するための機能
- 関数テンプレート
```
template <typename テンプレート引数>
返り値の型 関数名(引数の型 引数...(必要な分だけ書く)) {
  // 処理内容
}
```

- 関数テンプレートとして定義された関数の呼び出し
```
関数名<テンプレート引数>(引数1, 引数2, ...);
```

- クラステンプレートの宣言
```
template <typename テンプレート引数>
struct 構造体名 {
  (構造体の内容)
};
```

- クラステンプレートを用いて定義された構造体の使用
```
構造体名<テンプレート引数>
```

## 4.04.イテレータ
- イテレータの型
通常は`auto`を用いる。

- イテレータが指す要素へのアクセス
```
*イテレータ
```

- イテレータが指す要素のメンバへのアクセス
```
イテレータ->メンバ変数
イテレータ->メンバ関数()  // メンバ関数の呼び出し
```

#### イテレータの使用例
- 各要素に対して処理
```
for (auto it = コンテナ.begin(); it != コンテナ.end(); it++) {
  // 各要素に対する処理
}
```

### 注意点
- コンテナに対して要素の削除や追加を行うと、操作前のイテレータが無効化されることがある。無効なイテレータを使用することは未定義の動作を引き起こす。

### STLの関数の紹介
#### lower_bound
- イテレータの範囲内から指定した値以上の最小の要素を探し、その要素を指すイテレータを返す。指定する範囲がソート済みである必要がある。
- 配列の場合
```
lower_bound(イテレータ1, イテレータ2, 値)  // 見つからなかった場合はイテレータ2を返す
```
- map/setの場合　メンバ関数版のlower_boundを用いる方が高速
```
オブジェクト.lower_bound(イテレータ1, イテレータ2, 値)  // 見つからなかった場合はイテレータ2を返す
```

## 4.05.ポインタ
- ポインタの基本的な使い方は、以下の3つ
  - `&変数`で変数のアドレスを得ることができる
  - `型 *ポインタ名`でポインタを定義
  - `*ポインタ`でポインタの指すメモリ領域へのアクセス(書き込み・読み込み)

- ポインタの宣言
```
型 *ポインタ名;  // ポインタ変数の宣言
```

- ポインタの指す先の変更
```
ポインタ = &変数; // 変数のアドレスでポインタを初期化
ポインタ = 別のポインタ; // 別のポインタと同じアドレスを指す
```

- ポインタの指す先へのアクセス
```
*ポインタ
```

- ポインタそのものへのアクセス
```
ポインタ
```

- ポインタの指す先のメンバアクセス
```
オブジェクトを指すポインタ->メンバ
```

### ヒープ領域の確保
- ヒープ領域のメモリを確保する
```
型 *ポインタ1 = new 型;        // 1つ分の領域を確保
型 *ポインタ2 = new 型(引数);   // 1つ分の領域を確保(コンストラクタに引数を渡す)
型 *ポインタ3 = new 型[n];     // 連続したn個分の領域を確保
```
- ヒープ領域のメモリを解放する
```
delete ポインタ1;   //「new 型」や「new 型()」で確保したときに返ってきたポインタ
delete[] ポインタ3; //「new 型[n]」で確保したときに返ってきたポインタ
```

- 例
```
#include <bits/stdc++.h>
using namespace std;

int main() {
  uint32_t *p;

  // uint32_t型の変数10個分だけ(つまり4*10=40バイト分)ヒープ領域からメモリを確保する
  // pには先頭のメモリのアドレスが代入される
  p = new uint32_t[10];

  // ポインタを介して使う
  uint32_t *tmp = p;  // アドレス値のコピー
  for (int i = 0; i < 10; i++) {
    cout << tmp << endl;
    // 下記のインクリメントで、tmpは次のアドレスへのポインタになる
    tmp++;
  }


  // メモリを解放する(10個分連続で確保したのでdelete[]を使う)
  delete[] p;
}

// 上記の標準出力　uint32_t型の値は1つの変数で4byte文のメモリを確保するので、4byteずつアドレスが増えているのが分かる
0x560d5ca65e70
0x560d5ca65e74
0x560d5ca65e78
0x560d5ca65e7c
0x560d5ca65e80
0x560d5ca65e84
0x560d5ca65e88
0x560d5ca65e8c
0x560d5ca65e90
0x560d5ca65e94
```
